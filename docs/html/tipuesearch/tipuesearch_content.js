var tipuesearch = {"pages":[{"title":" GENEUS ","text":"GENEUS Developer Info Jabir Ali Ouassou","tags":"home","loc":"index.html"},{"title":"stdio.f90 – GENEUS","text":"Contents Modules stdio_m Source Code stdio.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: System !> !> This file renames the ISO input/output units to the standard UNIX names, !> defines the ANSI escape codes for colored output, and defines a number of !> auxiliary subroutines for e.g. writing out error and warning messages. module stdio_m use , intrinsic :: iso_fortran_env public ! Declare standard input/output units integer :: stdin = input_unit integer :: stdout = output_unit integer :: stderr = error_unit ! Define escape codes for terminal colors character ( * ), parameter :: color_none = '\u001b[00m' character ( * ), parameter :: color_red = '\u001b[31m' character ( * ), parameter :: color_green = '\u001b[32m' character ( * ), parameter :: color_yellow = '\u001b[33m' character ( * ), parameter :: color_blue = '\u001b[34m' character ( * ), parameter :: color_purple = '\u001b[35m' character ( * ), parameter :: color_cyan = '\u001b[36m' character ( * ), parameter :: color_white = '\u001b[37m' ! Declare public interfaces interface dump module procedure dump_arrays , dump_scalar end interface contains subroutine message ( msg ) !!  Provides a way to report a status message. character ( * ), intent ( in ) :: msg write ( stderr , '(a)' ) color_green // ' >> INFO: ' // color_none // msg flush ( stderr ) end subroutine subroutine warning ( msg ) !!  Provides a way to report a warning message. character ( * ), intent ( in ) :: msg write ( stderr , '(a)' ) color_yellow // ' >> WARNING: ' // color_none // msg flush ( stderr ) end subroutine subroutine error ( msg ) !!  Provides a way to report an error message and halt the program. character ( * ), intent ( in ) :: msg write ( stderr , '(a)' ) color_red // ' >> ERROR: ' // color_none // msg flush ( stderr ) stop end subroutine subroutine status_head ( title ) !!  Provides a way to write boxed status messages to standard out; in !!  particular, this routine writes out a boxed title with a timestamp. character ( len =* ), intent ( in ) :: title character ( len = 33 ) :: title_ real :: time integer :: hh , mm , ss ! Calculate the current time call cpu_time ( time ) hh = int ( time / 360 0.0 ) mm = int ( mod ( time , 360 0.0 ) / 6 0.0 ) ss = int ( mod ( time , 6 0.0 )) ! adjust the provided title title_ = '' title_ (( len ( title_ ) - len ( title ) + 1 ) / 2 :) = title ! Write out the boxed header flush ( unit = stdout ) write ( stdout , * ) write ( stdout , '(a)' ) & '╒═══════════════════════════════════╕' write ( stdout , '(a)' ) & '│ ' // title_ // ' │' write ( stdout , '(a)' ) & '├───────────────────────────────────┤' write ( stdout , '(a,3x,a,7x,i3.2,a,i2.2,a,i2.2,3x,a)' ) & '│' , 'Elapsed time:' , hh , ':' , mm , ':' , ss , '│' end subroutine subroutine status_body ( title , value ) !!  Provides a way to write boxed status messages to standard out; in !!  particular, this routine writes out the name and value of a variable. character ( len =* ), intent ( in ) :: title class ( * ), intent ( in ) :: value character ( len = 20 ) :: title_ ! Adjust the provided title title_ = trim ( title ) // ':' ! Print out the title and value ! TODO: Use a kind selector when that is supported. select type ( value ) type is ( integer ) ! Standard integers write ( stdout , '(a,3x,a,i10  ,2x,a)' ) '│' , title_ , value , '│' type is ( real ) ! Single-precision reals write ( stdout , '(a,3x,a,f10.8,2x,a)' ) '│' , title_ , value , '│' type is ( double precision ) ! Double-precision reals write ( stdout , '(a,3x,a,g10.8,2x,a)' ) '│' , title_ , value , '│' end select end subroutine subroutine status_foot () !!  Provides a way to write boxed status messages to standard out; in !!  particular, this routine writes out the bottom edge of such a box. ! Write out the boxed footer write ( stdout , '(a)' ) & '╘═══════════════════════════════════╛' ! Flush the information to standard out flush ( unit = stdout ) end subroutine subroutine status_box ( title ) !!  Provides a way to write boxed status messages to standard out. character ( len =* ), intent ( in ) :: title character ( len = 33 ) :: title_ ! Adjust the provided title title_ = '' title_ (( len ( title_ ) - len ( title ) + 1 ) / 2 :) = title ! Write out the boxed message write ( stdout , * ) write ( stdout , '(a)' ) & '╒═══════════════════════════════════╕' write ( stdout , '(a)' ) & '│ ' // title_ // ' │' write ( stdout , '(a)' ) & '╘═══════════════════════════════════╛' end subroutine function input ( file ) result ( unit ) !!  Open an input file for reading. character ( len =* ), intent ( in ) :: file integer :: unit integer :: iostat ! Open the output file open ( newunit = unit , file = file , iostat = iostat , action = 'read' , status = 'old' ) if ( iostat /= 0 ) then call error ( 'Failed to open input file \"' // file // '\"!' ) end if end function function output ( file ) result ( unit ) !!  Open an output file for writing. character ( len =* ), intent ( in ) :: file integer :: unit integer :: iostat ! Open the output file open ( newunit = unit , file = file , iostat = iostat , action = 'write' , status = 'replace' ) if ( iostat /= 0 ) then call error ( 'Failed to open output file \"' // file // '\"!' ) end if end function subroutine dump_arrays ( filename , arrays , header ) !!  Dump numerical arrays to an output file. use :: iso_fortran_env character ( len =* ), intent ( in ) :: filename real ( real64 ), dimension (:), intent ( in ) :: arrays character ( len =* ), dimension (:), intent ( in ) :: header real ( real64 ), dimension ( size ( arrays ) / size ( header ), size ( header )) :: matrix integer :: unit integer :: n ! Reshape the data matrix = reshape ( arrays , shape ( matrix )) ! Open the output file unit = output ( filename ) ! Write the header line write ( unit , '(*(a20,:,\"        \"))' ) '# ' // header ( 1 ), header ( 2 :) ! Loop over the matrix rows do n = 1 , size ( matrix , 1 ) ! Write the matrix column to file write ( unit , '(*(es20.12e3,:,\"        \"))' ) matrix ( n , :) end do ! Close the output file close ( unit = unit ) end subroutine subroutine dump_scalar ( filename , scalar ) !!  Dump a numerical result to an output file. use :: iso_fortran_env character ( len =* ), intent ( in ) :: filename real ( real64 ), intent ( in ) :: scalar character ( len = 2048 ) :: str integer :: unit integer :: n ! Open the output file unit = output ( filename ) ! Write out command-line arguments do n = 1 , command_argument_count () call get_command_argument ( n , str ) write ( unit , '(a,\"        \")' , advance = 'no' ) trim ( str ) end do ! Write the scalar value to file write ( unit , '(*(es20.12e3,:,\"        \"))' ) scalar ! Close the output file close ( unit = unit ) end subroutine end module","tags":"","loc":"sourcefile/stdio.f90.html"},{"title":"evaluate.f90 – GENEUS","text":"Contents Modules evaluate_m Source Code evaluate.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This module has functions that evaluate textual expressions as Fortran data. !> This includes functions for converting mathematical expressions as arrays. module evaluate_m use :: math_m use :: stdio_m private ! Declare which routines to export public :: evaluate ! Declare public interfaces interface evaluate module procedure & evaluate_scalar_value , evaluate_scalar_field , & evaluate_vector_value , evaluate_vector_field , & evaluate_logical_value , evaluate_integer_value end interface contains subroutine evaluate_logical_value ( expression , value ) !!  Takes a scalar logical expression as input and returns the value. !! !!  Usage: !! !!      call evaluate_logical_value('F', output) !!      call evaluate_logical_value('T', output) !! character ( * ), intent ( in ) :: expression !! Character 'T' or 'F' logical , intent ( out ) :: value !! Parsed expression select case ( expression ) case ( 'T' , 't' ) value = . true . case ( 'F' , 'f' ) value = . false . case default call error ( 'Invalid logical expression: \"' // trim ( expression ) // '\"' ) end select end subroutine subroutine evaluate_integer_value ( expression , value ) !!  Takes a scalar integer expression as input and returns the value. !! !!  Usage: !! !!      call evaluate_integer_value('10', output) !! character ( * ), intent ( in ) :: expression !! Numerical expression integer , intent ( out ) :: value !! Parsed result integer :: iostat read ( expression , * , iostat = iostat ) value if ( iostat /= 0 ) then call error ( 'Invalid integer expression: \"' // trim ( expression ) // '\"' ) end if end subroutine subroutine evaluate_scalar_value ( expression , value ) !!  Takes a scalar mathematical expression as input and returns the value. !! !!  Usage: !! !!      call evaluate_scalar_value('0',                    output) !!      call evaluate_scalar_value('sin(0.3*pi)*exp(-pi)', output) !! use :: fparser character ( * ), intent ( in ) :: expression !! Mathematical expression real ( wp ), intent ( out ) :: value !! Parsed result ! Make sure the expression is non-empty if ( scan ( expression , '0123456789pi' ) <= 0 ) then call error ( 'Invalid scalar expression: \"' // trim ( expression ) // '\"' ) end if ! Initialize the function parser call initf ( 1 ) call parsef ( 1 , expression , [ 'pi' ]) ! Evaluate the parsed function value = evalf ( 1 , [ pi ]) end subroutine subroutine evaluate_scalar_field ( expression , domain , value ) !!  Evaluates a scalar-valued function of 'z' at the provided values for 'z'. !! !!  Usage: !! !!      call evaluate_scalar_value('0',                    input(1:n), output(1:n)) !!      call evaluate_scalar_value('sin(pi*z)*exp(-pi*z)', input(1:n), output(1:n)) !! use :: fparser character ( * ), intent ( in ) :: expression !! Function of 'z' real ( wp ), dimension (:), intent ( in ) :: domain !! Values of 'z' real ( wp ), dimension (:), allocatable :: value !! Parsed result integer :: n ! Make sure the expression is non-empty if ( scan ( expression , '0123456789piz' ) <= 0 ) then call error ( 'Invalid scalar expression: \"' // trim ( expression ) // '\"' ) end if ! Initialize the function parser call initf ( 1 ) call parsef ( 1 , expression , [ 'pi' , 'z ' ]) ! Allocate memory for the output allocate ( value ( size ( domain ))) ! Evaluate the parsed function do n = 1 , size ( domain ) value ( n ) = evalf ( 1 , [ pi , domain ( n )]) end do end subroutine subroutine evaluate_vector_value ( expression , value ) !!  Takes a vector mathematical expression as input and returns the value. !! !!  Usage: !! !!      call evaluate_scalar_value('[0,0,0]',                     output(1:3)) !!      call evaluate_scalar_value('[sin(0.3*pi),0,cos(0,3*pi)]', output(1:3)) !! use :: fparser character ( * ), intent ( in ) :: expression !! Mathematical expression real ( wp ), dimension ( 3 ), intent ( out ) :: value !! Parsed result integer , dimension ( 4 ) :: sep ! Find the vector delimiters sep ( 1 ) = scan ( expression , '[' , back = . false .) sep ( 2 ) = scan ( expression , ',' , back = . false .) sep ( 3 ) = scan ( expression , ',' , back = . true .) sep ( 4 ) = scan ( expression , ']' , back = . true .) ! Make sure the expressions are non-empty if ( sep ( 1 ) <= 0 . or . any ( sep ( 2 : 4 ) - sep ( 1 : 3 ) <= 1 )) then call error ( 'Invalid vector expression: \"' // trim ( expression ) // '\"' ) end if if ( scan ( expression ( sep ( 1 ) + 1 : sep ( 2 ) - 1 ), '0123456789pi' ) <= 0 . or . & scan ( expression ( sep ( 2 ) + 1 : sep ( 3 ) - 1 ), '0123456789pi' ) <= 0 . or . & scan ( expression ( sep ( 3 ) + 1 : sep ( 4 ) - 1 ), '0123456789pi' ) <= 0 ) & then call error ( 'Invalid vector expression: \"' // trim ( expression ) // '\"' ) end if ! Initialize the function parser call initf ( 3 ) call parsef ( 1 , expression ( sep ( 1 ) + 1 : sep ( 2 ) - 1 ), [ 'pi' ]) call parsef ( 2 , expression ( sep ( 2 ) + 1 : sep ( 3 ) - 1 ), [ 'pi' ]) call parsef ( 3 , expression ( sep ( 3 ) + 1 : sep ( 4 ) - 1 ), [ 'pi' ]) ! Evaluate the parsed function value ( 1 ) = evalf ( 1 , [ pi ]) value ( 2 ) = evalf ( 2 , [ pi ]) value ( 3 ) = evalf ( 3 , [ pi ]) end subroutine subroutine evaluate_vector_field ( expression , domain , value ) !!  Evaluates a vector-valued function of 'z' at the provided values for 'z'. !! !!  Usage: !! !!      call evaluate_scalar_value('[0,0,0]',                     input(1:n), output(1:3,1:n)) !!      call evaluate_scalar_value('[sin(pi*z/2),0,cos(pi*z/2)]', input(1:n), output(1:3,1:n)) !! use :: fparser character ( * ), intent ( in ) :: expression !! Function of 'z' real ( wp ), dimension (:), intent ( in ) :: domain !! Values of 'z' real ( wp ), dimension (:, :), allocatable :: value !! Parsed result integer , dimension ( 4 ) :: sep integer :: n ! Allocate memory for the output allocate ( value ( 3 , size ( domain ))) ! Find the vector delimiters sep ( 1 ) = scan ( expression , '[' , back = . false .) sep ( 2 ) = scan ( expression , ',' , back = . false .) sep ( 3 ) = scan ( expression , ',' , back = . true .) sep ( 4 ) = scan ( expression , ']' , back = . true .) ! Make sure the expressions are non-empty if ( sep ( 1 ) <= 0 . or . any ( sep ( 2 : 4 ) - sep ( 1 : 3 ) <= 1 )) then call error ( 'Invalid vector expression: \"' // trim ( expression ) // '\"' ) end if if ( scan ( expression ( sep ( 1 ) + 1 : sep ( 2 ) - 1 ), '0123456789piz' ) <= 0 . or . & scan ( expression ( sep ( 2 ) + 1 : sep ( 3 ) - 1 ), '0123456789piz' ) <= 0 . or . & scan ( expression ( sep ( 3 ) + 1 : sep ( 4 ) - 1 ), '0123456789piz' ) <= 0 ) & then call error ( 'Invalid vector expression: \"' // trim ( expression ) // '\"' ) end if ! Initialize the function parser call initf ( 3 ) call parsef ( 1 , expression ( sep ( 1 ) + 1 : sep ( 2 ) - 1 ), [ 'pi' , 'z ' ]) call parsef ( 2 , expression ( sep ( 2 ) + 1 : sep ( 3 ) - 1 ), [ 'pi' , 'z ' ]) call parsef ( 3 , expression ( sep ( 3 ) + 1 : sep ( 4 ) - 1 ), [ 'pi' , 'z ' ]) ! Evaluate the parsed function do n = 1 , size ( domain ) value ( 1 , n ) = evalf ( 1 , [ pi , domain ( n )]) value ( 2 , n ) = evalf ( 2 , [ pi , domain ( n )]) value ( 3 , n ) = evalf ( 3 , [ pi , domain ( n )]) end do end subroutine end module","tags":"","loc":"sourcefile/evaluate.f90.html"},{"title":"nambu.f90 – GENEUS","text":"Contents Modules nambu_m Source Code nambu.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This module defines the new data type 'nambu', which represents 4×4 complex !> matrices in spin and particle-hole space. It overloads arithmetic operators !> to work with the new type and exports relevant Pauli matrices as constants. module nambu_m use :: math_m use :: spin_m private ! Public interface public nambu , nambuv public inverse , trace , conjg , sum ! Type declaration type nambu complex ( wp ) :: matrix ( 4 , 4 ) = 0.0_wp contains ! Overload constructors and operators generic :: nambu => & cons_rscalar , cons_cscalar , & cons_cmatrix , cons_nambu generic :: assignment ( = ) => & assr_rscalar , assr_cscalar , & assr_cmatrix , assl_cmatrix generic :: operator ( + ) => & addl_rscalar , addr_rscalar , & addl_cscalar , addr_cscalar , & addl_cmatrix , addr_cmatrix , & add_nambu generic :: operator ( - ) => & subl_rscalar , subr_rscalar , & subl_cscalar , subr_cscalar , & subl_cmatrix , subr_cmatrix , & sub_nambu generic :: operator ( * ) => & mull_rscalar , mulr_rscalar , & mull_cscalar , mulr_cscalar , & mull_cmatrix , mulr_cmatrix , & mul_nambu generic :: operator ( / ) => & divr_rscalar , divr_cscalar generic :: operator ( ** ) => & expr_iscalar ! Specific methods for construction procedure , nopass , private :: cons_nambu => nambu_cons_nambu procedure , nopass , private :: cons_rscalar => nambu_cons_rscalar procedure , nopass , private :: cons_cscalar => nambu_cons_cscalar procedure , nopass , private :: cons_cmatrix => nambu_cons_cmatrix ! Specific implementations of assignments procedure , pass ( this ), private :: assr_rscalar => nambu_assr_rscalar procedure , pass ( this ), private :: assr_cscalar => nambu_assr_cscalar procedure , pass ( this ), private :: assl_cmatrix => nambu_assl_cmatrix procedure , pass ( this ), private :: assr_cmatrix => nambu_assr_cmatrix ! Specific implementations of addition procedure , pass ( this ), private :: add_nambu => nambu_add_nambu procedure , pass ( this ), private :: addl_rscalar => nambu_addl_rscalar procedure , pass ( this ), private :: addr_rscalar => nambu_addr_rscalar procedure , pass ( this ), private :: addl_cscalar => nambu_addl_cscalar procedure , pass ( this ), private :: addr_cscalar => nambu_addr_cscalar procedure , pass ( this ), private :: addl_cmatrix => nambu_addl_cmatrix procedure , pass ( this ), private :: addr_cmatrix => nambu_addr_cmatrix ! Specific implementations of subtraction procedure , pass ( this ), private :: sub_nambu => nambu_sub_nambu procedure , pass ( this ), private :: subl_rscalar => nambu_subl_rscalar procedure , pass ( this ), private :: subr_rscalar => nambu_subr_rscalar procedure , pass ( this ), private :: subl_cscalar => nambu_subl_cscalar procedure , pass ( this ), private :: subr_cscalar => nambu_subr_cscalar procedure , pass ( this ), private :: subl_cmatrix => nambu_subl_cmatrix procedure , pass ( this ), private :: subr_cmatrix => nambu_subr_cmatrix ! Specific implementations of multiplication procedure , pass ( this ), private :: mul_nambu => nambu_mul_nambu procedure , pass ( this ), private :: mull_rscalar => nambu_mull_rscalar procedure , pass ( this ), private :: mulr_rscalar => nambu_mulr_rscalar procedure , pass ( this ), private :: mull_cscalar => nambu_mull_cscalar procedure , pass ( this ), private :: mulr_cscalar => nambu_mulr_cscalar procedure , pass ( this ), private :: mull_cmatrix => nambu_mull_cmatrix procedure , pass ( this ), private :: mulr_cmatrix => nambu_mulr_cmatrix ! Specific implementations of division procedure , pass ( this ), private :: divr_rscalar => nambu_divr_rscalar procedure , pass ( this ), private :: divr_cscalar => nambu_divr_cscalar ! Specific implementations of exponentiation procedure , pass ( this ), private :: expr_iscalar => nambu_expr_iscalar end type ! Public interfaces interface inverse module procedure nambu_inv end interface interface trace module procedure nambu_trace end interface interface sum module procedure nambu_sum end interface interface conjg module procedure nambu_conjg end interface interface nambuv module procedure nambuv_scalar , nambuv_vector end interface contains !--------------------------------------------------------------------------! !                            SPECIFIC CONSTRUCTORS                         ! !--------------------------------------------------------------------------! pure function nambuv_scalar ( n ) result ( r ) !!  Constructs basis matrix number n in spin-nambu space. integer , intent ( in ) :: n type ( nambu ) :: r select case ( n ) case ( 0 ) ! Basis matrix τ₀σ₀ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli0 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = + pauli0 % matrix case ( 1 ) ! Basis matrix τ₀σ₁ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli1 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = + pauli1 % matrix case ( 2 ) ! Basis matrix τ₀σ₂ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli2 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = - pauli2 % matrix case ( 3 ) ! Basis matrix τ₀σ₃ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli3 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = + pauli3 % matrix case ( 4 ) ! Basis matrix τ₃σ₀ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli0 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = - pauli0 % matrix case ( 5 ) ! Basis matrix τ₃σ₁ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli1 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = - pauli1 % matrix case ( 6 ) ! Basis matrix τ₃σ₂ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli2 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = + pauli2 % matrix case ( 7 ) ! Basis matrix τ₃σ₃ r % matrix ( 1 : 2 , 1 : 2 ) = + pauli3 % matrix r % matrix ( 3 : 4 , 3 : 4 ) = - pauli3 % matrix end select end function pure function nambuv_vector ( v ) result ( r ) !!  Constructs a matrix representation of a vector. real ( wp ), dimension ( 1 : 3 ), intent ( in ) :: v type ( nambu ) :: r r = v ( 1 ) * nambuv ( 1 ) + v ( 2 ) * nambuv ( 2 ) + v ( 3 ) * nambuv ( 3 ) end function pure function nambu_cons_rscalar ( other ) result ( this ) !!  Constructs a nambu object from a real scalar. real ( wp ), intent ( in ) :: other type ( nambu ) :: this this = other end function pure function nambu_cons_cscalar ( other ) result ( this ) !!  Constructs a nambu object from a complex scalar. complex ( wp ), intent ( in ) :: other type ( nambu ) :: this this = other end function pure function nambu_cons_cmatrix ( other ) result ( this ) !!  Constructs a nambu object from a complex matrix. complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: this this = other end function pure function nambu_cons_nambu ( other ) result ( this ) !!  Constructs a nambu object from an existing one. type ( nambu ), intent ( in ) :: other type ( nambu ) :: this this = other end function !--------------------------------------------------------------------------! !                         SPECIFIC IMPORT PROCEDURES                       ! !--------------------------------------------------------------------------! pure subroutine nambu_assr_rscalar ( this , other ) !!  Imports data to a nambu object from a real scalar. class ( nambu ), intent ( inout ) :: this real ( wp ), intent ( in ) :: other this % matrix = other * identity ( 4 ) end subroutine pure subroutine nambu_assr_cscalar ( this , other ) !!  Imports data to a nambu object from a complex scalar. class ( nambu ), intent ( inout ) :: this complex ( wp ), intent ( in ) :: other this % matrix = other * identity ( 4 ) end subroutine pure subroutine nambu_assr_cmatrix ( this , other ) !!  Imports data to a nambu object from a complex matrix. class ( nambu ), intent ( inout ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) this % matrix = other end subroutine !--------------------------------------------------------------------------! !                         SPECIFIC EXPORT PROCEDURES                       ! !--------------------------------------------------------------------------! pure subroutine nambu_assl_cmatrix ( other , this ) !!  Exports data from a nambu object to a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( out ) :: other ( 4 , 4 ) other = this % matrix end subroutine !--------------------------------------------------------------------------! !                     SPECIFIC EXPONENTIATION PROCEDURES                   ! !--------------------------------------------------------------------------! pure function nambu_expr_iscalar ( this , other ) result ( r ) !!  Exponentiates the nambu object, where the power is a positive integer. class ( nambu ), intent ( in ) :: this integer , intent ( in ) :: other type ( nambu ) :: r integer :: n r = this do n = 2 , other r % matrix = r % matrix * this end do end function !--------------------------------------------------------------------------! !                     SPECIFIC MULTIPLICATION PROCEDURES                   ! !--------------------------------------------------------------------------! elemental function nambu_mul_nambu ( this , other ) result ( r ) !!  Defines multiplication of two nambu matrices. class ( nambu ), intent ( in ) :: this class ( nambu ), intent ( in ) :: other type ( nambu ) :: r r % matrix = matmul ( this % matrix , other % matrix ) end function pure function nambu_mull_rscalar ( other , this ) result ( r ) !!  Defines left multiplication of a nambu matrix by a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = other * this % matrix end function pure function nambu_mulr_rscalar ( this , other ) result ( r ) !!  Defines right multiplication of a nambu matrix by a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix * other end function pure function nambu_mull_cscalar ( other , this ) result ( r ) !!  Defines left multiplication of a nambu matrix by a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = other * this % matrix end function function nambu_mulr_cscalar ( this , other ) result ( r ) !!  Defines right multiplication of a nambu matrix by a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix * other end function pure function nambu_mull_cmatrix ( other , this ) result ( r ) !!  Defines left multiplication of a nambu matrix by a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: r r % matrix = matmul ( other , this % matrix ) end function pure function nambu_mulr_cmatrix ( this , other ) result ( r ) !!  Defines right multiplication of a nambu matrix by a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: r r % matrix = matmul ( this % matrix , other ) end function !--------------------------------------------------------------------------! !                        SPECIFIC DIVISION PROCEDURES                      ! !--------------------------------------------------------------------------! pure function nambu_divr_rscalar ( this , other ) result ( r ) !!  Defines division of a nambu matrix by a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix / other end function pure function nambu_divr_cscalar ( this , other ) result ( r ) !!  Defines division of a nambu matrix by a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix / other end function !--------------------------------------------------------------------------! !                        SPECIFIC ADDITION PROCEDURES                      ! !--------------------------------------------------------------------------! elemental function nambu_add_nambu ( this , other ) result ( r ) !!  Defines addition of two nambu matrices. class ( nambu ), intent ( in ) :: this class ( nambu ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix + other % matrix end function pure function nambu_addl_rscalar ( other , this ) result ( r ) !!  Defines left addition of a nambu matrix and a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = other * identity ( 4 ) + this % matrix end function pure function nambu_addr_rscalar ( this , other ) result ( r ) !!  Defines right addition of a nambu matrix and a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix + other * identity ( 4 ) end function pure function nambu_addl_cscalar ( other , this ) result ( r ) !!  Defines left addition of a nambu matrix and a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = other * identity ( 4 ) + this % matrix end function pure function nambu_addr_cscalar ( this , other ) result ( r ) !!  Defines right addition of a nambu matrix and a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix + other * identity ( 4 ) end function pure function nambu_addl_cmatrix ( other , this ) result ( r ) !!  Defines left addition of a nambu matrix and a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: r r % matrix = other + this % matrix end function pure function nambu_addr_cmatrix ( this , other ) result ( r ) !!  Defines right addition of a nambu matrix and a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: r r % matrix = this % matrix + other end function !--------------------------------------------------------------------------! !                       SPECIFIC SUBTRACTION PROCEDURES                    ! !--------------------------------------------------------------------------! elemental function nambu_sub_nambu ( this , other ) result ( r ) !!  Defines subtraction of two nambu matrices. class ( nambu ), intent ( in ) :: this class ( nambu ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix - other % matrix end function pure function nambu_subl_rscalar ( other , this ) result ( r ) !!  Defines left subtraction of a nambu matrix and a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = other * identity ( 4 ) - this % matrix end function pure function nambu_subr_rscalar ( this , other ) result ( r ) !!  Defines right subtraction of a nambu matrix and a real scalar. class ( nambu ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix - other * identity ( 4 ) end function pure function nambu_subl_cscalar ( other , this ) result ( r ) !!  Defines left subtraction of a nambu matrix and a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = other * identity ( 4 ) - this % matrix end function pure function nambu_subr_cscalar ( this , other ) result ( r ) !!  Defines right subtraction of a nambu matrix and a complex scalar. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( nambu ) :: r r % matrix = this % matrix - other * identity ( 4 ) end function pure function nambu_subl_cmatrix ( other , this ) result ( r ) !!  Defines left subtraction of a nambu matrix and a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: r r % matrix = other - this % matrix end function pure function nambu_subr_cmatrix ( this , other ) result ( r ) !!  Defines right subtraction of a nambu matrix and a complex matrix. class ( nambu ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 4 , 4 ) type ( nambu ) :: r r % matrix = this % matrix - other end function !--------------------------------------------------------------------------! !                                MATRIX ALGEBRA                            ! !--------------------------------------------------------------------------! elemental function nambu_conjg ( this ) result ( r ) !!  Calculates the complex conjugate of the nambu matrix. class ( nambu ), intent ( in ) :: this type ( nambu ) :: r r % matrix = conjg ( this % matrix ) end function elemental function nambu_trace ( this ) result ( r ) !!  Calculates the trace of the nambu matrix. class ( nambu ), intent ( in ) :: this complex ( wp ) :: r r = this % matrix ( 1 , 1 ) + this % matrix ( 2 , 2 ) & + this % matrix ( 3 , 3 ) + this % matrix ( 4 , 4 ) end function pure function nambu_inv ( this ) result ( r ) !!  Calculates the inverse of the nambu matrix. class ( nambu ), intent ( in ) :: this type ( nambu ) :: r r % matrix = inverse ( this % matrix ) end function pure function nambu_sum ( this ) result ( r ) !!  Calculates the sum of an array of nambu matrices. class ( nambu ), intent ( in ) :: this (:) type ( nambu ) :: r integer :: n do n = 1 , size ( this ) r % matrix = r % matrix + this ( n )% matrix end do end function end module","tags":"","loc":"sourcefile/nambu.f90.html"},{"title":"condmat.f90 – GENEUS","text":"Contents Modules condmat_m Source Code condmat.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This file provides a common interface to a library of mathematical objects !> that can be useful for modelling materials in condensed matter physics. module condmat_m use :: math_m use :: spin_m use :: nambu_m use :: propagator_m end module","tags":"","loc":"sourcefile/condmat.f90.html"},{"title":"basic.f90 – GENEUS","text":"Contents Modules basic_m Source Code basic.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This module contains constants and functions for doing low-level numerics !> in Fortran. This includes standard real and complex precisions (sp, dp, qp), !> a \"working precision\" (wp) that is used as the default precision in GENEUS; !> some common numerical constants (like pi and the machine epsilon); as well !> as basic functions for e.g. constructing and deconstructing complex numbers. module basic_m use :: iso_fortran_env ! Declare floating-point precisions integer , parameter :: sp = real32 !! Single precision integer , parameter :: dp = real64 !! Double precision integer , parameter :: qp = real128 !! Quadruple precision integer , parameter :: wp = dp !! Working precision ! Define common mathematical constants real ( wp ), parameter :: inf = huge ( 1.0_wp ) !! Infinity real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) !! Infinitesimal real ( wp ), parameter :: pi = atan ( 1.0_wp ) * 4.0_wp !! Circle constant contains elemental function re ( z ) result ( x ) !!  Returns the real part of a complex number z=x+iy. !! !!  @NOTE: !!    This should be replaced by z%re when compilers support it. complex ( wp ), intent ( in ) :: z !! Complex number real ( wp ) :: x !! Real part x = real ( z , kind = wp ) end function elemental function im ( z ) result ( y ) !!  Returns the imaginary part of a complex number z=x+iy. !! !!  @NOTE: !!    This should be replaced by z%im when compilers support it. complex ( wp ), intent ( in ) :: z !! Complex number real ( wp ) :: y !! Imaginary part y = aimag ( z ) end function elemental function cx ( x , y ) result ( z ) !!  Returns the complex number z=x+iy. !! !!  @NOTE: !!    This should be rewritten via z%re, z%im when compilers support it. real ( wp ), intent ( in ) :: x !! Real part real ( wp ), intent ( in ), optional :: y !! Imaginary part complex ( wp ) :: z !! Complex number if ( present ( y )) then z = cmplx ( x , y , kind = wp ) else z = cmplx ( x , kind = wp ) end if end function elemental function arg ( z ) result ( t ) !!  Returns the complex argument θ of a complex number z=r·exp(iθ). !! !!  @NOTE: !!    This should be rewritten via z%re, z%im when compilers support it. complex ( wp ), intent ( in ) :: z !! Complex number real ( wp ) :: t !! Complex argument t = atan2 ( im ( z ), re ( z )) end function pure function unitvector ( v ) result ( r ) !!  If the argument has a finite norm, then it will be rescaled to a unit !!  vector. If that norm is zero, then a zero vector is returned instead. real ( wp ), dimension ( 3 ), intent ( in ) :: v !! Input vector real ( wp ), dimension ( 3 ) :: r !! Unit vector r = v / ( norm2 ( v ) + eps ) end function pure function nonzero ( v ) result ( r ) !!  Checks whether or not the argument has a finite norm. real ( wp ), dimension (:), intent ( in ) :: v !! Input vector logical :: r !! Conclusion r = norm2 ( v ) > eps end function end module","tags":"","loc":"sourcefile/basic.f90.html"},{"title":"spin.f90 – GENEUS","text":"Contents Modules spin_m Source Code spin.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> This module defines the type 'spin', representing 2×2 complex matrices in !> spin space. The module overloads common arithmetic operators to work with !> the new data type, and defines and exports the Pauli matrices as constants. !> To make it easier to interact with common differential equation solvers, !> which often operate on real state vectors, the assignment operator is !> overloaded to make 'spin' easily importable/exportable to real vectors. module spin_m use :: math_m private ! Public interface public spin public inverse , trace , conjg , norm2 , sum public pauli , pauli0 , pauli1 , pauli2 , pauli3 ! Type declaration type spin complex ( wp ) :: matrix ( 2 , 2 ) = 0.0_wp contains ! Overload constructors and operators generic :: spin => & cons_rscalar , cons_cscalar , & cons_cmatrix , cons_rvector , & cons_spin generic :: assignment ( = ) => & assr_rscalar , assr_cscalar , & assr_cmatrix , assr_rvector , & assl_cmatrix , assl_rvector generic :: operator ( + ) => & addl_rscalar , addr_rscalar , & addl_cscalar , addr_cscalar , & addl_cmatrix , addr_cmatrix , & add_spin generic :: operator ( - ) => & subl_rscalar , subr_rscalar , & subl_cscalar , subr_cscalar , & subl_cmatrix , subr_cmatrix , & sub_spin generic :: operator ( * ) => & mull_rscalar , mulr_rscalar , & mull_cscalar , mulr_cscalar , & mull_cmatrix , mulr_cmatrix , & mul_spin generic :: operator ( / ) => & divr_rscalar , divr_cscalar generic :: operator ( ** ) => & expr_iscalar ! Specific methods for construction procedure , nopass , private :: cons_spin => spin_cons_spin procedure , nopass , private :: cons_rscalar => spin_cons_rscalar procedure , nopass , private :: cons_cscalar => spin_cons_cscalar procedure , nopass , private :: cons_cmatrix => spin_cons_cmatrix procedure , nopass , private :: cons_rvector => spin_cons_rvector ! Specific implementations of assignments procedure , pass ( this ), private :: assr_rscalar => spin_assr_rscalar procedure , pass ( this ), private :: assr_cscalar => spin_assr_cscalar procedure , pass ( this ), private :: assl_cmatrix => spin_assl_cmatrix procedure , pass ( this ), private :: assr_cmatrix => spin_assr_cmatrix procedure , pass ( this ), private :: assl_rvector => spin_assl_rvector procedure , pass ( this ), private :: assr_rvector => spin_assr_rvector ! Specific implementations of addition procedure , pass ( this ), private :: add_spin => spin_add_spin procedure , pass ( this ), private :: addl_rscalar => spin_addl_rscalar procedure , pass ( this ), private :: addr_rscalar => spin_addr_rscalar procedure , pass ( this ), private :: addl_cscalar => spin_addl_cscalar procedure , pass ( this ), private :: addr_cscalar => spin_addr_cscalar procedure , pass ( this ), private :: addl_cmatrix => spin_addl_cmatrix procedure , pass ( this ), private :: addr_cmatrix => spin_addr_cmatrix ! Specific implementations of subtraction procedure , pass ( this ), private :: sub_spin => spin_sub_spin procedure , pass ( this ), private :: subl_rscalar => spin_subl_rscalar procedure , pass ( this ), private :: subr_rscalar => spin_subr_rscalar procedure , pass ( this ), private :: subl_cscalar => spin_subl_cscalar procedure , pass ( this ), private :: subr_cscalar => spin_subr_cscalar procedure , pass ( this ), private :: subl_cmatrix => spin_subl_cmatrix procedure , pass ( this ), private :: subr_cmatrix => spin_subr_cmatrix ! Specific implementations of multiplication procedure , pass ( this ), private :: mul_spin => spin_mul_spin procedure , pass ( this ), private :: mull_rscalar => spin_mull_rscalar procedure , pass ( this ), private :: mulr_rscalar => spin_mulr_rscalar procedure , pass ( this ), private :: mull_cscalar => spin_mull_cscalar procedure , pass ( this ), private :: mulr_cscalar => spin_mulr_cscalar procedure , pass ( this ), private :: mull_cmatrix => spin_mull_cmatrix procedure , pass ( this ), private :: mulr_cmatrix => spin_mulr_cmatrix ! Specific implementations of division procedure , pass ( this ), private :: divr_rscalar => spin_divr_rscalar procedure , pass ( this ), private :: divr_cscalar => spin_divr_cscalar ! Specific implementations of exponentiation procedure , pass ( this ), private :: expr_iscalar => spin_expr_iscalar end type ! Public interfaces interface inverse module procedure spin_inv end interface interface trace module procedure spin_trace end interface interface sum module procedure spin_sum end interface interface conjg module procedure spin_conjg end interface interface norm2 module procedure spin_norm end interface ! Exported constants type ( spin ), parameter :: pauli0 = & spin ( reshape ([( 1 , 0 ), ( 0 , 0 ), ( 0 , 0 ), ( 1 , 0 )], [ 2 , 2 ], order = [ 2 , 1 ])) type ( spin ), parameter :: pauli1 = & spin ( reshape ([( 0 , 0 ), ( 1 , 0 ), ( 1 , 0 ), ( 0 , 0 )], [ 2 , 2 ], order = [ 2 , 1 ])) type ( spin ), parameter :: pauli2 = & spin ( reshape ([( 0 , 0 ), ( 0 , - 1 ), ( 0 , 1 ), ( 0 , 0 )], [ 2 , 2 ], order = [ 2 , 1 ])) type ( spin ), parameter :: pauli3 = & spin ( reshape ([( 1 , 0 ), ( 0 , 0 ), ( 0 , 0 ), ( - 1 , 0 )], [ 2 , 2 ], order = [ 2 , 1 ])) type ( spin ), parameter , dimension ( 0 : 3 ) :: pauli = & [ pauli0 , pauli1 , pauli2 , pauli3 ] contains !--------------------------------------------------------------------------! !                            SPECIFIC CONSTRUCTORS                         ! !--------------------------------------------------------------------------! pure function spin_cons_rscalar ( other ) result ( this ) !!  Constructs a spin object from a real scalar. real ( wp ), intent ( in ) :: other type ( spin ) :: this this = other end function pure function spin_cons_cscalar ( other ) result ( this ) !!  Constructs a spin object from a complex scalar. complex ( wp ), intent ( in ) :: other type ( spin ) :: this this = other end function pure function spin_cons_cmatrix ( other ) result ( this ) !!  Constructs a spin object from a complex matrix. complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: this this = other end function pure function spin_cons_rvector ( other ) result ( this ) !!  Constructs a spin object from a real vector. real ( wp ), intent ( in ) :: other ( 8 ) type ( spin ) :: this this = other end function pure function spin_cons_spin ( other ) result ( this ) !!  Constructs a spin object from an existing one. type ( spin ), intent ( in ) :: other type ( spin ) :: this this = other end function !--------------------------------------------------------------------------! !                         SPECIFIC IMPORT PROCEDURES                       ! !--------------------------------------------------------------------------! pure subroutine spin_assr_rscalar ( this , other ) !!  Imports data to a spin object from a real scalar. class ( spin ), intent ( inout ) :: this real ( wp ), intent ( in ) :: other this % matrix = other * pauli0 % matrix end subroutine pure subroutine spin_assr_cscalar ( this , other ) !!  Imports data to a spin object from a complex scalar. class ( spin ), intent ( inout ) :: this complex ( wp ), intent ( in ) :: other this % matrix = other * pauli0 % matrix end subroutine pure subroutine spin_assr_cmatrix ( this , other ) !!  Imports data to a spin object from a complex matrix. class ( spin ), intent ( inout ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) this % matrix = other end subroutine pure subroutine spin_assr_rvector ( this , other ) !!  Imports data to a spin object from a real vector. class ( spin ), intent ( inout ) :: this real ( wp ), intent ( in ) :: other ( 8 ) ! TODO: Rewrite this without using `cx` in the future. this % matrix = cx ( reshape ( other ( 1 : 7 : 2 ), [ 2 , 2 ], order = [ 2 , 1 ]), & reshape ( other ( 2 : 8 : 2 ), [ 2 , 2 ], order = [ 2 , 1 ])) end subroutine !--------------------------------------------------------------------------! !                         SPECIFIC EXPORT PROCEDURES                       ! !--------------------------------------------------------------------------! pure subroutine spin_assl_cmatrix ( other , this ) !!  Exports data from a spin object to a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( out ) :: other ( 2 , 2 ) other = this % matrix end subroutine pure subroutine spin_assl_rvector ( other , this ) !!  Exports data from a spin object to a real vector. class ( spin ), intent ( in ) :: this real ( wp ), intent ( out ) :: other ( 8 ) other ( 1 : 7 : 2 ) = re ([ this % matrix ( 1 , :), this % matrix ( 2 , :)]) other ( 2 : 8 : 2 ) = im ([ this % matrix ( 1 , :), this % matrix ( 2 , :)]) end subroutine !--------------------------------------------------------------------------! !                     SPECIFIC EXPONENTIATION PROCEDURES                   ! !--------------------------------------------------------------------------! pure function spin_expr_iscalar ( this , other ) result ( r ) !!  Exponentiates the spin object, where the power is a positive integer. class ( spin ), intent ( in ) :: this integer , intent ( in ) :: other type ( spin ) :: r integer :: n r = this do n = 2 , other r % matrix = r % matrix * this end do end function !--------------------------------------------------------------------------! !                     SPECIFIC MULTIPLICATION PROCEDURES                   ! !--------------------------------------------------------------------------! elemental function spin_mul_spin ( this , other ) result ( r ) !!  Defines multiplication of two spin matrices. class ( spin ), intent ( in ) :: this class ( spin ), intent ( in ) :: other type ( spin ) :: r r % matrix = matmul ( this % matrix , other % matrix ) end function pure function spin_mull_rscalar ( other , this ) result ( r ) !!  Defines left multiplication of a spin matrix by a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = other * this % matrix end function pure function spin_mulr_rscalar ( this , other ) result ( r ) !!  Defines right multiplication of a spin matrix by a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix * other end function pure function spin_mull_cscalar ( other , this ) result ( r ) !!  Defines left multiplication of a spin matrix by a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = other * this % matrix end function function spin_mulr_cscalar ( this , other ) result ( r ) !!  Defines right multiplication of a spin matrix by a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix * other end function pure function spin_mull_cmatrix ( other , this ) result ( r ) !!  Defines left multiplication of a spin matrix by a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: r r % matrix = matmul ( other , this % matrix ) end function pure function spin_mulr_cmatrix ( this , other ) result ( r ) !!  Defines right multiplication of a spin matrix by a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: r r % matrix = matmul ( this % matrix , other ) end function !--------------------------------------------------------------------------! !                        SPECIFIC DIVISION PROCEDURES                      ! !--------------------------------------------------------------------------! pure function spin_divr_rscalar ( this , other ) result ( r ) !!  Defines division of a spin matrix by a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix / other end function pure function spin_divr_cscalar ( this , other ) result ( r ) !!  Defines division of a spin matrix by a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix / other end function !--------------------------------------------------------------------------! !                        SPECIFIC ADDITION PROCEDURES                      ! !--------------------------------------------------------------------------! elemental function spin_add_spin ( this , other ) result ( r ) !!  Defines addition of two spin matrices. class ( spin ), intent ( in ) :: this class ( spin ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix + other % matrix end function pure function spin_addl_rscalar ( other , this ) result ( r ) !!  Defines left addition of a spin matrix and a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = other * pauli0 % matrix + this % matrix end function pure function spin_addr_rscalar ( this , other ) result ( r ) !!  Defines right addition of a spin matrix and a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix + other * pauli0 % matrix end function pure function spin_addl_cscalar ( other , this ) result ( r ) !!  Defines left addition of a spin matrix and a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = other * pauli0 % matrix + this % matrix end function pure function spin_addr_cscalar ( this , other ) result ( r ) !!  Defines right addition of a spin matrix and a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix + other * pauli0 % matrix end function pure function spin_addl_cmatrix ( other , this ) result ( r ) !!  Defines left addition of a spin matrix and a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: r r % matrix = other + this % matrix end function pure function spin_addr_cmatrix ( this , other ) result ( r ) !!  Defines right addition of a spin matrix and a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: r r % matrix = this % matrix + other end function !--------------------------------------------------------------------------! !                       SPECIFIC SUBTRACTION PROCEDURES                    ! !--------------------------------------------------------------------------! elemental function spin_sub_spin ( this , other ) result ( r ) !!  Defines subtraction of two spin matrices. class ( spin ), intent ( in ) :: this class ( spin ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix - other % matrix end function pure function spin_subl_rscalar ( other , this ) result ( r ) !!  Defines left subtraction of a spin matrix and a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = other * pauli0 % matrix - this % matrix end function pure function spin_subr_rscalar ( this , other ) result ( r ) !!  Defines right subtraction of a spin matrix and a real scalar. class ( spin ), intent ( in ) :: this real ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix - other * pauli0 % matrix end function pure function spin_subl_cscalar ( other , this ) result ( r ) !!  Defines left subtraction of a spin matrix and a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = other * pauli0 % matrix - this % matrix end function pure function spin_subr_cscalar ( this , other ) result ( r ) !!  Defines right subtraction of a spin matrix and a complex scalar. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other type ( spin ) :: r r % matrix = this % matrix - other * pauli0 % matrix end function pure function spin_subl_cmatrix ( other , this ) result ( r ) !!  Defines left subtraction of a spin matrix and a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: r r % matrix = other - this % matrix end function pure function spin_subr_cmatrix ( this , other ) result ( r ) !!  Defines right subtraction of a spin matrix and a complex matrix. class ( spin ), intent ( in ) :: this complex ( wp ), intent ( in ) :: other ( 2 , 2 ) type ( spin ) :: r r % matrix = this % matrix - other end function !--------------------------------------------------------------------------! !                                MATRIX ALGEBRA                            ! !--------------------------------------------------------------------------! elemental function spin_norm ( this ) result ( r ) !!  Calculate the Frobenius norm of the spin matrix. class ( spin ), intent ( in ) :: this real ( wp ) :: r , w ( 8 ) w = this r = norm2 ( w ) end function elemental function spin_conjg ( this ) result ( r ) !!  Calculate the complex conjugate of the spin matrix. class ( spin ), intent ( in ) :: this type ( spin ) :: r r % matrix = conjg ( this % matrix ) end function elemental function spin_trace ( this ) result ( r ) !!  Calculate the trace of the spin matrix. class ( spin ), intent ( in ) :: this complex ( wp ) :: r r = this % matrix ( 1 , 1 ) + this % matrix ( 2 , 2 ) end function pure function spin_inv ( this ) result ( r ) !!  Calculate the inverse of the spin matrix. class ( spin ), intent ( in ) :: this type ( spin ) :: r r % matrix = inverse ( this % matrix ) end function pure function spin_sum ( this ) result ( r ) !!  Calculate the sum of an array of spin matrices. class ( spin ), intent ( in ) :: this (:) type ( spin ) :: r integer :: n do n = 1 , size ( this ) r % matrix = r % matrix + this ( n )% matrix end do end function end module","tags":"","loc":"sourcefile/spin.f90.html"},{"title":"math.f90 – GENEUS","text":"Contents Modules math_m Source Code math.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This file provides a common interface to a large library of mathematical !> functions and subroutines. See the documentation of individual interfaces !> below for more information about the contents of the mathematical library. module math_m use :: basic_m use :: calculus_m use :: matrix_m private !------------------------------------------------------------ ! Public interface !------------------------------------------------------------ ! Floating-point precision public :: sp , dp , qp , wp ! Numerical constants public :: inf , eps , pi ! Basic routines public :: unitvector , nonzero , re , im , cx , arg ! Matrix routines public :: trace , diag , inverse , identity , commutator , anticommutator ! Calculus routines public :: mean , differentiate , integrate , interpolate , linspace !------------------------------------------------------------ ! Interfaces for working with matrices !------------------------------------------------------------ interface trace !!  Public interface for functions that calculate a matrix trace. module procedure matrix_trace end interface interface inverse !!  Public interface for functions that calculate a matrix inverse. module procedure matrix_inverse_re , matrix_inverse_cx end interface interface diag !!  Public interface for functions that deal with matrix diagonals. module procedure matrix_diag , vector_diag end interface !------------------------------------------------------------ ! Interfaces for calculus routines !------------------------------------------------------------ interface mean !!  Public interface for routines that calculate the mean value. module procedure mean_array_re , mean_array_cx end interface interface differentiate !!  Public interface for various differentiation routines. module procedure differentiate_array_re , differentiate_array_cx end interface interface integrate !!  Public interface for various integration routines. module procedure integrate_array_re , integrate_array_cx , & integrate_range_re , integrate_range_cx end interface interface interpolate !!  Public interface for various interpolation routines. module procedure interpolate_point_re , interpolate_point_cx , & interpolate_array_re , interpolate_array_cx , & interpolate_point_matrix_re end interface interface linspace !!  Public interface for routines that initialize arrays. module procedure linspace_array_re end interface end module","tags":"","loc":"sourcefile/math.f90.html"},{"title":"calculus.f90 – GENEUS","text":"Contents Modules calculus_m Source Code calculus.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This module defines some functions that perform common calculus operations, !> including differentiating, integrating, and interpolating discretized data. module calculus_m use :: basic_m contains !--------------------------------------------------------------------------- ! Specific implementations of the `mean` interface !--------------------------------------------------------------------------- pure function mean_array_re ( x ) result ( r ) !!  Calculates the mean value of a real-valued array. real ( wp ), dimension (:), intent ( in ) :: x !! Real-valued array real ( wp ) :: r !! Mean value <x> r = sum ( x ) / max ( 1 , size ( x )) end function pure function mean_array_cx ( x ) result ( r ) !!  Calculates the mean value of a complex-valued array. complex ( wp ), dimension (:), intent ( in ) :: x !! Complex-valued array complex ( wp ) :: r !! Mean value <x> r = sum ( x ) / max ( 1 , size ( x )) end function !--------------------------------------------------------------------------- ! Specific implementations of the `differentiate` interface !--------------------------------------------------------------------------- pure function differentiate_array_re ( x , y ) result ( r ) !!  Calculates the numerical derivative of an array y wrt. x using central !!  differences at the interior points and forward/backward differences at !!  the exterior points. All three approaches yield two-point approximations !!  of the derivatives, thus the mesh spacing does not have to be uniform. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x real ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), dimension ( size ( x )) :: r !! Derivative dy/dx ! Differentiate using finite differences associate ( n => size ( x )) r ( 1 ) = ( y ( 2 ) - y ( 1 )) / ( x ( 2 ) - x ( 1 )) r ( 2 : n - 1 ) = ( y ( 3 : n ) - y ( 1 : n - 2 )) / ( x ( 3 : n ) - x ( 1 : n - 2 )) r ( n ) = ( y ( n ) - y ( n - 1 )) / ( x ( n ) - x ( n - 1 )) end associate end function pure function differentiate_array_cx ( x , y ) result ( r ) !!  Complex version of differentiate_array_re. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x complex ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) complex ( wp ), dimension ( size ( x )) :: r !! Derivative dy/dx ! Differentiate using finite differences associate ( n => size ( x )) r ( 1 ) = ( y ( 2 ) - y ( 1 )) / ( x ( 2 ) - x ( 1 )) r ( 2 : n - 1 ) = ( y ( 3 : n ) - y ( 1 : n - 2 )) / ( x ( 3 : n ) - x ( 1 : n - 2 )) r ( n ) = ( y ( n ) - y ( n - 1 )) / ( x ( n ) - x ( n - 1 )) end associate end function !--------------------------------------------------------------------------- ! Specific implementations of the `integrate` interface !--------------------------------------------------------------------------- pure function integrate_array_re ( x , y ) result ( r ) !!  Calculates the integral of an array y wrt. x using the trapezoid !!  method. The mesh spacing does not necessarily have to be uniform. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x real ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ) :: r !! Integral ∫y(x)·dx ! Integrate using the trapezoidal rule associate ( n => size ( x )) r = sum (( y ( 2 : n ) + y ( 1 : n - 1 )) * ( x ( 2 : n ) - x ( 1 : n - 1 ))) / 2 end associate end function pure function integrate_array_cx ( x , y ) result ( r ) !!  Complex version of integrate_array_re. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x complex ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) complex ( wp ) :: r !! Integral ∫y(x)·dx ! Integrate using the trapezoidal rule associate ( n => size ( x )) r = sum (( y ( 2 : n ) + y ( 1 : n - 1 )) * ( x ( 2 : n ) - x ( 1 : n - 1 ))) / 2 end associate end function function integrate_range_re ( x , y , a , b ) result ( r ) !!  Constructs a piecewise hermitian cubic interpolation of an array y(x) !!  from discrete numerical data, and then integrates the interpolation in !!  the range (a, b). The mesh spacing does not have to be uniform. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x real ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), intent ( in ) :: a !! Left endpoint real ( wp ), intent ( in ) :: b !! Right endpoint real ( wp ) :: r !! Integral ∫y(x)·dx external :: dpchez real ( wp ), external :: dpchqa real ( wp ), dimension ( size ( x )) :: d integer :: err ! Create a PCHIP interpolation of the input data call dpchez ( size ( x ), x , y , d , . false ., 0 , 0 , err ) ! Integrate the interpolation in the provided range r = dpchqa ( size ( x ), x , y , d , a , b , err ) end function function integrate_range_cx ( x , y , a , b ) result ( r ) !!  Complex version of integrate_range_re. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x complex ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), intent ( in ) :: a !! Left endpoint real ( wp ), intent ( in ) :: b !! Right endpoint complex ( wp ) :: r !! Integral ∫y(x)·dx ! Integrate the real and imaginary parts separately ! TODO: Replace this with two sequential integrations. r = cx ( integrate_range_re ( x , re ( y ), a , b ), & integrate_range_re ( x , im ( y ), a , b )) end function !--------------------------------------------------------------------------- ! Specific implementations of the `interpolate` interface !--------------------------------------------------------------------------- function interpolate_array_re ( x , y , p ) result ( r ) !!  Constructs a piecewise hermitian cubic interpolation of an array y(x) !!  based on discrete numerical data and evaluates the interpolation at p. !!  Note that the mesh spacing does not necessarily have to be uniform. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x real ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), dimension (:), intent ( in ) :: p !! Point array p real ( wp ), dimension ( size ( p )) :: r !! Interpolation y(p) external :: dpchez external :: dpchfe real ( wp ), dimension ( size ( x )) :: d integer :: err ! Create a PCHIP interpolation of the input data call dpchez ( size ( x ), x , y , d , . false ., 0 , 0 , err ) ! Extract the interpolated data at provided points call dpchfe ( size ( x ), x , y , d , 1 , . false ., size ( p ), p , r , err ) end function function interpolate_array_cx ( x , y , p ) result ( r ) !!  Complex version of interpolate_array_re. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x complex ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), dimension (:), intent ( in ) :: p !! Point array p complex ( wp ), dimension ( size ( p )) :: r !! Interpolation y(p) ! Interpolate the real and imaginary parts separately ! TODO: Replace this with two sequential interpolations. r = cx ( interpolate_array_re ( x , re ( y ), p ), & interpolate_array_re ( x , im ( y ), p )) end function function interpolate_point_re ( x , y , p ) result ( r ) !!  Wrapper for interpolate_array_re that accepts scalar arguments. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x real ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), intent ( in ) :: p !! Single point p real ( wp ) :: r !! Interpolation y(p) real ( wp ), dimension ( 1 ) :: rs ! Perform the interpolation rs = interpolate_array_re ( x , y , [ p ]) ! Extract the scalar result r = rs ( 1 ) end function function interpolate_point_cx ( x , y , p ) result ( r ) !!  Complex version of interpolate_point_re. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x complex ( wp ), dimension ( size ( x )), intent ( in ) :: y !! Function y(x) real ( wp ), intent ( in ) :: p !! Single point p complex ( wp ) :: r !! Interpolation y(p) complex ( wp ), dimension ( 1 ) :: rs ! Perform the interpolation ! TODO: Replace this with two sequential interpolations. rs = cx ( interpolate_array_re ( x , re ( y ), [ p ]), & interpolate_array_re ( x , im ( y ), [ p ])) ! Extract the scalar result r = rs ( 1 ) end function pure function interpolate_point_matrix_re ( x , y , p ) result ( r ) !!  Interpolates a matrix function using Catmull-Rom splines. real ( wp ), dimension (:), intent ( in ) :: x !! Variable x real ( wp ), dimension (:, :, :), intent ( in ) :: y !! Function y(x) real ( wp ), intent ( in ) :: p !! Single point p real ( wp ), dimension ( size ( y , 1 ), size ( y , 2 )) :: r !! Interpolation y(p) integer :: n , m real ( wp ) :: t ! Find the nearest known point y(x) m = size ( x ) n = floor ( p * ( m - 1 ) + 1 ); ! Perform the interpolation if ( n <= 0 ) then ! Exterior: nearest extrapolation r = y (:, :, 1 ) else if ( n >= m ) then ! Exterior: nearest extrapolation r = y (:, :, m ) else ! Interior: spline interpolation t = ( p - x ( max ( n , 1 ))) / ( x ( min ( n + 1 , m )) - x ( max ( n , 1 ))) r = y (:, :, max ( n - 1 , 1 )) * ( - 0.5 * t + 1.0 * t ** 2 - 0.5 * t ** 3 ) & + y (:, :, max ( n - 0 , 1 )) * ( + 1.0 - 2.5 * t ** 2 + 1.5 * t ** 3 ) & + y (:, :, min ( n + 1 , m )) * ( + 0.5 * t + 2.0 * t ** 2 - 1.5 * t ** 3 ) & + y (:, :, min ( n + 2 , m )) * ( - 0.5 * t ** 2 + 0.5 * t ** 3 ) end if end function !--------------------------------------------------------------------------- ! Specific implementations of the `linspace` interface !--------------------------------------------------------------------------- pure subroutine linspace_array_re ( array , first , last ) !!  Populates an array with elements from `first` to `last`, inclusive. real ( wp ), dimension (:), intent ( out ) :: array !! Output array to populate real ( wp ), intent ( in ) :: first !! Value of first element real ( wp ), intent ( in ) :: last !! Value of last  element integer :: n do n = 1 , size ( array ) array ( n ) = first + (( last - first ) * ( n - 1 )) / ( size ( array ) - 1 ) end do end subroutine end module","tags":"","loc":"sourcefile/calculus.f90.html"},{"title":"propagator.f90 – GENEUS","text":"Contents Modules propagator_m Source Code propagator.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This module defines a type 'propagator' which represents a propagator (also !> known as a Green's function) for a given position and energy. The equilibrium !> parts (i.e. retarded and advanced) are represented via the Riccati parameters !> γ, γ~ and their derivatives, while the nonequilibrium part (i.e. Keldysh part) !> is represented by the traces of the distribution function and its derivatives. !> These are together sufficient to reconstruct the full 8×8 propagator and its !> derivatives, and can be used to calculate the associated physical quantities !> such as the density of states, charge currents, spin currents, and so on. module propagator_m use :: math_m use :: spin_m use :: nambu_m private ! Public interface public propagator ! Type declaration type propagator ! Riccati parametrization of equilibrium propagators. type ( spin ) :: g !! Riccati parameter γ type ( spin ) :: gt !! Riccati parameter γ~ type ( spin ) :: dg !! Riccati parameter ∇γ type ( spin ) :: dgt !! Riccati parameter ∇γ~ type ( spin ) :: d2g !! Riccati parameter ∇²γ type ( spin ) :: d2gt !! Riccati parameter ∇²γ~ type ( spin ) :: N !! Riccati normalization N type ( spin ) :: Nt !! Riccati normalization N~ ! Distribution-trace parametrization of nonequilibrium propagators. real ( wp ), dimension ( 0 : 7 ) :: h = [ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] !! Distribution trace H real ( wp ), dimension ( 0 : 7 ) :: dh = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] !! Distribution trace ∇H real ( wp ), dimension ( 0 : 7 ) :: d2h = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] !! Distribution trace ∇²H contains ! Accessors for the propagator matrices represented by this object procedure :: retarded => propagator_retarded !! Retarded propagator Gᴿ procedure :: retarded_gradient => propagator_retarded_gradient !! Retarded propagator ∇Gᴿ procedure :: retarded_laplacian => propagator_retarded_laplacian !! Retarded propagator ∇²Gᴿ procedure :: advanced => propagator_advanced !! Advanced propagator Gᴬ procedure :: advanced_gradient => propagator_advanced_gradient !! Advanced propagator ∇Gᴬ procedure :: advanced_laplacian => propagator_advanced_laplacian !! Advanced propagator ∇²Gᴬ procedure :: keldysh => propagator_keldysh !! Keldysh propagator Gᴷ procedure :: keldysh_gradient => propagator_keldysh_gradient !! Keldysh propagator ∇Gᴷ procedure :: distribution => propagator_distribution !! Distribution matrix H procedure :: distribution_gradient => propagator_distribution_gradient !! Distribution matrix ∇H ! Accessors for derived matrices used to solve the kinetic equations procedure :: dissipation => propagator_dissipation !! Dissipation matrix M procedure :: dissipation_gradient => propagator_dissipation_gradient !! Dissipation matrix ∇M procedure :: condensate => propagator_condensate !! Condensate matrix Q procedure :: condensate_gradient => propagator_condensate_gradient !! Condensate matrix ∇Q procedure :: selfenergy1 => propagator_selfenergy1 !! Self-energy matrix R₁ procedure :: selfenergy2 => propagator_selfenergy2 !! Self-energy matrix R₂ ! Accessors for physical quantities that derive from the propagators procedure :: supercurrent => propagator_supercurrent !! Spectral super currents procedure :: lossycurrent => propagator_lossycurrent !! Spectral lossy currents procedure :: accumulation => propagator_accumulation !! Spectral accumulations procedure :: correlation => propagator_correlation !! Spectral correlations procedure :: density => propagator_density !! Local density of states ! Miscellaneous utility functions for working with propagator objects procedure :: save => propagator_save !! Export Riccati parameters procedure :: load => propagator_load !! Import Riccati parameters end type ! Type constructor interface propagator module procedure & propagator_construct_vacuum , & propagator_construct_riccati , & propagator_construct_bcs end interface contains pure function propagator_construct_vacuum () result ( this ) !!  Construct a vacuum propagator, i.e. a propagator which satisfies G=0. type ( propagator ) :: this !! Constructed object continue end function pure function propagator_construct_riccati ( g , gt , dg , dgt ) result ( this ) !!  Construct an arbitrary state by explicitly providing Riccati parameters. !!  Unspecified Riccati parameters default to zero due to spin constructors. !!  The distribution function defaults to equilibrium at zero temperature. type ( propagator ) :: this !! Constructed object type ( spin ), intent ( in ) :: g !! Riccati parameter γ type ( spin ), intent ( in ) :: gt !! Riccati parameter γ~ type ( spin ), optional , intent ( in ) :: dg !! Riccati parameter ∇γ type ( spin ), optional , intent ( in ) :: dgt !! Riccati parameter ∇γ~ ! Copy Riccati parameters into the new object this % g = g this % gt = gt ! Copy Riccati derivatives into the new object if ( present ( dg )) this % dg = dg if ( present ( dgt )) this % dgt = dgt ! Update the normalization matrices associate ( g => this % g , gt => this % gt , N => this % N , Nt => this % Nt ) N = inverse ( pauli0 - g * gt ) Nt = inverse ( pauli0 - gt * g ) end associate end function pure function propagator_construct_bcs ( energy , gap ) result ( this ) !!  Constructs the state of a a BCS superconductor at a given energy, which !!  may have an imaginary term representing inelastic scattering. The second !!  argument 'gap' is used to provide the superconducting order parameter Δ. !!  The distribution function defaults to equilibrium at zero temperature. type ( propagator ) :: this !! Constructed object complex ( wp ), intent ( in ) :: energy !! Quasiparticle energy complex ( wp ), intent ( in ) :: gap !! Order parameter real ( wp ) :: p complex ( wp ) :: t , u complex ( wp ) :: a , b ! Calculate the superconducting gap and phase u = abs ( gap ) / energy p = arg ( gap ) ! Calculate the θ-parameter t = ( log ( 1 + u ) - log ( 1 - u )) / 2 ! Calculate the scalar Riccati parameters a and b a = ( exp ( + t ) - exp ( - t )) / ( 2 + exp ( + t ) + exp ( - t )) * exp (( 0 , + 1 ) * p ) b = - ( exp ( + t ) - exp ( - t )) / ( 2 + exp ( + t ) + exp ( - t )) * exp (( 0 , - 1 ) * p ) ! Calculate the matrix Riccati parameters γ and γ~ this % g = a * (( 0.0_wp , 1.0_wp ) * pauli2 ) this % gt = b * (( 0.0_wp , 1.0_wp ) * pauli2 ) ! Update the normalization matrices this % N = inverse ( pauli0 - this % g * this % gt ) this % Nt = inverse ( pauli0 - this % gt * this % g ) end function pure function propagator_retarded ( this ) result ( GR ) !!  Calculates the 4×4 retarded propagator Gᴿ. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ) :: GR !! Retarded propagator ! Construct the propagator from the Riccati parameters associate ( g => this % g , gt => this % gt , & N => this % N , Nt => this % Nt , & I => pauli0 , M => GR % matrix ) M ( 1 : 2 , 1 : 2 ) = ( + 1.0_wp ) * N * ( I + g * gt ) M ( 1 : 2 , 3 : 4 ) = ( + 2.0_wp ) * N * g M ( 3 : 4 , 1 : 2 ) = ( - 2.0_wp ) * Nt * gt M ( 3 : 4 , 3 : 4 ) = ( - 1.0_wp ) * Nt * ( I + gt * g ) end associate end function pure function propagator_retarded_gradient ( this , gauge ) result ( dGR ) !!  Calculates the 4×4 retarded propagator gradient ∇Gᴿ. If an optional !!  gauge field is specified, it returns the gauge-covariant gradient. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ), optional , intent ( in ) :: gauge !! Optional gauge field type ( nambu ) :: dGR !! Retarded gradient ! Construct the propagator from the Riccati parameters associate ( g => this % g , gt => this % gt , & dg => this % dg , dgt => this % dgt , & N => this % N , Nt => this % Nt , & I => pauli0 , M => dGR % matrix ) M ( 1 : 2 , 1 : 2 ) = ( + 2.0_wp ) * N * ( dg * gt + g * dgt ) * N M ( 1 : 2 , 3 : 4 ) = ( + 2.0_wp ) * N * ( dg + g * dgt * g ) * Nt M ( 3 : 4 , 1 : 2 ) = ( - 2.0_wp ) * Nt * ( dgt + gt * dg * gt ) * N M ( 3 : 4 , 3 : 4 ) = ( - 2.0_wp ) * Nt * ( dgt * g + gt * dg ) * Nt end associate ! Construct the gauge-covariant terms if ( present ( gauge )) then associate ( A => gauge , GR => this % retarded (), i => ( 0.0_wp , 1.0_wp )) dGR = dGR - i * ( A * GR - GR * A ) end associate end if end function pure function propagator_retarded_laplacian ( this ) result ( d2GR ) !!  Calculates the 4×4 retarded propagator gradient ∇²Gᴿ. !! !!  @TODO: !!    Implement support for gauge-covariant laplacians. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ) :: d2GR !! Retarded laplacian type ( spin ) :: D , Dt , dD , dDt , F , Ft , dF , dFt ! Construct the propagator from the Riccati parameters associate ( g => this % g , gt => this % gt , & dg => this % dg , dgt => this % dgt , & d2g => this % d2g , d2gt => this % d2gt , & N => this % N , Nt => this % Nt , & I => pauli0 , M => d2GR % matrix ) ! Calculate 1st-derivative auxiliary matrices D = dg * gt + g * dgt Dt = dgt * g + gt * dg F = dg + g * dgt * g Ft = dgt + gt * dg * gt ! Calculate 2nd-derivative auxiliary matrices dD = d2g * gt + g * d2gt + 2.0_wp * dg * dgt dDt = d2gt * g + gt * d2g + 2.0_wp * dgt * dg dF = d2g + g * d2gt * g + dg * dgt * g + g * dgt * dg dFt = d2gt + gt * d2g * gt + dgt * dg * gt + gt * dg * dgt ! Calculate the propagator matrix M ( 1 : 2 , 1 : 2 ) = ( + 2.0_wp ) * N * ( dD + 2.0_wp * D * N * D ) * N M ( 1 : 2 , 3 : 4 ) = ( + 2.0_wp ) * N * ( dF + D * N * F + F * Nt * Dt ) * Nt M ( 3 : 4 , 1 : 2 ) = ( - 2.0_wp ) * Nt * ( dFt + Dt * Nt * Ft + Ft * N * D ) * N M ( 3 : 4 , 3 : 4 ) = ( - 2.0_wp ) * Nt * ( dDt + 2.0_wp * Dt * Nt * Dt ) * Nt end associate end function pure function propagator_advanced ( this ) result ( GA ) !!  Calculates the 4×4 advanced propagator Gᴬ. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ) :: GA !! Advanced propagator type ( nambu ) :: GR ! Calculate the retarded propagator GR = this % retarded () ! Use the identity GA = -τ₃GR†τ₃ GA = nambuv ( 4 ) * transpose ( conjg ( - GR % matrix )) * nambuv ( 4 ) end function pure function propagator_advanced_gradient ( this , gauge ) result ( dGA ) !!  Calculates the 4×4 advanced propagator gradient ∇Gᴬ. If an optional !!  gauge field is specified, it returns the gauge-covariant gradient. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ), optional , intent ( in ) :: gauge !! Optional gauge field type ( nambu ) :: dGA !! Advanced gradient type ( nambu ) :: dGR ! Calculate the retarded propagator gradient dGR = this % retarded_gradient ( gauge ) ! Use the identity GA = -τ₃GR†τ₃ dGA = nambuv ( 4 ) * transpose ( conjg ( - dGR % matrix )) * nambuv ( 4 ) end function pure function propagator_advanced_laplacian ( this ) result ( d2GA ) !!  Calculates the 4×4 retarded propagator gradient ∇²Gᴬ. !! !!  @TODO: !!    Implement support for gauge-covariant laplacians. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ) :: d2GA !! Advanced laplacian type ( nambu ) :: d2GR ! Calculate the retarded propagator laplacian d2GR = this % retarded_laplacian () ! Use the identity GA = -τ₃GR†τ₃ d2GA = nambuv ( 4 ) * transpose ( conjg ( - d2GR % matrix )) * nambuv ( 4 ) end function pure function propagator_keldysh ( this ) result ( GK ) !!  Calculates the 4×4 Keldysh propagator Gᴷ. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ) :: GK !! Propagator matrix type ( nambu ) :: GR , GA , H ! Calculate equilibrium propagators and the distribution GR = this % retarded () GA = this % advanced () H = this % distribution () ! Use this to calculate the nonequilibrium propagator GK = GR * H - H * GA end function pure function propagator_keldysh_gradient ( this , gauge ) result ( dGK ) !!  Calculates the 4×4 Keldysh propagator gradient ∇Gᴷ. If an optional !!  gauge field is specified, it returns the gauge-covariant gradient. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ), optional , intent ( in ) :: gauge !! Optional gauge field type ( nambu ) :: dGK !! Propagator gradient type ( nambu ) :: GR , GA , H type ( nambu ) :: dGR , dGA , dH ! Calculate equilibrium propagators and the distribution GR = this % retarded () GA = this % advanced () H = this % distribution () ! Calculate the gradients of the matrix functions above dGR = this % retarded_gradient ( gauge ) dGA = this % advanced_gradient ( gauge ) dH = this % distribution_gradient ( gauge ) ! Use this to calculate the nonequilibrium propagator gradient dGK = ( dGR * H - H * dGA ) + ( GR * dH - dH * GA ) end function pure function propagator_distribution ( this ) result ( H ) !!  Calculates the 4×4 distribution function matrix H. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ) :: H !! Distribution matrix integer :: i ! Construct the distribution matrix from its Pauli-decomposition do i = 0 , 7 H = H + nambuv ( i ) * this % h ( i ) end do end function pure function propagator_distribution_gradient ( this , gauge ) result ( dH ) !!  Calculates the 4×4 distribution function gradient ∇H. If an optional !!  gauge field is specified, it returns the gauge-covariant gradient. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ), optional , intent ( in ) :: gauge !! Optional gauge field type ( nambu ) :: dH !! Distribution gradient integer :: i ! Construct the distribution matrix from its Pauli-decomposition do i = 0 , 7 dH = dH + nambuv ( i ) * this % dh ( i ) end do ! Construct the gauge-covariant terms if ( present ( gauge )) then associate ( A => gauge , H => this % distribution (), i => ( 0.0_wp , 1.0_wp )) dH = dH - i * ( A * H - H * A ) end associate end if end function pure function propagator_supercurrent ( this , gauge ) result ( J ) !!  Calculates the spectral super currents in the junction. The result is an !!  8-vector encoding respectively charge, spin, heat, spin-heat currents. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ), optional , intent ( in ) :: gauge !! Optional gauge field real ( wp ), dimension ( 0 : 7 ) :: J !! Spectral supercurrent type ( nambu ) :: I , H , GR , dGR , GA , dGA integer :: n ! Calculate the propagators H = this % distribution () GR = this % retarded () GA = this % advanced () dGR = this % retarded_gradient ( gauge ) dGA = this % advanced_gradient ( gauge ) ! Calculate the matrix current I = ( GR * dGR ) * H - H * ( GA * dGA ) ! Pauli-decompose the current do n = 0 , 7 J ( n ) = re ( trace (( nambuv ( 4 ) * nambuv ( n )) * I )) / 8 end do end function pure function propagator_lossycurrent ( this , gauge ) result ( J ) !!  Calculates the spectral lossy currents in the junction. The result !!  is an 8-vector containing charge, spin, heat, and spin-heat currents. class ( propagator ), intent ( in ) :: this !! Propagator object type ( nambu ), optional , intent ( in ) :: gauge !! Optional gauge field real ( wp ), dimension ( 0 : 7 ) :: J !! Spectral lossy current type ( nambu ) :: I , dH , GR , GA integer :: n ! Calculate the propagators dH = this % distribution_gradient ( gauge ) GR = this % retarded () GA = this % advanced () ! Calculate the matrix current I = dH - GR * dH * GA ! Pauli-decompose the current do n = 0 , 7 J ( n ) = re ( trace (( nambuv ( 4 ) * nambuv ( n )) * I )) / 8 end do end function pure function propagator_accumulation ( this ) result ( Q ) !!  Calculates the spectral accumulations. The result is an 8-vector !!  containing the charge, spin, heat, and spin-heat accumulations. class ( propagator ), intent ( in ) :: this !! Propagator object real ( wp ), dimension ( 0 : 7 ) :: Q !! Spectral accumulation type ( nambu ) :: GK integer :: n ! Calculate the propagator GK = this % keldysh () ! Pauli-decompose it do n = 0 , 7 Q ( n ) = - re ( trace ( nambuv ( n ) * GK )) / 8 end do end function pure function propagator_correlation ( this ) result ( r ) !!  Calculates the spectral pair-correlation function. This is useful to !!  self-consistently calculate the superconducting gap in a superconductor. class ( propagator ), intent ( in ) :: this !! Propagator object complex ( wp ) :: r !! Spectral correlation type ( nambu ) :: GK type ( spin ) :: f , ft ! Calculate the propagator GK = this % keldysh () ! Extract the anomalous components f = GK % matrix ( 1 : 2 , 3 : 4 ) ft = GK % matrix ( 3 : 4 , 1 : 2 ) ! Trace out the singlet component r = trace (( 0.0_wp , - 1.0_wp ) * pauli2 * ( f + conjg ( ft ))) / 8 end function pure function propagator_density ( this ) result ( D ) !!  Calculates the spin-resolved local density of states. class ( propagator ), intent ( in ) :: this real ( wp ), dimension ( 0 : 7 ) :: D type ( nambu ) :: GR type ( spin ) :: g , gt ! Extract the normal retarded propagator GR = this % retarded () g = + GR % matrix ( 1 : 2 , 1 : 2 ) gt = - GR % matrix ( 3 : 4 , 3 : 4 ) ! Calculate the spin-resolved density of states, ! for both positive and negative energy values D ( 0 : 3 ) = re ( trace ( pauli * g )) / 2 D ( 4 : 7 ) = re ( trace ( pauli * gt )) / 2 end function elemental subroutine propagator_save ( this , other ) !!  Defines a function for exporting Riccati parameters. class ( propagator ), intent ( inout ) :: this class ( propagator ), intent ( inout ) :: other ! Copy all the Riccati parameters other % g = this % g other % gt = this % gt other % dg = this % dg other % dgt = this % dgt other % d2g = this % d2g other % d2gt = this % d2gt other % N = this % N other % Nt = this % Nt end subroutine elemental subroutine propagator_load ( this , other ) !!  Defines a function for importing Riccati parameters. class ( propagator ), intent ( inout ) :: this class ( propagator ), intent ( inout ) :: other ! Copy all the Riccati parameters this % g = other % g this % gt = other % gt this % dg = other % dg this % dgt = other % dgt this % d2g = other % d2g this % d2gt = other % d2gt this % N = other % N this % Nt = other % Nt end subroutine pure function propagator_dissipation ( this ) result ( M ) !!  Calculates the dissipation matrix M = ∂J/∂H', where J is the !!  current and H' is the gradient of the distribution function. class ( propagator ), intent ( in ) :: this complex ( wp ), dimension ( 0 : 7 , 0 : 7 ) :: M type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR , GA integer :: i , j ! Memoize the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices GR = this % retarded () GA = this % advanced () ! Construct the dissipation matrix do i = 0 , 7 do j = 0 , 7 M ( i , j ) = trace ( N ( i ) * N ( j ) - N ( i ) * GR * N ( j ) * GA ) / 4 end do end do end function pure function propagator_dissipation_gradient ( this ) result ( dM ) !!  Calculates the gradient of the dissipation matrix M'. class ( propagator ), intent ( in ) :: this complex ( wp ), dimension ( 0 : 7 , 0 : 7 ) :: dM type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR , GA , dGR , dGA integer :: i , j ! Memoize the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices GR = this % retarded () GA = this % advanced () ! Construct the propagator gradients dGR = this % retarded_gradient () dGA = this % advanced_gradient () ! Construct the dissipation matrix do j = 0 , 7 do i = 0 , 7 dM ( i , j ) = - trace ( N ( i ) * dGR * N ( j ) * GA + N ( i ) * GR * N ( j ) * dGA ) / 4 end do end do end function pure function propagator_condensate ( this ) result ( Q ) !!  Calculates the condensate matrix Q = ∂J/∂H, where J is the !!  current and H is the nonequilibrium distribution function. class ( propagator ), intent ( in ) :: this complex ( wp ), dimension ( 0 : 7 , 0 : 7 ) :: Q type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR , GA , dGR , dGA integer :: i , j ! Memoize the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices GR = this % retarded () GA = this % advanced () ! Construct the propagator gradients dGR = this % retarded_gradient () dGA = this % advanced_gradient () ! Construct the condensate matrix do j = 0 , 7 do i = 0 , 7 Q ( i , j ) = trace ( N ( j ) * N ( i ) * GR * dGR - N ( i ) * N ( j ) * GA * dGA ) / 4 end do end do end function pure function propagator_condensate_gradient ( this ) result ( dQ ) !!  Calculates the gradient of the condensate matrix Q'. class ( propagator ), intent ( in ) :: this complex ( wp ), dimension ( 0 : 7 , 0 : 7 ) :: dQ type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR , GA , dGR , dGA , d2GR , d2GA integer :: i , j ! Memoize the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices GR = this % retarded () GA = this % advanced () ! Construct the propagator gradients dGR = this % retarded_gradient () dGA = this % advanced_gradient () ! Construct the propagator laplacians d2GR = this % retarded_laplacian () d2GA = this % advanced_laplacian () ! Construct the condensate matrix do j = 0 , 7 do i = 0 , 7 dQ ( i , j ) = trace ( N ( j ) * N ( i ) * ( dGR * dGR + GR * d2GR ) - N ( i ) * N ( j ) * ( dGA * dGA + GA * d2GA )) / 4 end do end do end function pure function propagator_selfenergy1 ( this , S ) result ( R ) !!  Calculates 1st-order self-energy contribution to the kinetic equations. class ( propagator ), intent ( in ) :: this type ( nambu ), intent ( in ) :: S complex ( wp ), dimension ( 0 : 7 , 0 : 7 ) :: R type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR , GA integer :: i , j ! Memoize the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices GR = this % retarded () GA = this % advanced () ! Construct the self-energy matrix do j = 0 , 7 do i = 0 , 7 R ( i , j ) = ( 0.00 , 0.25 ) * trace (( N ( i ) * S - S * N ( i )) * ( GR * N ( j ) - N ( j ) * GA )) end do end do end function pure function propagator_selfenergy2 ( this , S ) result ( R ) !!  Calculates 2nd-order self-energy contribution to the kinetic equations. class ( propagator ), intent ( in ) :: this type ( nambu ), intent ( in ) :: S complex ( wp ), dimension ( 0 : 7 , 0 : 7 ) :: R type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR , GA integer :: i , j ! Memoize the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices GR = this % retarded () GA = this % advanced () ! Construct the self-energy matrix do j = 0 , 7 do i = 0 , 7 R ( i , j ) = ( 0.00 , 0.25 ) * trace (( N ( i ) * S - S * N ( i )) * ( GR * S * GR * N ( j ) - N ( j ) * GA * S * GA + GR * ( N ( j ) * S - S * N ( j )) * GA )) end do end do end function end module","tags":"","loc":"sourcefile/propagator.f90.html"},{"title":"matrix.f90 – GENEUS","text":"Contents Modules matrix_m Source Code matrix.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Foundation !> !> This module implements standard operations from linear algebra, including !> including matrix construction, inversion, commutation, and taking traces. module matrix_m use :: basic_m contains pure function identity ( n ) result ( R ) !!  Constructs an n×n identity matrix. integer , intent ( in ) :: n !! Matrix dimension real ( wp ), dimension ( n , n ) :: R !! Identity matrix [n×n] integer :: i , j ! Initialize by exploiting integer arithmetic to avoid multiple passes do i = 1 , n do j = 1 , n R ( j , i ) = ( i / j ) * ( j / i ) end do end do end function pure function matrix_inverse_re ( A ) result ( R ) !!  Wrapper for matrix_inverse_cx that operates on real matrices. real ( wp ), dimension (:, :), intent ( in ) :: A !! Matrix A [n×n] real ( wp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: R !! Matrix R=A¯¹ R = re ( matrix_inverse_cx ( cx ( A ))) end function pure function matrix_inverse_cx ( A ) result ( R ) !!  Inverts a square matrix via Gauss-Jordan elimination with partial pivot !!  (general) or a cofactoring algorithm (2x2 matrices). The implementation !!  is based on Algorithm #2 in \"Efficient matrix inversion via Gauss-Jordan !!  elimination and its parallelization\" by E.S. Quintana et al. (1998). complex ( wp ), dimension (:, :), intent ( in ) :: A !! Matrix A [n×n] complex ( wp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: R !! Matrix R=A¯¹ integer , dimension ( size ( A , 1 )) :: P complex ( wp ) :: Q integer :: i , j select case ( size ( A , 1 )) case ( 1 ) ! Trivial case R ( 1 , 1 ) = 1 / A ( 1 , 1 ) case ( 2 ) ! Inverse determinant Q = 1 / ( A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 )) ! Inverse matrix R ( 1 , 1 ) = + Q * A ( 2 , 2 ) R ( 2 , 1 ) = - Q * A ( 2 , 1 ) R ( 1 , 2 ) = - Q * A ( 1 , 2 ) R ( 2 , 2 ) = + Q * A ( 1 , 1 ) case default ! Permutation array P = [( i , i = 1 , size ( A , 1 ))] ! Matrix copy R = A ! Matrix inversion do i = 1 , size ( A , 1 ) ! Pivoting procedure j = ( i - 1 ) + maxloc ( abs ( A ( i :, i )), 1 ) P ([ i , j ]) = P ([ j , i ]) R ([ i , j ], :) = R ([ j , i ], :) ! Jordan transformation Q = R ( i , i ) R (:, i ) = [ R (: i - 1 , i ), ( 0.0_wp , 0.0_wp ), R ( i + 1 :, i )] / ( - Q ) R = R + matmul ( R (:, [ i ]), R ([ i ], :)) R ( i , :) = [ R ( i , : i - 1 ), ( 1.0_wp , 0.0_wp ), R ( i , i + 1 :)] / ( + Q ) end do ! Pivot inversion R (:, P ) = R end select end function pure function matrix_trace ( A ) result ( r ) !!  Calculates the trace of a general complex matrix. complex ( wp ), dimension (:, :), intent ( in ) :: A !! Matrix [n×m] complex ( wp ) :: r !! r = Tr(A) integer :: n r = 0 do n = 1 , min ( size ( A , 1 ), size ( A , 2 )) r = r + A ( n , n ) end do end function pure function commutator ( A , B ) result ( R ) !!  Calculates the commutator between two complex square matrices. complex ( wp ), dimension (:, :), intent ( in ) :: A !! Left  matrix [n×n] complex ( wp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( in ) :: B !! Right matrix [n×n] complex ( wp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: R !! Commutator R = [A,B] R = matmul ( A , B ) - matmul ( B , A ) end function pure function anticommutator ( A , B ) result ( R ) !!  Calculates the anticommutator between two complex square matrices. complex ( wp ), dimension (:, :), intent ( in ) :: A !! Left  matrix [n×n] complex ( wp ), dimension ( size ( A , 1 ), size ( A , 1 )), intent ( in ) :: B !! Right matrix [n×n] complex ( wp ), dimension ( size ( A , 1 ), size ( A , 1 )) :: R !! Anticommutator R = {A,B} R = matmul ( A , B ) + matmul ( B , A ) end function pure function vector_diag ( A ) result ( r ) !!  Extracts the diagonal of a general complex matrix. complex ( wp ), dimension (:, :), intent ( in ) :: A !! Matrix [n×m] complex ( wp ), dimension ( min ( size ( A , 1 ), size ( A , 2 ))) :: r !! r = Diag(A) integer :: n do n = 1 , size ( r ) r ( n ) = A ( n , n ) end do end function pure function matrix_diag ( A , B ) result ( R ) !!  Constructs a block-diagonal matrix R from two general matrices A and B. complex ( wp ), dimension (:, :), intent ( in ) :: A !! Left  matrix [n×m] complex ( wp ), dimension (:, :), intent ( in ) :: B !! Right matrix [p×q] complex ( wp ), dimension ( size ( A , 1 ) + size ( B , 1 ), size ( A , 2 ) + size ( B , 2 )) :: R !! R = Diag(A,B) R = 0.0_wp R (: size ( A , 1 ), : size ( A , 2 )) = A R ( size ( A , 1 ) + 1 :, size ( A , 2 ) + 1 :) = B end function end module","tags":"","loc":"sourcefile/matrix.f90.html"},{"title":"spinactive.f90 – GENEUS","text":"Contents Modules spinactive_m Source Code spinactive.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This submodule is included by conductor.f, and contains the equations which model spin-active interfaces. !> !> @TODO !>   Reimplement shortcut-evaluation of the current for nonmagnetic interfaces. module spinactive_m use :: propagator_m use :: material_m use :: condmat_m private ! Public interface public spinactive ! Type declarations type :: spinactive ! Physical parameters of the interface real ( wp ) :: conductance = 1.0 !! Interfacial conductance real ( wp ) :: polarization = 0.0 !! Interfacial spin-polarization real ( wp ) :: spinmixing = 0.0 !! Interfacial 1st-order spin-mixing real ( wp ) :: secondorder = 0.0 !! Interfacial 2nd-order spin-mixing real ( wp ), dimension ( 1 : 3 ) :: magnetization = [ 0 , 0 , 1 ] !! Interfacial magnetization direction real ( wp ), dimension ( 1 : 3 ) :: misalignment0 = [ 0 , 0 , 0 ] !! Interfacial magnetization misalignment (this  side) real ( wp ), dimension ( 1 : 3 ) :: misalignment1 = [ 0 , 0 , 0 ] !! Interfacial magnetization misalignment (other side) ! Fields used internally by the object type ( nambu ), private :: M !! Magnetization matrix (transmission) type ( nambu ), private :: M0 !! Magnetization matrix (reflection, this  side) type ( nambu ), private :: M1 !! Magnetization matrix (reflection, other side) contains procedure :: diffusion_current => spinactive_diffusion_current procedure :: kinetic_current => spinactive_kinetic_current procedure :: update_prehook => spinactive_update_prehook end type contains subroutine spinactive_update_prehook ( this ) !! Updates the internal variables associated with spin-active interfaces. class ( spinactive ), intent ( inout ) :: this ! Transmission magnetization this % M = nambuv ( this % magnetization ) ! Reflection magnetization (this side) this % M0 = this % M if ( nonzero ( this % misalignment0 )) then this % M0 = nambuv ( this % misalignment0 ) end if ! Reflection magnetization (other side) this % M1 = this % M if ( nonzero ( this % misalignment1 )) then this % M1 = nambuv ( this % misalignment1 ) end if end subroutine pure function spinactive_diffusion_current ( this , G0 , G1 ) result ( I ) !! Calculate the matrix current at an interface with spin-active properties. The equations !! implemented here should be valid for an arbitrary interface polarization, and up to 2nd !! order in the transmission probabilities and spin-mixing angles of the interface. class ( spinactive ), intent ( in ) :: this type ( nambu ), intent ( in ) :: G0 , G1 !! Propagator matrices type ( nambu ) :: S0 , S1 !! Matrix expressions type ( nambu ) :: I !! Matrix current ! Evaluate the 1st-order matrix functions S0 = spinactive_current1_transmission ( G1 ) S1 = spinactive_current1_reflection () ! Evaluate the 1st-order matrix current associate ( S => S0 + S1 ) I = ( S * G0 - G0 * S ) end associate ! Calculate the 2nd-order contributions to the matrix current. Note that we make a ! number of simplifications in this implementation. In particular, we assume that ! all interface parameters except the magnetization directions are equal on both ! sides of the interface. We also assume that the spin-mixing angles and tunneling ! probabilities of different channels have standard deviations that are much smaller ! than their mean values, which reduces the number of new fitting parameters to one. if ( abs ( this % secondorder ) > 0 ) then ! Evaluate the 1st-order matrix functions associate ( M1 => this % M1 ) S1 = spinactive_current1_transmission ( G1 * M1 * G1 - M1 ) end associate ! Evaluate the 2nd-order matrix current I = I & + spinactive_current2_transmission () & + spinactive_current2_crossterms () & + spinactive_current2_reflection () end if ! Scale the final result based on conductance I = ( this % conductance / 2 ) * I contains pure function spinactive_current1_transmission ( G ) result ( F ) !! Calculate the 1st-order transmission terms in the matrix current commutator. type ( nambu ), intent ( in ) :: G type ( nambu ) :: F real ( wp ) :: Pr , Pp , Pm associate ( P => this % polarization , M => this % M ) Pr = sqrt ( 1 - P ** 2 ) Pp = 1 + Pr Pm = 1 - Pr F = G + ( P / Pp ) * ( M * G + G * M ) + ( Pm / Pp ) * ( M * G * M ) end associate end function pure function spinactive_current1_reflection () result ( F ) !! Calculate the 1st-order spin-mixing terms in the matrix current commutator. type ( nambu ) :: F associate ( Q => this % spinmixing , M0 => this % M0 ) F = (( 0 , - 1 ) * Q ) * M0 end associate end function pure function spinactive_current2_transmission () result ( I ) !! Calculate the 2nd-order transmission terms in the matrix current. type ( nambu ) :: I associate ( R => this % secondorder , Q => this % spinmixing ) I = ( - 0.50 * R / Q ) * ( S0 * G0 * S0 ) end associate end function pure function spinactive_current2_reflection () result ( I ) !! Calculate the 2nd-order spin-mixing terms in the matrix current. type ( nambu ) :: I , U associate ( R => this % secondorder , Q => this % spinmixing , M0 => this % M0 ) U = M0 * G0 * M0 I = ( 0.25 * R * Q ) * ( U * G0 - G0 * U ) end associate end function pure function spinactive_current2_crossterms () result ( I ) !! Calculate the 2nd-order cross-terms in the matrix current. type ( nambu ) :: I , U associate ( R => this % secondorder , M0 => this % M0 ) U = S0 * G0 * M0 + M0 * G0 * S0 + S1 I = (( 0.00 , 0.25 ) * R ) * ( U * G0 - G0 * U ) end associate end function end function pure subroutine spinactive_kinetic_current ( this , G0 , G1 , C0 , C1 ) !! Calculate the kinetic boundary coefficients at an interface with spin-active properties. !! These can be used to calculate the generalized current according to J = C₀H₀ - C₁H₁. class ( spinactive ), intent ( in ) :: this type ( propagator ), intent ( in ) :: G0 !! Propagator (this  side) type ( propagator ), intent ( in ) :: G1 !! Propagator (other side) complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( out ) :: C0 !! Boundary coefficient (this  side) complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( out ) :: C1 !! Boundary coefficient (other side) type ( nambu ), dimension ( 0 : 7 ) :: N type ( nambu ) :: GR0 , GA0 type ( nambu ) :: GR1 , GA1 integer :: i , j ! Construct the basis matrices do i = 0 , 7 N ( i ) = nambuv ( i ) end do ! Construct the propagator matrices (this side) GR0 = G0 % retarded () GA0 = G0 % advanced () ! Construct the propagator matrices (other side) GR1 = G1 % retarded () GA1 = G1 % advanced () ! Construct the boundary coefficients do j = 0 , 7 do i = 0 , 7 ! Calculate the boundary matrix coefficients C0 ( i , j ) = ( this % conductance / 8 ) * trace ( ( R ( GA1 ) * N ( i ) - N ( i ) * R ( GR1 ) ) * ( ( GR0 * N ( j ) - N ( j ) * GA0 ) ) ) C1 ( i , j ) = ( this % conductance / 8 ) * trace ( ( GA0 * N ( i ) - N ( i ) * GR0 ) * ( T ( GR1 * N ( j ) - N ( j ) * GA1 ) ) ) end do end do contains pure function T ( U ) ! Calculates the contents of the spin-active boundary condition commutators: !   I ~ [F(G₁), G₀] ! This is used for the calculation of the boundary coefficient matrices. ! Note that this version of the function only includes transmission terms, ! and used to evaluate contributions from the other side of the interface. type ( nambu ), intent ( in ) :: U type ( nambu ) :: T real ( wp ) :: GMR real ( wp ) :: GT1 associate ( M => this % M , P => this % polarization ) ! Calculate the normalized interface conductances GMR = P / ( 1 + sqrt ( 1 - P ** 2 )) GT1 = ( 1 - sqrt ( 1 - P ** 2 )) / ( 1 + sqrt ( 1 - P ** 2 )) ! Calculate the transmission function T = U + GMR * ( M * U + U * M ) + GT1 * M * U * M end associate end function pure function R ( U ) ! Calculates the contents of the spin-active boundary condition commutators: !   I ~ [F(G₁), G₀] ! This is used for the calculation of the boundary coefficient matrices. ! Note that this version of the function also includes reflection terms, ! and is used to evaluate contributions from this side of the interface. type ( nambu ), intent ( in ) :: U type ( nambu ) :: R complex ( wp ) :: Gphi associate ( M => this % M0 , Q => this % spinmixing ) ! Calculate the normalized interface conductance Gphi = ( 0 , - 1 ) * Q ! Calculate the reflection function R = T ( U ) + Gphi * M end associate end function end subroutine end module","tags":"","loc":"sourcefile/spinactive.f90.html"},{"title":"spinscattering.f90 – GENEUS","text":"Contents Modules spinscattering_m Source Code spinscattering.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This submodule is included by conductor.f, and contains equations which model !> spin-flip scattering, spin-orbit scattering, and magnetic orbital depairing. module spinscattering_m use :: condmat_m use :: material_m private ! Public interface public spinscattering , spinscattering_construct ! Type declarations type :: spinscattering ! Metadata class ( material ), pointer :: material => null () !! Pointer to the material modelled by this instance type ( nambu ), dimension ( 0 : 7 ) :: nambuv !! Pauli matrices spanning the 4×4 Spin-Nambu space ! Physical fields real ( wp ) :: depairing = 0.0_wp !! Orbital depairing coefficient real ( wp ) :: spinflip = 0.0_wp !! Spin-flip  scattering coefficient (1/8τΔ) real ( wp ) :: spinorbit = 0.0_wp !! Spin-orbit scattering coefficient (1/8τΔ) contains procedure :: diffusion_equation => spinscattering_diffusion_equation !! Diffusion equation procedure :: kinetic_equation => spinscattering_kinetic_equation !! Kinetic equation end type ! Type constructors interface spinscattering module procedure spinscattering_construct end interface contains function spinscattering_construct ( parent ) result ( this ) !! Constructs a spinscattering object with a given parent material. type ( spinscattering ) :: this class ( material ), target :: parent integer :: i ! Save a pointer to the parent object this % material => parent ! Memoize the most used basis matrices do i = 0 , 7 this % nambuv ( i ) = nambuv ( i ) end do end function pure subroutine spinscattering_diffusion_equation ( this , p ) !! Calculate the spin-flip and spin-orbit scattering terms in the diffusion !! equation, and update the second derivatives of the Riccati parameters. class ( spinscattering ), intent ( in ) :: this type ( propagator ), intent ( inout ) :: p type ( nambu ) :: G , R type ( nambu ) :: Gsf , Gso , Gdp real ( wp ) :: Csf , Cso , Cdp ! Construct the propagator matrix G = p % retarded () ! Construct the self-energy matrices associate ( N => this % nambuv ) Gdp = N ( 4 ) * G * N ( 4 ) Gsf = N ( 1 ) * G * N ( 1 ) + N ( 2 ) * G * N ( 2 ) + N ( 3 ) * G * N ( 3 ) Gso = N ( 4 ) * Gsf * N ( 4 ) end associate ! Calculate the self-energy prefactors ! (including 1/2i from the Riccati-parametrized Usadel equation) Cdp = ( this % depairing ) / ( 2 * 4 * this % material % thouless ) Csf = ( this % spinflip ) / ( 2 * 1 * this % material % thouless ) Cso = ( this % spinorbit ) / ( 2 * 1 * this % material % thouless ) ! Calculate the self-energy commutators R = Cdp * Gdp + Csf * Gsf + Cso * Gso R = R * G - G * R ! Update the second derivatives of the Riccati parameters associate ( U => R % matrix , & g => p % g , gt => p % gt , & dg => p % dg , dgt => p % dgt , & d2g => p % d2g , d2gt => p % d2gt ) d2g = d2g + ( pauli0 - g * gt ) * ( U ( 1 : 2 , 3 : 4 ) - U ( 1 : 2 , 1 : 2 ) * g ) d2gt = d2gt + ( pauli0 - gt * g ) * ( U ( 3 : 4 , 1 : 2 ) - U ( 3 : 4 , 3 : 4 ) * gt ) end associate end subroutine pure subroutine spinscattering_kinetic_equation ( this , Gp , R ) !! Calculate the self-energies in the kinetic equation. class ( spinscattering ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( inout ) :: R complex ( wp ) :: Csf , Cso , Cdp ! Calculate the self-energy prefactors Cdp = ( 0 , 1 ) * ( this % depairing ) / ( 4 * this % material % thouless ) Csf = ( 0 , 1 ) * ( this % spinflip ) / ( 1 * this % material % thouless ) Cso = ( 0 , 1 ) * ( this % spinorbit ) / ( 1 * this % material % thouless ) ! Calculate the self-energy contributions associate ( N => this % nambuv ) R = R & + Csf * Gp % selfenergy2 ( N ( 1 )) & + Csf * Gp % selfenergy2 ( N ( 2 )) & + Csf * Gp % selfenergy2 ( N ( 3 )) & + Cdp * Gp % selfenergy2 ( N ( 4 )) & + Cso * Gp % selfenergy2 ( N ( 5 )) & + Cso * Gp % selfenergy2 ( N ( 6 )) & + Cso * Gp % selfenergy2 ( N ( 7 )) end associate end subroutine end module","tags":"","loc":"sourcefile/spinscattering.f90.html"},{"title":"conductor.f90 – GENEUS","text":"Contents Modules conductor_m Source Code conductor.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This module defines the data type 'conductor', which models the physical state of a conductor for a discretized range !> of positions and energies.  It has two main applications: (i) it can be used as a base type for more exotic materials, !> such as superconductors and ferromagnets; (ii) it can be used in conjunction with such materials in hybrid structures. module conductor_m use :: stdio_m use :: condmat_m use :: material_m use :: spinorbit_m use :: spinactive_m use :: spinscattering_m private ! Type declarations type , public , extends ( material ) :: conductor ! Physical fields in the material type ( spinscattering ), allocatable :: spinscattering !! Spin-dependent scattering type ( spinorbit ), allocatable :: spinorbit !! Spin-orbit coupling ! Physical fields at the interfaces type ( spinactive ), allocatable :: spinactive_a !! Spin-active interface (left) type ( spinactive ), allocatable :: spinactive_b !! Spin-active interface (right) contains ! These methods are required by the class(material) abstract interface procedure :: construct => conductor_construct !! Constructs the object procedure :: initialize => conductor_initialize !! Initializes propagators procedure :: update_prehook => conductor_update_prehook !! Code to execute before updates procedure :: update_posthook => conductor_update_posthook !! Code to execute after  updates ! These methods contain the equations that describe electrical conductors procedure :: diffusion_equation => conductor_diffusion_equation !! Diffusion equation procedure :: diffusion_equation_a => conductor_diffusion_equation_a !! Boundary condition (left) procedure :: diffusion_equation_b => conductor_diffusion_equation_b !! Boundary condition (right) procedure :: kinetic_equation => conductor_kinetic_equation !! Kinetic equation procedure :: kinetic_equation_a => conductor_kinetic_equation_a !! Boundary condition (left) procedure :: kinetic_equation_b => conductor_kinetic_equation_b !! Boundary condition (right) ! These methods define miscellaneous utility functions procedure :: conf => conductor_conf !! Configures material parameters end type contains !--------------------------------------------------------------------------------! !                        IMPLEMENTATION OF CONSTRUCTORS                          ! !--------------------------------------------------------------------------------! subroutine conductor_construct ( this ) !! Constructs a conductor object initialized to a superconducting state. class ( conductor ), intent ( inout ) :: this ! Initialize locations allocate ( this % location ( 101 )) call linspace ( this % location , 0 + 1e-10_wp , 1 - 1e-10_wp ) ! Initialize energies allocate ( this % energy ( 1000 )) call linspace ( this % energy ( : 800 ), 1e-6_wp , 4.00_wp ) call linspace ( this % energy ( 800 : ), 4.00_wp , 3 0.0_wp ) ! Allocate memory for propagators allocate ( this % propagator ( size ( this % energy ), size ( this % location ))) ! Initialize superconductivity allocate ( this % correlation ( size ( this % location ))) this % correlation = eps ! Initialize magnetism allocate ( this % magnetization ( 1 : 3 , size ( this % location ))) this % magnetization = 0 ! Allocate memory for physical observables allocate ( this % supercurrent ( 0 : 7 , size ( this % location ))) allocate ( this % lossycurrent ( 0 : 7 , size ( this % location ))) allocate ( this % accumulation ( 0 : 7 , size ( this % location ))) allocate ( this % density ( size ( this % energy ), size ( this % location ), 0 : 7 )) ! Initialize observables this % supercurrent = 0 this % lossycurrent = 0 this % accumulation = 0 this % density = 0 ! Allocate boundary condition objects allocate ( this % spinactive_a ) allocate ( this % spinactive_b ) end subroutine subroutine conductor_initialize ( this ) !! Define the default initializer. class ( conductor ), intent ( inout ) :: this integer :: n , m ! Initialize the Riccati parameters do m = 1 , size ( this % location ) do n = 1 , size ( this % energy ) this % propagator ( n , m ) = propagator ( cx ( this % energy ( n ), this % scattering ), this % correlation ( m ) ) end do end do ! Initialize the distribution function do m = 1 , size ( this % location ) do n = 1 , size ( this % energy ) ! Finite nonequilibrium potentials this % propagator ( n , m ) % h = & [ & ( f ( n , + 1 , + 1 ) + f ( n , + 1 , - 1 ) + f ( n , - 1 , + 1 ) + f ( n , - 1 , - 1 )), & ( f ( n , + 1 , + 1 ) - f ( n , + 1 , - 1 ) + f ( n , - 1 , + 1 ) - f ( n , - 1 , - 1 )) * u ( 1 ), & ( f ( n , + 1 , + 1 ) - f ( n , + 1 , - 1 ) + f ( n , - 1 , + 1 ) - f ( n , - 1 , - 1 )) * u ( 2 ), & ( f ( n , + 1 , + 1 ) - f ( n , + 1 , - 1 ) + f ( n , - 1 , + 1 ) - f ( n , - 1 , - 1 )) * u ( 3 ), & ( f ( n , + 1 , + 1 ) + f ( n , + 1 , - 1 ) - f ( n , - 1 , + 1 ) - f ( n , - 1 , - 1 )), & ( f ( n , + 1 , + 1 ) - f ( n , + 1 , - 1 ) - f ( n , - 1 , + 1 ) + f ( n , - 1 , - 1 )) * u ( 1 ), & ( f ( n , + 1 , + 1 ) - f ( n , + 1 , - 1 ) - f ( n , - 1 , + 1 ) + f ( n , - 1 , - 1 )) * u ( 2 ), & ( f ( n , + 1 , + 1 ) - f ( n , + 1 , - 1 ) - f ( n , - 1 , + 1 ) + f ( n , - 1 , - 1 )) * u ( 3 ) & ] ! Transverse applied potentials if ( this % transverse ) then this % propagator ( n , m ) % h ( 4 : 7 ) = 0 end if ! Derivatives of the above this % propagator ( n , m ) % dh = 0 this % propagator ( n , m ) % d2h = 0 end do end do contains pure function f ( n , c , s ) result ( h ) ! Fermi distribution for a given energy (n), charge parity (c=±1), and spin (s=±1). integer , intent ( in ) :: n , c , s real ( wp ) :: h associate ( E => this % energy ( n ), & V => this % voltage * c , & Vs => this % spinvoltage * c * s , & T => this % temperature , & Ts => this % spintemperature * s ) h = tanh ( 0.8819384944310228_wp * ( E + V + Vs ) / ( T + Ts )) / 4 end associate end function pure function u ( m ) result ( r ) ! Nonequilibrium spin-projection along the m'th basis vector. integer , intent ( in ) :: m real ( wp ) :: r r = this % spinaxis ( m ) end function end subroutine !--------------------------------------------------------------------------------! !                     IMPLEMENTATION OF CONDUCTOR EQUATIONS                      ! !--------------------------------------------------------------------------------! pure subroutine conductor_diffusion_equation ( this , p , e , z ) !! Use the diffusion equation to calculate the second-derivatives !! of the Riccati parameters at an energy e and position z. class ( conductor ), intent ( in ) :: this complex ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: z type ( propagator ), intent ( inout ) :: p associate ( N => p % N , Nt => p % Nt , & g => p % g , gt => p % gt , & dg => p % dg , dgt => p % dgt , & d2g => p % d2g , d2gt => p % d2gt ) ! Calculate the second-derivatives of the Riccati parameters d2g = ( - 2.0_wp , 0.0_wp ) * dg * Nt * gt * dg - ( 0.0_wp , 2.0_wp ) * e * g d2gt = ( - 2.0_wp , 0.0_wp ) * dgt * N * g * dgt - ( 0.0_wp , 2.0_wp ) * e * gt ! Calculate the contribution from a spin-orbit coupling if ( allocated ( this % spinorbit )) then call this % spinorbit % diffusion_equation ( p ) end if ! Calculate the contribution from spin-dependent scattering if ( allocated ( this % spinscattering )) then call this % spinscattering % diffusion_equation ( p ) end if end associate end subroutine pure subroutine conductor_diffusion_equation_a ( this , p , a , r , rt ) !! Calculate residuals from the boundary conditions at the left interface. class ( conductor ), intent ( in ) :: this type ( propagator ), intent ( in ) :: p , a type ( spin ), intent ( inout ) :: r , rt complex ( wp ), dimension ( 1 : 4 , 1 : 4 ) :: I ! Calculate a matrix current from the propagators I = ( + 0.50_wp ) * this % spinactive_a % diffusion_current ( p % retarded (), a % retarded ()) ! Calculate the deviation from the boundary condition associate ( g => p % g , gt => p % gt , dg => p % dg , dgt => p % dgt ) r = dg - ( pauli0 - g * gt ) * ( I ( 1 : 2 , 3 : 4 ) - I ( 1 : 2 , 1 : 2 ) * g ) rt = dgt - ( pauli0 - gt * g ) * ( I ( 3 : 4 , 1 : 2 ) - I ( 3 : 4 , 3 : 4 ) * gt ) end associate ! Gauge-dependent terms in the case of spin-orbit coupling if ( allocated ( this % spinorbit )) then call this % spinorbit % diffusion_equation_a ( p , r , rt ) end if end subroutine pure subroutine conductor_diffusion_equation_b ( this , p , b , r , rt ) !! Calculate residuals from the boundary conditions at the right interface. class ( conductor ), intent ( in ) :: this type ( propagator ), intent ( in ) :: p , b type ( spin ), intent ( inout ) :: r , rt complex ( wp ), dimension ( 1 : 4 , 1 : 4 ) :: I ! Calculate a matrix current from the propagators I = ( - 0.50_wp ) * this % spinactive_b % diffusion_current ( p % retarded (), b % retarded ()) ! Calculate the deviation from the boundary condition associate ( g => p % g , gt => p % gt , dg => p % dg , dgt => p % dgt ) r = dg - ( pauli0 - g * gt ) * ( I ( 1 : 2 , 3 : 4 ) - I ( 1 : 2 , 1 : 2 ) * g ) rt = dgt - ( pauli0 - gt * g ) * ( I ( 3 : 4 , 1 : 2 ) - I ( 3 : 4 , 3 : 4 ) * gt ) end associate ! Gauge-dependent terms in the case of spin-orbit coupling if ( allocated ( this % spinorbit )) then call this % spinorbit % diffusion_equation_b ( p , r , rt ) end if end subroutine pure subroutine conductor_kinetic_equation ( this , Gp , R , z ) !! Calculate the self-energies in the kinetic equation. class ( conductor ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( inout ) :: R real ( wp ), intent ( in ) :: z ! There are no normal-metal terms R = 0 ! Spin-dependent scattering terms if ( allocated ( this % spinscattering )) then call this % spinscattering % kinetic_equation ( Gp , R ) end if end subroutine pure subroutine conductor_kinetic_equation_a ( this , Gp , Ga , Cp , Ca ) !! Calculate proportionality matrices for the boundary conditions at the left interface. class ( conductor ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp , Ga complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( out ) :: Cp , Ca ! Calculate the boundary coefficients call this % spinactive_a % kinetic_current ( Gp , Ga , Cp , Ca ) ! Direction of the interface normal Cp = + Cp Ca = + Ca end subroutine pure subroutine conductor_kinetic_equation_b ( this , Gp , Gb , Cp , Cb ) !! Calculate proportionality matrices for the boundary conditions at the right interface. class ( conductor ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp , Gb complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( out ) :: Cp , Cb ! Calculate the boundary coefficients call this % spinactive_b % kinetic_current ( Gp , Gb , Cp , Cb ) ! Direction of the interface normal Cp = - Cp Cb = - Cb end subroutine subroutine conductor_update_prehook ( this ) !! Code to execute before running the update method of a class(conductor) object. class ( conductor ), intent ( inout ) :: this ! Discard the tunneling conductance at vacuum interfaces if (. not . associated ( this % material_a )) then this % spinactive_a % conductance = 1 end if if (. not . associated ( this % material_b )) then this % spinactive_b % conductance = 1 end if ! Prepare variables associated with spin-orbit coupling if ( allocated ( this % spinorbit )) then call this % spinorbit % update_prehook end if ! Prepare variables associated with spin-active interfaces call this % spinactive_a % update_prehook call this % spinactive_b % update_prehook ! Modify the type string this % type_string = color_yellow // 'CONDUCTOR' // color_none end subroutine subroutine conductor_update_posthook ( this ) !! Code to execute after running the update method of a class(conductor) object. !! In particular, this function calculates supercurrents, dissipative currents, !! accumulations, and density of states, and stores the results in the object. class ( conductor ), intent ( inout ) :: this type ( nambu ), allocatable :: gauge real ( wp ), allocatable , dimension (:,:) :: I , J , Q complex ( wp ), allocatable , dimension (:) :: S integer :: n , m , k ! Allocate memory for the workspace allocate ( S ( size ( this % energy ))) allocate ( I ( size ( this % energy ), 0 : 7 )) allocate ( J ( size ( this % energy ), 0 : 7 )) allocate ( Q ( size ( this % energy ), 0 : 7 )) ! Calculate the gauge contribution if ( allocated ( this % spinorbit )) then allocate ( gauge ) gauge = diag ( + this % spinorbit % Az % matrix ,& - this % spinorbit % Azt % matrix ) end if ! Simplify the namespace associate ( E => this % energy , & z => this % location , & G => this % propagator , & D => this % density ) ! Iterate over positions do n = 1 , size ( z ) ! Calculate the spectral properties at this position do m = 1 , size ( E ) S ( m ) = G ( m , n ) % correlation () Q ( m ,:) = G ( m , n ) % accumulation () I ( m ,:) = G ( m , n ) % supercurrent ( gauge ) J ( m ,:) = G ( m , n ) % lossycurrent ( gauge ) D ( m , n ,:) = G ( m , n ) % density () end do ! Superconducting correlations depend on the cutoff S = S / log ( 2 * E ( size ( E ))) ! Heat and spin-heat observables depend on the energy do k = 4 , 7 Q (:, k ) = E * Q (:, k ) I (:, k ) = E * I (:, k ) J (:, k ) = E * J (:, k ) end do ! Integrate the spectral observables to find the total observables this % correlation ( n ) = integrate ( E , S , E ( 1 ), E ( size ( E ))) do k = 0 , 7 this % accumulation ( k , n ) = integrate ( E , Q (:, k ), E ( 1 ), E ( size ( E ))) this % supercurrent ( k , n ) = integrate ( E , I (:, k ), E ( 1 ), E ( size ( E ))) this % lossycurrent ( k , n ) = integrate ( E , J (:, k ), E ( 1 ), E ( size ( E ))) end do end do end associate ! Reset the center-of-mass phase if ( this % phaselock ) then associate ( g => this % correlation , i => ( 0 , 1 )) g = g / exp ( i * arg ( mean ( g ))) end associate end if ! Deallocate workspace memory deallocate ( S , Q , I , J ) end subroutine !--------------------------------------------------------------------------------! !                      IMPLEMENTATION OF UTILITY METHODS                         ! !--------------------------------------------------------------------------------! subroutine conductor_conf ( this , key , val ) !! Configure a material property based on a key-value pair. use :: evaluate_m class ( conductor ), intent ( inout ) :: this character ( * ), intent ( in ) :: key character ( * ), intent ( in ) :: val real ( wp ) :: tmp select case ( key ) case ( 'conductance_a' ) call evaluate ( val , this % spinactive_a % conductance ) case ( 'conductance_b' ) call evaluate ( val , this % spinactive_b % conductance ) case ( 'resistance_a' ) call evaluate ( val , tmp ) this % spinactive_a % conductance = 1 / tmp case ( 'resistance_b' ) call evaluate ( val , tmp ) this % spinactive_b % conductance = 1 / tmp case ( 'spinmixing_a' ) call evaluate ( val , this % spinactive_a % spinmixing ) case ( 'spinmixing_b' ) call evaluate ( val , this % spinactive_b % spinmixing ) case ( 'secondorder_a' ) call evaluate ( val , this % spinactive_a % secondorder ) case ( 'secondorder_b' ) call evaluate ( val , this % spinactive_b % secondorder ) case ( 'polarization_a' ) call evaluate ( val , this % spinactive_a % polarization ) case ( 'polarization_b' ) call evaluate ( val , this % spinactive_b % polarization ) case ( 'magnetization_a' ) call evaluate ( val , this % spinactive_a % magnetization ) this % spinactive_a % magnetization = unitvector ( this % spinactive_a % magnetization ) case ( 'magnetization_b' ) call evaluate ( val , this % spinactive_b % magnetization ) this % spinactive_b % magnetization = unitvector ( this % spinactive_b % magnetization ) case ( 'misalignment0_a' ) call evaluate ( val , this % spinactive_a % misalignment0 ) this % spinactive_a % misalignment0 = unitvector ( this % spinactive_a % misalignment0 ) case ( 'misalignment0_b' ) call evaluate ( val , this % spinactive_b % misalignment0 ) this % spinactive_b % misalignment0 = unitvector ( this % spinactive_b % misalignment0 ) case ( 'misalignment1_a' ) call evaluate ( val , this % spinactive_a % misalignment1 ) this % spinactive_a % misalignment1 = unitvector ( this % spinactive_a % misalignment1 ) case ( 'misalignment1_b' ) call evaluate ( val , this % spinactive_b % misalignment1 ) this % spinactive_b % misalignment1 = unitvector ( this % spinactive_b % misalignment1 ) case ( 'nanowire' ) call evaluate ( val , tmp ) if (. not . allocated ( this % spinorbit )) then allocate ( this % spinorbit ) this % spinorbit = spinorbit ( this ) end if this % spinorbit % field ( 3 ) = this % spinorbit % field ( 3 ) + ( - tmp ) * pauli1 case ( 'rashba' ) call evaluate ( val , tmp ) if (. not . allocated ( this % spinorbit )) then allocate ( this % spinorbit ) this % spinorbit = spinorbit ( this ) end if this % spinorbit % field ( 1 ) = this % spinorbit % field ( 1 ) + ( - tmp ) * pauli2 this % spinorbit % field ( 2 ) = this % spinorbit % field ( 2 ) + ( + tmp ) * pauli1 case ( 'dresselhaus' ) call evaluate ( val , tmp ) if (. not . allocated ( this % spinorbit )) then allocate ( this % spinorbit ) this % spinorbit = spinorbit ( this ) end if this % spinorbit % field ( 1 ) = this % spinorbit % field ( 1 ) + ( + tmp ) * pauli1 this % spinorbit % field ( 2 ) = this % spinorbit % field ( 2 ) + ( - tmp ) * pauli2 case ( 'gap' ) block real ( wp ), allocatable , dimension (:) :: r associate ( g => this % correlation , z => this % location , i => ( 0 , 1 )) call evaluate ( val , z , r ) g = r * exp ( i * arg ( g )) end associate end block case ( 'phase' ) block real ( wp ), allocatable , dimension (:) :: r associate ( g => this % correlation , z => this % location , i => ( 0 , 1 )) call evaluate ( val , z , r ) g = abs ( g ) * exp ( i * pi * r ) end associate end block case ( 'scattering_spinflip' ) if (. not . allocated ( this % spinscattering )) then allocate ( this % spinscattering ) this % spinscattering = spinscattering ( this ) end if call evaluate ( val , this % spinscattering % spinflip ) case ( 'scattering_spinorbit' ) if (. not . allocated ( this % spinscattering )) then allocate ( this % spinscattering ) this % spinscattering = spinscattering ( this ) end if call evaluate ( val , this % spinscattering % spinorbit ) case ( 'depairing' ) if (. not . allocated ( this % spinscattering )) then allocate ( this % spinscattering ) this % spinscattering = spinscattering ( this ) end if call evaluate ( val , this % spinscattering % depairing ) case ( 'zeroenergy' ) block logical :: tmp call evaluate ( val , tmp ) if ( tmp ) then deallocate ( this % energy ) allocate ( this % energy ( 1 )) this % energy ( 1 ) = 0 end if end block case default call material_conf ( this , key , val ) end select end subroutine end module","tags":"","loc":"sourcefile/conductor.f90.html"},{"title":"halfmetal.f90 – GENEUS","text":"Contents Modules halfmetal_m Source Code halfmetal.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This module defines the data type 'halfmetal', which models the physical state of a strong or halfmetallic ferromagnet. !> The type is a member of class(conductor), and inherits the internal structure and generic methods defined there. !> !> @TODO !>   Add an update_posthook to rescale density(:) and current(:) with the dependence of the diffusion constant matrix !>   on the polarization. Remember to check how the polarization dependence varies with the number of dimensions. !> !> @TODO !>   Check if a non-linear dependence of the polarization matrix on the polarization is more sensible? module halfmetal_m use :: stdio_m use :: condmat_m use :: material_m use :: conductor_m private ! Type declarations type , public , extends ( conductor ) :: halfmetal real ( wp ) :: polarization = 0.0_wp !! Spin-polarization of the ferromagnet type ( spin ), private :: P !! Polarization matrix contains procedure :: conf => halfmetal_conf !! Configures the material parameters procedure :: diffusion_equation => halfmetal_diffusion_equation !! Defines the Usadel diffusion equation procedure :: diffusion_equation_a => halfmetal_diffusion_equation_a !! Boundary condition at the left  interface procedure :: diffusion_equation_b => halfmetal_diffusion_equation_b !! Boundary condition at the right interface procedure :: update_prehook => halfmetal_update_prehook !! Code to execute before calculating the propagators procedure :: update_posthook => halfmetal_update_posthook !! Code to execute after  calculating the propagators procedure :: update_density => halfmetal_update_density !! Calculates the density of states end type contains !--------------------------------------------------------------------------------! !                     IMPLEMENTATION OF HALFMETAL EQUATIONS                      ! !--------------------------------------------------------------------------------! pure subroutine halfmetal_diffusion_equation ( this , p , e , z ) !! Use the diffusion equation to calculate the second-derivatives !! of the Riccati parameters at an energy e and a position z. class ( halfmetal ), intent ( in ) :: this complex ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: z type ( propagator ), intent ( inout ) :: p type ( spin ) :: h , ht , dh , dht type ( spin ) :: N , Nt associate ( g => p % g , gt => p % gt , & dg => p % dg , dgt => p % dgt , & d2g => p % d2g , d2gt => p % d2gt ) ! Ensure that the Riccati parameters are diagonal h = g % matrix * pauli0 % matrix ht = gt % matrix * pauli0 % matrix dh = dg % matrix * pauli0 % matrix dht = dgt % matrix * pauli0 % matrix ! Calculate the normalization matrices N = inverse ( pauli0 - h * ht ) Nt = inverse ( pauli0 - ht * h ) ! Calculate the second-derivatives of the Riccati parameters associate ( P => this % P ) d2g = ( - 2.0_wp , 0.0_wp ) * dh * Nt * ht * dh - ( 0.0_wp , 2.0_wp ) * e * P * h d2gt = ( - 2.0_wp , 0.0_wp ) * dht * N * h * dht - ( 0.0_wp , 2.0_wp ) * e * P * ht end associate end associate end subroutine pure subroutine halfmetal_diffusion_equation_a ( this , p , a , r , rt ) !! Calculate residuals from the boundary conditions at the left interface. class ( halfmetal ), intent ( in ) :: this type ( propagator ), intent ( in ) :: p , a type ( spin ), intent ( inout ) :: r , rt ! Diagonal components: use regular spin-active boundary conditions call this % conductor % diffusion_equation_a ( p , a , r , rt ) ! Off-diagonal components: use boundary conditions g,gt=0 r % matrix ( 1 , 2 ) = p % g % matrix ( 1 , 2 ) r % matrix ( 2 , 1 ) = p % g % matrix ( 2 , 1 ) rt % matrix ( 1 , 2 ) = p % gt % matrix ( 1 , 2 ) rt % matrix ( 2 , 1 ) = p % gt % matrix ( 2 , 1 ) end subroutine pure subroutine halfmetal_diffusion_equation_b ( this , p , b , r , rt ) !! Calculate residuals from the boundary conditions at the right interface. class ( halfmetal ), intent ( in ) :: this type ( propagator ), intent ( in ) :: p , b type ( spin ), intent ( inout ) :: r , rt ! Diagonal components: use regular spin-active boundary conditions call this % conductor % diffusion_equation_b ( p , b , r , rt ) ! Off-diagonal components: use boundary conditions g,gt=0 r % matrix ( 1 , 2 ) = p % g % matrix ( 1 , 2 ) r % matrix ( 2 , 1 ) = p % g % matrix ( 2 , 1 ) rt % matrix ( 1 , 2 ) = p % gt % matrix ( 1 , 2 ) rt % matrix ( 2 , 1 ) = p % gt % matrix ( 2 , 1 ) end subroutine subroutine halfmetal_update_prehook ( this ) !! Code to execute before running the update method of a class(halfmetal) object. class ( halfmetal ), intent ( inout ) :: this ! Verify that a polarization is defined if ( abs ( this % polarization ) < eps ) then call error ( 'Tried to update a halfmetal with no defined polarization!' ) end if ! Update the polarization matrix this % P % matrix ( 1 , 1 ) = 2 / ( 1 + eps + this % polarization ) this % P % matrix ( 1 , 2 ) = 0 this % P % matrix ( 2 , 1 ) = 0 this % P % matrix ( 2 , 2 ) = 2 / ( 1 + eps - this % polarization ) ! Update the left  interface parameters this % spinactive_a % magnetization = [ 0 , 0 , 1 ] this % spinactive_a % polarization = this % polarization ! Update the right interface parameters this % spinactive_b % magnetization = [ 0 , 0 , 1 ] this % spinactive_b % polarization = this % polarization ! Call the superclass prehook call this % conductor % update_prehook ! Modify the type string this % type_string = color_red // 'HALFMETAL' // color_none end subroutine subroutine halfmetal_update_posthook ( this ) !! Code to execute after running the update method of a class(halfmetal) object. class ( halfmetal ), intent ( inout ) :: this real ( wp ) :: error integer :: n , m ! Call the superclass posthook call this % conductor % update_posthook ! Perform sanity checks error = 0 do m = 1 , size ( this % location ) do n = 1 , size ( this % energy ) ! Find the maximum off-diagonal element error = max ( abs ( this % propagator ( n , m )% g % matrix ( 1 , 2 )), error ) error = max ( abs ( this % propagator ( n , m )% g % matrix ( 2 , 1 )), error ) error = max ( abs ( this % propagator ( n , m )% gt % matrix ( 1 , 2 )), error ) error = max ( abs ( this % propagator ( n , m )% gt % matrix ( 2 , 1 )), error ) end do end do ! Update density of states call this % update_density ! Status information if ( this % information >= 0 . and . this % order > 0 ) then write ( stdout , '(6x,a,f10.8,a)' ) 'Max error:  ' , error , '                                        ' end if end subroutine pure subroutine halfmetal_update_density ( this ) !! Calculate the density of states in the halfmetal. class ( halfmetal ), intent ( inout ) :: this integer :: n , m ! Allocate memory if necessary if (. not . allocated ( this % density )) then allocate ( this % density ( size ( this % energy ), size ( this % location ), 0 : 7 )) end if ! Placeholder code this % density = inf ! ! Calculate the density of states at each position and energy ! ! TODO: Generalize this to work for strong ferromagnets too. ! if (this % polarization > 0) then !   do m=1,size(this%location) !     do n=1,size(this%energy) !       this % density(n,m) = 2 * re(this % propagator(n,m) % N % matrix(1,1)) - 1 !     end do !   end do ! else !   do m=1,size(this%location) !     do n=1,size(this%energy) !       this % density(n,m) = 2 * re(this % propagator(n,m) % N % matrix(2,2)) - 1 !     end do !   end do ! end if end subroutine !--------------------------------------------------------------------------------! !                      IMPLEMENTATION OF UTILITY METHODS                         ! !--------------------------------------------------------------------------------! subroutine halfmetal_conf ( this , key , val ) !! Configure a material property based on a key-value pair. use :: evaluate_m class ( halfmetal ), intent ( inout ) :: this character ( * ), intent ( in ) :: key character ( * ), intent ( in ) :: val real ( wp ) :: tmp select case ( key ) case ( 'polarization' ) call evaluate ( val , this % polarization ) case default call this % conductor % conf ( key , val ) end select end subroutine end module","tags":"","loc":"sourcefile/halfmetal.f90.html"},{"title":"spinorbit.f90 – GENEUS","text":"Contents Modules spinorbit_m Source Code spinorbit.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This submodule is included by conductor.f, and contains the equations which model spin-orbit coupling in diffusive materials. module spinorbit_m use :: condmat_m use :: material_m private ! Public interface public spinorbit , spinorbit_construct ! Type declarations type :: spinorbit class ( material ), pointer :: material => null () !! Pointer to the material modelled by this instance type ( spin ), dimension ( 1 : 3 ) :: field !! Spin-orbit coupling field (SU(2) gauge field) type ( spin ) :: Ax , Ay , Az , A2 !! Spin-orbit coupling matrices (the components and square) type ( spin ) :: Axt , Ayt , Azt , A2t !! Spin-orbit coupling matrices (tilde-conjugated versions) contains procedure :: diffusion_equation => spinorbit_diffusion_equation !! Diffusion equation procedure :: diffusion_equation_a => spinorbit_diffusion_equation_a !! Boundary condition (left) procedure :: diffusion_equation_b => spinorbit_diffusion_equation_b !! Boundary condition (right) procedure :: update_prehook => spinorbit_update_prehook !! Code to execute before updates end type ! Type constructors interface spinorbit module procedure spinorbit_construct end interface contains function spinorbit_construct ( parent ) result ( this ) !! Constructs a spinorbit object with a given parent material. type ( spinorbit ) :: this class ( material ), target :: parent ! Save a pointer to the parent object this % material => parent ! Ensure that the spin-orbit field is zero this % field = spin ( 0 ) end function subroutine spinorbit_update_prehook ( this ) !! Updates the internal variables associated with spin-orbit coupling. class ( spinorbit ), intent ( inout ) :: this ! Spin-orbit coupling terms in the equations for the Riccati parameter γ this % Ax = this % material % length * this % field ( 1 ) this % Ay = this % material % length * this % field ( 2 ) this % Az = this % material % length * this % field ( 3 ) this % A2 = this % Ax ** 2 + this % Ay ** 2 + this % Az ** 2 ! Spin-orbit coupling terms in the equations for the Riccati parameter γ~ this % Axt = conjg ( this % Ax ) this % Ayt = conjg ( this % Ay ) this % Azt = conjg ( this % Az ) this % A2t = conjg ( this % A2 ) end subroutine pure subroutine spinorbit_diffusion_equation ( this , p ) !! Calculate the spin-orbit coupling terms in the diffusion equation, !! and update the second derivatives of the Riccati parameters. class ( spinorbit ), intent ( in ) :: this type ( propagator ), intent ( inout ) :: p associate ( Ax => this % Ax , Axt => this % Axt , & Ay => this % Ay , Ayt => this % Ayt , & Az => this % Az , Azt => this % Azt , & A2 => this % A2 , A2t => this % A2t , & N => p % N , Nt => p % Nt , & g => p % g , gt => p % gt , & dg => p % dg , dgt => p % dgt , & d2g => p % d2g , d2gt => p % d2gt ) ! Update the second derivatives of the Riccati parameters d2g = d2g + ( A2 * g - g * A2t ) & + ( 2.0_wp , 0.0_wp ) * ( Ax * g + g * Axt ) * Nt * ( Axt + gt * Ax * g ) & + ( 2.0_wp , 0.0_wp ) * ( Ay * g + g * Ayt ) * Nt * ( Ayt + gt * Ay * g ) & + ( 2.0_wp , 0.0_wp ) * ( Az * g + g * Azt ) * Nt * ( Azt + gt * Az * g ) & + ( 0.0_wp , 2.0_wp ) * ( Az + g * Azt * gt ) * N * dg & + ( 0.0_wp , 2.0_wp ) * dg * Nt * ( gt * Az * g + Azt ) d2gt = d2gt + ( A2t * gt - gt * A2 ) & + ( 2.0_wp , 0.0_wp ) * ( Axt * gt + gt * Ax ) * N * ( Ax + g * Axt * gt ) & + ( 2.0_wp , 0.0_wp ) * ( Ayt * gt + gt * Ay ) * N * ( Ay + g * Ayt * gt ) & + ( 2.0_wp , 0.0_wp ) * ( Azt * gt + gt * Az ) * N * ( Az + g * Azt * gt ) & - ( 0.0_wp , 2.0_wp ) * ( Azt + gt * Az * g ) * Nt * dgt & - ( 0.0_wp , 2.0_wp ) * dgt * N * ( g * Azt * gt + Az ) end associate end subroutine pure subroutine spinorbit_diffusion_equation_a ( this , p , r , rt ) !! Calculate the spin-orbit coupling terms in the left boundary condition, and update the residuals. class ( spinorbit ), target , intent ( in ) :: this type ( propagator ), intent ( in ) :: p type ( spin ), intent ( inout ) :: r , rt associate ( Az => this % Az , Azt => this % Azt , & g => p % g , gt => p % gt ) ! Update the residuals r = r - ( 0.0_wp , 1.0_wp ) * ( Az * g + g * Azt ) rt = rt + ( 0.0_wp , 1.0_wp ) * ( Azt * gt + gt * Az ) end associate end subroutine pure subroutine spinorbit_diffusion_equation_b ( this , p , r , rt ) !! Calculate the spin-orbit coupling terms in the right boundary condition, and update the residuals. class ( spinorbit ), target , intent ( in ) :: this type ( propagator ), intent ( in ) :: p type ( spin ), intent ( inout ) :: r , rt associate ( Az => this % Az , Azt => this % Azt , & g => p % g , gt => p % gt ) ! Update the residuals r = r - ( 0.0_wp , 1.0_wp ) * ( Az * g + g * Azt ) rt = rt + ( 0.0_wp , 1.0_wp ) * ( Azt * gt + gt * Az ) end associate end subroutine end module","tags":"","loc":"sourcefile/spinorbit.f90.html"},{"title":"structure.f90 – GENEUS","text":"Contents Modules structure_m Source Code structure.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This module defines a data type 'structure', which is useful for constructing and using multilayer hybrid structures. It !> also exports the type definitions and constructors for all class(material) types, although these should rarely be needed. module structure_m use :: stdio_m use :: condmat_m use :: material_m use :: conductor_m use :: superconductor_m use :: ferromagnet_m use :: halfmetal_m private ! Export class(material) types public material , conductor , superconductor , ferromagnet , halfmetal ! Type declaration type , public :: structure ! Endpoints of the contained linked list class ( material ), pointer :: a => null () !! First material class ( material ), pointer :: b => null () !! Last  material ! Output units for physical observables integer , allocatable :: supercurrent !! Output unit (allocate to write supercurrents  to file) integer , allocatable :: lossycurrent !! Output unit (allocate to write lossycurrents  to file) integer , allocatable :: accumulation !! Output unit (allocate to write accumulations  to file) integer , allocatable :: correlation !! Output unit (allocate to write correlations   to file) integer , allocatable :: magnetization !! Output unit (allocate to write magnetizations to file) integer , allocatable :: distribution !! Output unit (allocate to write distributions  to file) integer , allocatable :: density !! Output unit (allocate to write density of states to file) contains ! Basic construction and management procedure :: push => structure_push !! Construct a single layer procedure :: conf => structure_conf !! Configure a single layer procedure :: cmap => structure_cmap !! Configure  all layers procedure :: fmap => structure_fmap !! Manipulate all layers ! Manipulation of the physical state procedure :: initialize => structure_initialize !! Reset the physical state procedure :: save => structure_save !! Save the physical state procedure :: load => structure_load !! Load the physical state procedure :: update => structure_update !! Update the physical state procedure :: update_prehook => structure_update_prehook !! Execute all update prehooks procedure :: update_posthook => structure_update_posthook !! Execute all update posthooks procedure :: converge => structure_converge !! Update until convergence procedure :: write => structure_write !! Write out observables ! Auxiliary helper functions procedure :: difference => structure_difference !! Check how much the physical state changes procedure :: materials => structure_materials !! Check the number of enabled materials procedure :: selfconsistency => structure_selfconsistency !! Whether selfconsistency iteration is required procedure :: superconductors => structure_superconductors !! Check the number of enables superconductors procedure :: chargeviolation => structure_chargeviolation !! Check the violation of charge conservation procedure :: gap => structure_gap !! Check the minimum superconducting gap end type ! Type constructor interface structure module procedure structure_construct end interface ! Interface for external routines that can be mapped onto class(material) objects abstract interface subroutine mappable ( ptr ) use :: material_m class ( material ), pointer :: ptr end subroutine end interface ! Interface for external routines that can be used by convergence() calls abstract interface subroutine hook () end subroutine end interface contains subroutine structure_push ( this , string ) !! Constructs a new class(material) object at the bottom of the multilayer stack. class ( structure ), intent ( inout ) :: this character ( * ), intent ( in ) :: string ! Construct the material if (. not . associated ( this % b )) then ! This is the first layer in the structure call alloc ( this % b , string ) call this % b % construct this % a => this % b else ! This is not the first layer in the structure call alloc ( this % b % material_b , string ) call this % b % material_b % construct this % b % material_b % material_a => this % b this % b => this % b % material_b end if ! Status information write ( stdout , * ) write ( stdout , * ) '[' // string // ']' contains subroutine alloc ( ptr , str ) !! Allocates memory for a new material layer. class ( material ), pointer :: ptr character ( * ) :: str select case ( str ) case ( 'halfmetal' ) allocate ( halfmetal :: ptr ) case ( 'ferromagnet' ) allocate ( ferromagnet :: ptr ) case ( 'superconductor' ) allocate ( superconductor :: ptr ) case ( 'conductor' ) allocate ( conductor :: ptr ) case default call error ( 'Material type \"' // trim ( str ) // '\" unknown!' ) end select end subroutine end subroutine subroutine structure_conf ( this , key , val ) !! Configures the last material pushed to the multilayer stack. !! !! @TODO !!   Add global config options for the entire stack. class ( structure ), intent ( inout ) :: this character ( * ), intent ( in ) :: key character ( * ), intent ( in ) :: val character ( 24 ) :: str ! Status information write ( str , * ) key // ':' write ( stdout , * ) str // val ! Configuration procedure if (. not . associated ( this % b )) then ! Global configuration since no materials exist select case ( key ) case default call warning ( \"Unknown structure option '\" // key // \"' ignored.\" ) end select else ! Local configuration of only the last material call this % b % conf ( key , val ) end if end subroutine subroutine structure_cmap ( this , key , val ) !! Maps a configuration option onto each element of the multilayer stack. class ( structure ), intent ( inout ) :: this character ( * ), intent ( in ) :: key class ( * ), intent ( in ) :: val character ( 1024 ) :: str ! Parse the config option str = '' select type ( val ) type is ( character ( * )) str = val type is ( logical ) write ( str , '(l1)' ) val type is ( integer ) write ( str , '(i0)' ) val type is ( real ( wp )) write ( str , '(g0)' ) val end select ! Map it onto each material call this % fmap ( conf , every = . true .) contains subroutine conf ( m ) class ( material ), pointer :: m ! Configure the material call m % conf ( key , trim ( adjustl ( str ))) end subroutine end subroutine subroutine structure_fmap ( this , routine , every ) !! Maps a subroutine onto each element of the multilayer stack. class ( structure ), target :: this class ( material ), pointer :: ptr procedure ( mappable ) :: routine logical , optional :: every ! Traverse the structure from top to bottom call top ( ptr ) do while ( associated ( ptr )) call routine ( ptr ) call next ( ptr ) end do contains function check ( ptr ) result ( skip ) ! Check if a material layer should be skipped. class ( material ), pointer :: ptr logical :: skip logical :: every_ ! Check for optional arguments if ( present ( every )) then every_ = every else every_ = . false . end if ! Decide whether to skip this layer if ( every_ ) then ! Process every layer in the stack skip = . false . else if (. not . associated ( ptr )) then ! There are no layers left to skip skip = . false . else ! Decide based on the user config skip = ptr % order <= 0 end if end function subroutine top ( ptr ) ! Find the first enabled material in the stack. class ( material ), pointer :: ptr ptr => this % a do while ( check ( ptr )) ptr => ptr % material_b end do end subroutine subroutine next ( ptr ) ! Find the next enabled material in the stack. class ( material ), pointer :: ptr if ( associated ( ptr )) then ptr => ptr % material_b do while ( check ( ptr )) ptr => ptr % material_b end do end if end subroutine end subroutine function structure_gap ( this ) result ( gap ) !! Obtains the mean gap in the enabled superconductor. If there are multiple such !! superconductors in the junction, then it returns the minimum of the mean gaps. class ( structure ), target :: this real ( wp ) :: gap logical :: found ! Initialize variables gap = huge ( real ( wp )) found = . false . ! Check the gaps call this % fmap ( find ) ! If no superconductor was found, raise an error if (. not . found ) then call error ( 'No superconductors with order > 0 in the junction!' ) end if contains subroutine find ( m ) class ( material ), pointer :: m select type ( m ) class is ( superconductor ) gap = min ( gap , sum ( abs ( m % gap_function )) / max ( 1 , size ( m % gap_function ))) found = . true . end select end subroutine end function subroutine structure_initialize ( this ) !! Initializes the state of the entire multilayer stack. class ( structure ), target :: this ! Initialize all material states call this % fmap ( initialize , every = . true .) contains subroutine initialize ( m ) class ( material ), pointer :: m call m % initialize end subroutine end subroutine subroutine structure_save ( this ) !! Saves the state of the entire multilayer stack. class ( structure ), target :: this ! Save all material states call this % fmap ( save ) contains subroutine save ( m ) class ( material ), pointer :: m call m % save end subroutine end subroutine subroutine structure_load ( this ) !! Loads the saved state of the multilayer stack. class ( structure ), target :: this ! Load all material states call this % fmap ( load ) contains subroutine load ( m ) class ( material ), pointer :: m call m % load end subroutine end subroutine subroutine structure_update ( this , bootstrap ) !! Updates the state of the entire multilayer stack. class ( structure ), target :: this logical , optional :: bootstrap integer :: order ! Update materials in order do order = 1 , 16 call this % fmap ( update ) end do contains subroutine update ( m ) class ( material ), pointer :: m if ( m % order == order ) then call m % update ( bootstrap ) end if end subroutine end subroutine subroutine structure_converge ( this , threshold , iterations , bootstrap , prehook , posthook ) !! Performs a convergence procedure, where the state of every material in the stack !! is repeatedly updated until the residuals drop below some specified threshold !! and/or a certain number of iterations have been performed. If bootstrap is set !! to true, the selfconsistency equations will only be solved once at the end, but !! not inbetween the individual iterations. If a prehook and/or posthook is given, !! those subroutines will be executed before/after each iteration of the update. class ( structure ), target :: this real ( wp ), optional :: threshold real ( wp ) :: threshold_ integer , optional :: iterations integer :: iterations_ logical , optional :: bootstrap logical :: bootstrap_ procedure ( hook ), optional :: prehook procedure ( hook ), optional :: posthook integer :: materials logical :: selfconsistency integer :: n ! Set default arguments threshold_ = 1 iterations_ = 0 bootstrap_ = . false . ! Check optional arguments if ( present ( threshold )) threshold_ = threshold if ( present ( iterations )) iterations_ = iterations if ( present ( bootstrap )) bootstrap_ = bootstrap ! Count the number of materials materials = this % materials () selfconsistency = this % selfconsistency () ! Reset any iteration counters call this % cmap ( 'iteration' , 0 ) ! If we're not bootstrapping, then we wish to execute all posthook actions at least once if (. not . bootstrap_ ) then call this % update_posthook end if ! If we're not bootstrapping, then we have to solve the diffusion equation until convergence. ! If we're bootstrapping, it's only required if we have selfconsistency equations to solve. if ((. not . bootstrap_ ) . or . selfconsistency ) then n = 0 do ! Update counter n = n + 1 ! Status information if ( bootstrap_ ) then call status_head ( 'BOOTSTRAPPING' ) else call status_head ( 'CONVERGING' ) end if if ( present ( prehook )) then call prehook end if call status_body ( 'State difference' , this % difference ()) if (. not . bootstrap_ ) then call status_body ( 'Charge violation' , this % chargeviolation ()) end if call status_body ( 'Iteration' , n ) call status_foot ! Update the material state (non-selfconsistently) call this % update ( bootstrap = bootstrap_ ) ! Write the results to files call this % write ! Extra actions defined by the user if ( present ( posthook )) then call posthook end if ! Exit criterion #1: one iteration is sufficient for convergence if (( materials == 1 ) . and . ( bootstrap_ . or . (. not . selfconsistency ))) then exit end if ! Exit criterion #2: minimum number of iterations reached, ! and the materials converged within specified parameters if (( n >= iterations_ ) . and . ( this % difference () < threshold_ )) then exit end if end do end if end subroutine subroutine structure_update_prehook ( this ) !! Silently execute all update prehooks. class ( structure ) :: this ! Traverse all materials call this % fmap ( prehook ) contains subroutine prehook ( ptr ) class ( material ), pointer :: ptr integer :: info ! Disable status messages info = ptr % information if ( ptr % information >= 0 ) then ptr % information = - 1 end if ! Silently run prehooks call ptr % update_prehook ! Reenable status messages ptr % information = info end subroutine end subroutine subroutine structure_update_posthook ( this ) !! Silently execute all update posthooks. class ( structure ) :: this ! Traverse all materials call this % fmap ( posthook ) contains subroutine posthook ( ptr ) class ( material ), pointer :: ptr integer :: info ! Disable status messages info = ptr % information if ( ptr % information >= 0 ) then ptr % information = - 1 end if ! Silently run posthooks call ptr % update_posthook ! Reenable status messages ptr % information = info end subroutine end subroutine function structure_materials ( this ) result ( num ) !! Checks the number of enabled materials in the multilayer stack. class ( structure ), target :: this integer :: num ! Initialize variables num = 0 ! Count the number of materials call this % fmap ( count ) contains subroutine count ( ptr ) class ( material ), pointer :: ptr num = num + 1 end subroutine end function function structure_selfconsistency ( this ) result ( res ) !! Checks whether selfconsistency iteration is required. class ( structure ), target :: this logical :: res ! Initialize variables res = . false . ! Check for materials where selfconsistency iterations are required call this % fmap ( count ) contains subroutine count ( ptr ) class ( material ), pointer :: ptr select type ( ptr ) class is ( superconductor ) res = res . or . ( allocated ( ptr % zeeman )) . or . ( ptr % selfconsistent ) class is ( ferromagnet ) res = res . or . ( allocated ( ptr % zeeman )) end select end subroutine end function function structure_superconductors ( this ) result ( num ) !! Checks the number of selfconsistent superconductors in the multilayer stack. class ( structure ), target :: this integer :: num ! Initialize variables num = 0 ! Count the number of superconductors call this % fmap ( count ) contains subroutine count ( ptr ) class ( material ), pointer :: ptr select type ( ptr ) class is ( superconductor ) if ( ptr % selfconsistent ) then num = num + 1 end if end select end subroutine end function function structure_difference ( this ) result ( difference ) !! Checks how much the multilayer stack has changed recently. class ( structure ), target :: this real ( wp ) :: difference ! Initialization difference = 0 ! Traverse all materials call this % fmap ( check ) contains subroutine check ( m ) class ( material ), pointer :: m ! Accumulate the difference difference = max ( difference , m % difference ) end subroutine end function function structure_chargeviolation ( this ) result ( difference ) !! Checks how much the charge current varies with position. Since charge current !! is supposed to be conserved through the junction, this provides a measure of !! charge conservation violation, i.e. if the solution is physically realistic. class ( structure ), target :: this real ( wp ) :: difference real ( wp ) :: minimum real ( wp ) :: maximum ! Set starting values minimum = + inf maximum = - inf ! Traverse all materials to find the most extreme currents call this % fmap ( check ) ! Calculate the difference between these extreme values difference = maximum - minimum contains subroutine check ( m ) class ( material ), pointer :: m ! Determine the charge current extrema maximum = max ( maximum , maxval ( m % supercurrent ( 0 ,:) + m % lossycurrent ( 0 ,:))) minimum = min ( minimum , minval ( m % supercurrent ( 0 ,:) + m % lossycurrent ( 0 ,:))) end subroutine end function subroutine structure_write ( this ) !! Writes physical observables to output files. class ( structure ), target :: this real ( wp ) :: a , b ! Initialize variables b = 0 ! Traverse all materials call this % fmap ( writer ) ! Sync data to output files call sync ( this % accumulation ) call sync ( this % supercurrent ) call sync ( this % lossycurrent ) call sync ( this % correlation ) call sync ( this % magnetization ) call sync ( this % distribution ) call sync ( this % density ) contains subroutine sync ( unit ) integer , allocatable , intent ( in ) :: unit if ( allocated ( unit )) then flush ( unit ) rewind ( unit ) end if end subroutine subroutine writer ( ptr ) class ( material ), pointer :: ptr real ( wp ) :: p , z integer :: n , m ! Calculate the endpoints a = b b = b + ptr % length ! Loop over all positions do m = 1 , size ( ptr % location ) ! Calculate current position p = ptr % location ( m ) z = a + ( b - a ) * p ! Write accumulations if ( allocated ( this % accumulation )) then write ( this % accumulation , '(*(es20.12e3,:,\"\t\"))' ) & z , ptr % accumulation (:, m ) end if ! Write supercurrents if ( allocated ( this % supercurrent )) then write ( this % supercurrent , '(*(es20.12e3,:,\"\t\"))' ) & z , ptr % supercurrent (:, m ) end if ! Write dissipative currents if ( allocated ( this % lossycurrent )) then write ( this % lossycurrent , '(*(es20.12e3,:,\"\t\"))' ) & z , ptr % lossycurrent (:, m ) end if ! Write superconducting correlations if ( allocated ( this % correlation )) then write ( this % correlation , '(*(es20.12e3,:,\"\t\"))' ) & z , abs ( ptr % correlation ( m )), arg ( ptr % correlation ( m )) / pi end if ! Write effective magnetizations if ( allocated ( this % magnetization )) then write ( this % magnetization , '(*(es20.12e3,:,\"\t\"))' ) & z , ptr % magnetization (:, m ) end if ! Write distribution functions if ( allocated ( this % distribution )) then ! Energies do n = 1 , size ( ptr % energy ) write ( this % distribution , '(*(es20.12e3,:,\"\t\"))' ) & z , ptr % energy ( n ), ptr % propagator ( n , m ) % h end do ! Newline write ( this % distribution , '()' ) end if ! Write density of states if ( allocated ( this % density )) then ! Negative energies do n = size ( ptr % energy ), 1 , - 1 write ( this % density , '(*(es20.12e3,:,\"\t\"))' ) & z , - ptr % energy ( n ), ptr % density ( n , m , 4 : 7 ) end do ! Positive energies do n = 1 , size ( ptr % energy ), + 1 write ( this % density , '(*(es20.12e3,:,\"\t\"))' ) & z , + ptr % energy ( n ), ptr % density ( n , m , 0 : 3 ) end do ! Newline write ( this % density , '()' ) end if end do end subroutine end subroutine function structure_construct () result ( this ) !! Constructs a multilayer stack from a configuration file. type ( structure ) :: this character ( len = 4096 ) :: file integer :: unit integer :: iostat integer :: status character ( len = 2048 ) :: str , arg integer :: line , i , j , k ! Initialize variables line = 0 unit = 0 iostat = 0 status = 0 ! Open the config file call get_command_argument ( 1 , file , status = status ) if ( status /= 0 ) then call error ( 'Missing the command line argument #1, i.e. the name of configuration file.' ) end if unit = input ( trim ( file )) ! Command arguments call get_command ( str ) write ( stdout , '(a)' ) trim ( str ) ! Status information call status_box ( 'CONFIGURATION' ) ! Read the config file do while ( iostat == 0 ) ! Increase line counter line = line + 1 ! Read one line from file str = '' read ( unit , '(a)' , iostat = iostat ) str ! Strip comments from line i = scan ( str , '#' ) if ( i > 0 ) then str = str (: i - 1 ) end if ! Strip whitespace from line str = trim ( adjustl ( str )) ! Substitute command line arguments i = scan ( str , '{' ) j = scan ( str , '}' ) do while ( i > 0 . and . j - 1 >= i + 1 ) read ( str ( i + 1 : j - 1 ), * , iostat = status ) k if ( status /= 0 ) then call error ( 'Failed to parse parameter ' // str ( i : j ) // ' defined by the configuration file.' ) end if call get_command_argument ( k + 1 , arg , status = status ) if ( status /= 0 ) then write ( arg , '(i0)' ) k + 1 call error ( 'Missing command line argument #' // trim ( arg ) // ', i.e. parameter ' // str ( i : j ) // ' in the config file.' ) end if if ( scan ( trim ( arg ), '+-' ) == 1 ) then ! Escape signed command line arguments str = str (: i - 1 ) // '(' // trim ( arg ) // ')' // str ( j + 1 :) else ! Do not escape unsigned arguments str = str (: i - 1 ) // trim ( arg ) // str ( j + 1 :) end if i = scan ( str , '{' ) j = scan ( str , '}' ) end do ! Construct the material i = scan ( str , '[' ) j = scan ( str , ']' ) if ( i == 1 . and . j > i ) then call this % push ( trim ( adjustl ( str ( i + 1 : j - 1 )))) cycle end if ! Configure the material i = scan ( str , ':' ) if ( i > 0 ) then call this % conf ( trim ( adjustl ( str (: i - 1 ))), trim ( adjustl ( str ( i + 1 :)))) cycle end if ! Check if this line contains garbage if ( str /= '' ) then write ( str , '(i0)' ) line call error ( 'Failed to parse line ' // trim ( str ) // ' in the config file.' ) end if end do ! Close the config file close ( unit = unit ) ! Confirm that there is at least one material layer if ( this % materials () < 1 ) then call error ( 'The material stack described by \"' // file // '\" has no layers with order > 0!' ) end if ! Initialize all materials call this % initialize end function end module","tags":"","loc":"sourcefile/structure.f90.html"},{"title":"superconductor.f90 – GENEUS","text":"Contents Modules superconductor_m Source Code superconductor.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This module defines the data type 'superconductor', which models the physical state of a superconductor. The type is !> a member of class(conductor), and thus inherits the internal structure and generic methods defined in conductor_m. module superconductor_m use :: stdio_m use :: condmat_m use :: conductor_m use :: ferromagnet_m private ! Type declaration type , public , extends ( ferromagnet ) :: superconductor ! These parameters control the physical characteristics of the material complex ( wp ), allocatable :: gap_history (:,:) !! Superconducting order parameter as a function of location (backup of previously calculated gaps on the location mesh) complex ( wp ), allocatable :: gap_function (:) !! Superconducting order parameter as a function of location (relative to the zero-temperature gap of a bulk superconductor) real ( wp ), allocatable :: gap_location (:) !! Location array for the gap function (required because we interpolate the gap to a higher resolution than the propagators) contains ! These methods define the class(material) interface procedure :: construct => superconductor_construct !! Construct  propagators procedure :: initialize => superconductor_initialize !! Initialize propagators ! These methods contain the equations that describe superconductors procedure :: diffusion_equation => superconductor_diffusion_equation !! Diffusion equation procedure :: kinetic_equation => superconductor_kinetic_equation !! Kinetic equation procedure :: update_gap => superconductor_update_gap !! Calculate the superconducting order parameter procedure :: update_boost => superconductor_update_boost !! Boost the convergence of the order parameter (Steffensen's method) procedure :: update_prehook => superconductor_update_prehook !! Update the internal variables before calculating the propagators procedure :: update_posthook => superconductor_update_posthook !! Update the superconducting order parameter from  the propagators ! These methods are used to access and mutate the parameters procedure :: gap => superconductor_gap !! Return the superconducting order parameter at a given position ! These methods define miscellaneous utility functions procedure :: conf => superconductor_conf !! Configure material parameters end type contains !--------------------------------------------------------------------------------! !                        IMPLEMENTATION OF CONSTRUCTORS                          ! !--------------------------------------------------------------------------------! subroutine superconductor_construct ( this ) !! Constructs a superconducting material that is initialized to a superconducting state. class ( superconductor ), intent ( inout ) :: this ! Call the superclass constructor call this % ferromagnet % construct ! Initialize superconductivity this % correlation = 1 ! Enable a higher-order solver this % method = 6 ! Allocate interpolation functions allocate ( this % gap_history ( size ( this % location ), 1 : 3 )) allocate ( this % gap_location ( 4096 * size ( this % location ))) allocate ( this % gap_function ( size ( this % gap_location ))) call linspace ( this % gap_location , this % location ( 1 ), this % location ( size ( this % location ))) end subroutine subroutine superconductor_initialize ( this ) !! Redefine the default initializer. class ( superconductor ), intent ( inout ) :: this integer :: info ! Call the superclass initializer call this % ferromagnet % initialize ! Disable status messages info = this % information if ( this % information >= 0 ) then this % information = - 1 end if ! Silently initialize the gap call this % update_gap ! Reenable status messages this % information = info ! Reset the iteration counter this % iteration = 0 end subroutine !--------------------------------------------------------------------------------! !                   IMPLEMENTATION OF SUPERCONDUCTOR METHODS                     ! !--------------------------------------------------------------------------------! pure subroutine superconductor_diffusion_equation ( this , p , e , z ) !! Use the diffusion equation to calculate the second derivatives of the Riccati parameters at point z. class ( superconductor ), intent ( in ) :: this complex ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: z type ( propagator ), intent ( inout ) :: p complex ( wp ) :: gap , gapt associate ( N => p % N , Nt => p % Nt , & g => p % g , gt => p % gt , & dg => p % dg , dgt => p % dgt , & d2g => p % d2g , d2gt => p % d2gt ) ! Lookup the superconducting order parameter gap = ( this % gap ( z )) / ( this % thouless ) gapt = conjg ( gap ) ! Calculate the second derivatives of the Riccati parameters (superclass terms) call this % ferromagnet % diffusion_equation ( p , e , z ) ! Calculate the second derivatives of the Riccati parameters (superconductor terms) d2g = d2g - gap * pauli2 + gapt * g * pauli2 * g d2gt = d2gt + gapt * pauli2 - gap * gt * pauli2 * gt end associate end subroutine pure subroutine superconductor_kinetic_equation ( this , Gp , R , z ) !! Calculate the self-energies in the kinetic equation. class ( superconductor ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( inout ) :: R real ( wp ), intent ( in ) :: z complex ( wp ) :: gap , gapt type ( nambu ) :: S ! Call the superclass kinetic equation call this % ferromagnet % kinetic_equation ( Gp , R , z ) ! Lookup the superconducting order parameter gap = ( this % gap ( z )) / ( this % thouless ) gapt = conjg ( gap ) ! Construct the self-energy matrix S % matrix ( 1 , 4 ) = + gap S % matrix ( 2 , 3 ) = - gap S % matrix ( 3 , 2 ) = + gapt S % matrix ( 4 , 1 ) = - gapt ! Calculate the self-energy contribution R = R + Gp % selfenergy1 ( S ) end subroutine subroutine superconductor_update_prehook ( this ) !! Code to execute before running the update method of a class(superconductor) object. class ( superconductor ), intent ( inout ) :: this ! Call the superclass prehook call this % ferromagnet % update_prehook ! Modify the type string this % type_string = color_green // 'SUPERCONDUCTOR' // color_none end subroutine subroutine superconductor_update_posthook ( this ) !! Updates the superconducting order parameter based on the propagators of the system. class ( superconductor ), intent ( inout ) :: this ! Call the superclass posthook call this % ferromagnet % update_posthook ! Update the superconducting gap using fixpoint-iteration if ( this % selfconsistent ) then call this % update_gap end if ! Boost the superconducting gap using Steffensen's method if ( this % selfconsistent . and . this % boost ) then call this % update_boost end if end subroutine subroutine superconductor_update_gap ( this ) !! Interpolate the superconducting correlations Δ(z) to a higher resolution, !! to make the calculations more stable near strong ferromagnetic materials. class ( superconductor ), intent ( inout ) :: this !! Superconductor object real ( wp ) :: diff !! Change between iterations ! Interpolate the gap as a function of position to a higher resolution this % gap_function = interpolate ( this % location , this % correlation , this % gap_location ) ! Save the calculated gap as backup associate ( b => this % gap_history , m => lbound ( this % gap_history , 2 ), n => ubound ( this % gap_history , 2 ) ) b (:, m : n - 1 ) = b (:, m + 1 : n ) b (:, n ) = this % correlation diff = mean ( abs ( b (:, n ) - b (:, n - 1 ))) end associate ! Status information if ( this % information >= 0 . and . this % order > 0 ) then write ( stdout , '(6x,a,f10.8,a,10x)' ) 'Gap change: ' , diff end if end subroutine subroutine superconductor_update_boost ( this ) !! Boost the convergence of the order parameter using Steffensen's method. !! !! The basic idea is that a selfconsistent solution of the Usadel equations can be !! regarded as a fixpoint iteration problem Δ=f(Δ), where the function f consists !! of solving the diffusion and gap equations one time. We're seeking the point !! where f'(Δ)=0, and this can be done more efficiently using e.g. Newtons method !! than a straight-forward fixpoint-iteration. Using Newtons method, we get: !!   Δ_{n+1} = Δ_{n} - f'(Δ_n)/f''(Δ_n) !! Using a finite-difference approximation for the derivatives, we arrive at the !! Steffensen iteration scheme, which yields an improved 2nd-order convergence: !!   Δ_{n+3} = Δ_{n} - (Δ_{n+1} - Δ_{n})²/(Δ_{n+2} - 2Δ_{n+1} + Δ_{n}) !! In most of my tests, the simulation time is then reduced by a factor 2x to 5x. !! !! @NOTE: !!   I have also experimented with several higher-order methods, including methods !!   that utilize the 3rd derivative or perform multiple successive boosts. However, !!   my experience so far is that these are less stable than Steffensen's method, !!   and often converged more slowly. These methods have therefore been discarded. class ( superconductor ), intent ( inout ) :: this complex ( wp ), dimension ( size ( this % location )) :: g , d1 , d2 logical :: u ! Update the iterator this % iteration = modulo ( this % iteration + 1 , 8 ) ! Stop here if it is not yet time to boost if ( this % iteration > 0 ) then return end if ! Boost the convergence using Steffensen's method d1 = f ( 2 ) - f ( 1 ) d2 = f ( 3 ) - 2 * f ( 2 ) + f ( 1 ) g = f ( 1 ) - d1 ** 2 / d2 ! Do not boost adjacent to transparent interfaces if ( this % transparent_a ) then g ( lbound ( g , 1 )) = this % gap ( 0.0_wp ) end if if ( this % transparent_b ) then g ( ubound ( g , 1 )) = this % gap ( 1.0_wp ) end if ! Interpolate the gap as a function of position to a higher resolution this % gap_function = interpolate ( this % location , g , this % gap_location ) ! Perform one extra update if necessary u = . false . if ( associated ( this % material_a )) then u = u . or . ( this % material_a % order > 0 ) end if if ( associated ( this % material_b )) then u = u . or . ( this % material_b % order > 0 ) end if if ( u ) then call this % update ( bootstrap = . true .) end if ! Status information if ( this % information >= 0 . and . this % order > 0 ) then write ( stdout , '(6x,a,f10.8,a,10x)' ) 'Gap boost:  ' , mean ( abs ( g - f ( 3 ))) end if contains pure function f ( n ) result ( r ) ! Define an accessor for the gap after n iterations. integer , intent ( in ) :: n complex ( wp ), dimension ( size ( this % gap_history , 1 )) :: r r = this % gap_history (:, n ) end function end subroutine !--------------------------------------------------------------------------------! !                    IMPLEMENTATION OF GETTERS AND SETTERS                       ! !--------------------------------------------------------------------------------! pure function superconductor_gap ( this , location ) result ( gap ) !! Returns the superconducting order parameter at the given location. class ( superconductor ), intent ( in ) :: this real ( wp ), intent ( in ) :: location complex ( wp ) :: gap integer :: n , m associate ( f => this % gap_function , fp => gap , p => location ) ! Calculate the index corresponding to the given location m = size ( f ) - 1 n = floor ( p * m + 1 ) ! Interpolate the superconducting order parameter at that point if ( n <= 1 ) then fp = f ( 1 ) else fp = f ( n - 1 ) + ( f ( n ) - f ( n - 1 )) * ( p * m - ( n - 2 )) end if end associate end function !--------------------------------------------------------------------------------! !                      IMPLEMENTATION OF UTILITY METHODS                         ! !--------------------------------------------------------------------------------! subroutine superconductor_conf ( this , key , val ) !! Configure a material property based on a key-value pair. use :: evaluate_m class ( superconductor ), intent ( inout ) :: this character ( * ), intent ( in ) :: key character ( * ), intent ( in ) :: val select case ( key ) case default call this % ferromagnet % conf ( key , val ) end select end subroutine end module","tags":"","loc":"sourcefile/superconductor.f90.html"},{"title":"ferromagnet.f90 – GENEUS","text":"Contents Modules ferromagnet_m Source Code ferromagnet.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This module defines the data type 'ferromagnet', which models the physical state of a ferromagnet. The type is a !> member of class(conductor), and thus inherits the internal structure and generic methods defined in conductor_m. module ferromagnet_m use :: stdio_m use :: condmat_m use :: conductor_m private ! Type declaration type , public , extends ( conductor ) :: ferromagnet real ( wp ), allocatable :: zeeman !! How easy the material is magnetized by spin accumulation real ( wp ), allocatable :: exchange (:,:) !! Magnetic exchange field as a function of position real ( wp ), allocatable , private :: z (:) !! Used by internal subroutines to handle location data type ( spin ), allocatable , private :: h (:) !! Used by internal subroutines to handle exchange fields contains ! These methods define the class(material) interface procedure :: update_prehook => ferromagnet_update_prehook !! Code to execute before calculating the propagators ! These methods contain the equations that describe ferromagnets procedure :: diffusion_equation => ferromagnet_diffusion_equation !! Diffusion equation procedure :: kinetic_equation => ferromagnet_kinetic_equation !! Kinetic equation ! These methods define miscellaneous utility functions procedure :: conf => ferromagnet_conf !! Configures material parameters end type contains !--------------------------------------------------------------------------------! !                    IMPLEMENTATION OF FERROMAGNET METHODS                       ! !--------------------------------------------------------------------------------! pure subroutine ferromagnet_diffusion_equation ( this , p , e , z ) !! Use the diffusion equation to calculate the second derivatives of the Riccati parameters at point z. class ( ferromagnet ), intent ( in ) :: this complex ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: z type ( propagator ), intent ( inout ) :: p type ( spin ) :: h , ht real ( wp ) :: d integer :: n , m associate ( g => p % g , gt => p % gt , & dg => p % dg , dgt => p % dgt , & d2g => p % d2g , d2gt => p % d2gt ) ! Calculate the second derivatives of the Riccati parameters (conductor terms) call this % conductor % diffusion_equation ( p , e , z ) if ( allocated ( this % h )) then ! Calculate the index corresponding to the given location m = size ( this % h ) - 1 ! Number of array intervals n = floor ( z * m + 1 ) ! Nearest position in array ! Extract the exchange field terms at that point if ( n <= 1 ) then ! Left edge of the material h = this % h ( 1 ) else ! Linear interpolation from known values. The relative displacement d is defined ! as [z - location(n-1)]/[location(n) - location(n-1)], but assuming location(:) ! is a uniform array of values in the range [0,1], the below will be equivalent. d = z * m - ( n - 2 ) h = this % h ( n - 1 ) + ( this % h ( n ) - this % h ( n - 1 )) * d end if ! Find the corresponding tilde-conjugate ht = conjg ( h ) ! Calculate the second derivatives of the Riccati parameters (ferromagnet terms) associate ( i => ( 0.00_wp , 1.00_wp ) ) d2g = d2g - i * ( h * g - g * ht ) d2gt = d2gt + i * ( ht * gt - gt * h ) end associate end if end associate end subroutine pure subroutine ferromagnet_kinetic_equation ( this , Gp , R , z ) !! Calculate the self-energies in the kinetic equation. class ( ferromagnet ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( inout ) :: R real ( wp ), intent ( in ) :: z type ( nambu ) :: S real ( wp ) :: d type ( spin ) :: h , ht integer :: n , m ! Call the superclass kinetic equation call this % conductor % kinetic_equation ( Gp , R , z ) if ( allocated ( this % h )) then ! Calculate the index corresponding to the given location m = size ( this % h ) - 1 ! Number of array intervals n = floor ( z * m + 1 ) ! Nearest position in array ! Extract the exchange field terms at that point if ( n <= 1 ) then ! Left edge of the material h = this % h ( 1 ) else ! Linear interpolation from known values. The relative displacement d is defined ! as [z - location(n-1)]/[location(n) - location(n-1)], but assuming location(:) ! is a uniform array of values in the range [0,1], the below will be equivalent. d = z * m - ( n - 2 ) h = this % h ( n - 1 ) + ( this % h ( n ) - this % h ( n - 1 )) * d end if ! Find the corresponding tilde-conjugate ht = conjg ( h ) ! Construct the self-energy matrix S % matrix ( 1 : 2 , 1 : 2 ) = h S % matrix ( 3 : 4 , 3 : 4 ) = ht ! Calculate the self-energy contribution R = R + Gp % selfenergy1 ( S ) end if end subroutine subroutine ferromagnet_update_prehook ( this ) !! Updates the exchange field terms in the diffusion equation. class ( ferromagnet ), intent ( inout ) :: this ! Ferromagnet object that will be updated real ( wp ), allocatable , dimension (:,:) :: interpolation ! High-resolution magnetization interpolation integer :: n ! Loop variable ! Call the superclass prehook call this % conductor % update_prehook ! Update magnetization matrices if ( allocated ( this % exchange ) . or . allocated ( this % zeeman )) then ! Allocate and initialize workspace allocate ( interpolation ( 3 , size ( this % location ) * 4096 )) if (. not . allocated ( this % h )) then allocate ( this % h ( size ( interpolation , 2 ))) allocate ( this % z ( size ( interpolation , 2 ))) call linspace ( this % z , this % location ( 1 ), this % location ( size ( this % location ))) end if ! Calculate the effective magnetization this % magnetization = 0 if ( allocated ( this % exchange )) then this % magnetization = this % magnetization + ( this % exchange ( 1 : 3 ,:)) end if if ( allocated ( this % zeeman )) then this % magnetization = this % magnetization + ( this % accumulation ( 1 : 3 ,:)) * ( this % zeeman ) end if ! High-resolution interpolation interpolation ( 1 ,:) = interpolate ( this % location , this % magnetization ( 1 ,:), this % z ) interpolation ( 2 ,:) = interpolate ( this % location , this % magnetization ( 2 ,:), this % z ) interpolation ( 3 ,:) = interpolate ( this % location , this % magnetization ( 3 ,:), this % z ) ! Update the internal variables do n = 1 , size ( interpolation , 2 ) this % h ( n ) = ( interpolation ( 1 , n ) * pauli1 + interpolation ( 2 , n ) * pauli2 + interpolation ( 3 , n ) * pauli3 ) / ( this % thouless ) end do ! Clean up deallocate ( interpolation ) end if ! Modify the type string if ( allocated ( this % exchange ) . or . allocated ( this % zeeman )) then this % type_string = color_red // 'MAGNET' // color_none end if end subroutine !--------------------------------------------------------------------------------! !                      IMPLEMENTATION OF UTILITY METHODS                         ! !--------------------------------------------------------------------------------! subroutine ferromagnet_conf ( this , key , val ) !! Configure a material property based on a key-value pair. use :: evaluate_m class ( ferromagnet ), intent ( inout ) :: this character ( * ), intent ( in ) :: key character ( * ), intent ( in ) :: val select case ( key ) case ( 'magnetization' ) call evaluate ( val , this % location , this % exchange ) case ( 'zeeman' ) allocate ( this % zeeman ) call evaluate ( val , this % zeeman ) case default ! Pass this option to the superclass call this % conductor % conf ( key , val ) end select end subroutine end module","tags":"","loc":"sourcefile/ferromagnet.f90.html"},{"title":"material.f90 – GENEUS","text":"Contents Modules material_m Source Code material.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Materials !> !> This module defines the data type 'material',  which models the state of a physical material for a discretized range of !> positions and energies. This is an abstract type, meaning that it is not intended to be instantiated on its own, but is !> intended as a base type for physical materials like conductors, superconductors, and ferromagnets. In other words, this !> type defines the essential data structures and program structure, while the derived subtypes will define actual physics. module material_m use :: stdio_m use :: condmat_m private ! Public declarations public :: material_conf , material_load ! Type declarations type , public , abstract :: material ! Material properties that affect the equilibrium state real ( wp ) :: length = 1.00_wp !! Material length (L/ξ) real ( wp ) :: thouless = 1.00_wp !! Thouless energy (ħD/L²) real ( wp ) :: scattering = 0.01_wp !! Inelastic scattering (η/Δ₀) logical :: transparent_a = . false . !! Interface transparency (left) logical :: transparent_b = . false . !! Interface transparency (right) logical :: phaselock = . false . !! Lock the center-of-mass phase? ! Material properties that affect the nonequilibrium state logical :: nonequilibrium = . false . !! Equilibrium? logical :: transverse = . false . !! Transverse potential gradients? real ( wp ) :: voltage = 0.00_wp !! Voltage (eV/Δ₀) real ( wp ) :: temperature = 0.01_wp !! Temperature (T/Tc) real ( wp ) :: spinvoltage = 0.00_wp !! Spin-voltage (eVs/Δ₀) real ( wp ) :: spintemperature = 0.00_wp !! Spin-temperature (Ts/Tc) real ( wp ), dimension ( 1 : 3 ) :: spinaxis = [ 0 , 0 , 1 ] !! Spin quantization axis ! Physical state modelled using quasiclassical propagators real ( wp ), allocatable :: energy (:) !! Energy domain real ( wp ), allocatable :: location (:) !! Position domain type ( propagator ), allocatable :: propagator (:,:) !! Propagator values type ( propagator ), allocatable :: backup (:,:) !! Propagator backups ! Physical observables derived from the propagators above real ( wp ), allocatable :: density (:,:,:) !! Spin-resolved density of states real ( wp ), allocatable :: supercurrent (:,:) !! Charge, spin, heat, and spin-heat supercurrents real ( wp ), allocatable :: lossycurrent (:,:) !! Charge, spin, heat, and spin-heat dissipative currents real ( wp ), allocatable :: accumulation (:,:) !! Charge, spin, heat, and spin-heat accumulation real ( wp ), allocatable :: magnetization (:,:) !! Magnetization due to exchange and Zeeman effects complex ( wp ), allocatable :: correlation (:) !! Superconducting pair-correlations ! Hybrid structures are modeled as double-linked lists integer :: order = 1 !! Simulation priority of this material class ( material ), pointer :: material_a => null () !! Material to the left  (default: vacuum) class ( material ), pointer :: material_b => null () !! Material to the right (default: vacuum) ! Control parameters for the numerical solvers integer :: iteration = 0 !! Used to keep track of selfconsistent iteration cycles logical :: selfconsistent = . true . !! Whether to selfconsistently calculate the superconducting gap logical :: boost = . true . !! Whether to use convergence acceleration methods integer :: scaling = 128 !! Maximal mesh increase (range: 2&#94;N, N>1) integer :: method = 4 !! Runge—Kutta order (range: 2, 4, 6) integer :: control = 2 !! Error control (1: defect, 2: global error, 3: 1 then 2, 4: 1 and 2) real ( wp ) :: tolerance = 1e-10_wp !! Error tolerance (maximum defect or global error) integer :: information = 0 !! Debug information (range: [-1,2]) real ( wp ) :: difference = 1e+10_wp !! Difference between iterations ! The following variables are used for input/output purposes, and should be modified by class(material) constructors character ( len = 128 ) :: type_string = 'MATERIAL' !! Name of this material contains ! These methods define how to update the physical state of the material procedure ( manipulate ), deferred :: construct !! Construct  object procedure ( initialize ), deferred :: initialize !! Initialize object procedure ( manipulate ), deferred :: update_prehook !! Executed before update procedure ( manipulate ), deferred :: update_posthook !! Executed after  update procedure :: update => material_update !! Calculate propagators procedure :: update_diffusion => diffusion_update !! Calculate propagators (in equilibrium) procedure :: update_kinetic => kinetic_update !! Calculate propagators (nonequilibrium) ! These methods define the physical equations used by the update methods procedure ( diffusion_equation ), deferred :: diffusion_equation !! Diffusion equation procedure ( diffusion_equation_a ), deferred :: diffusion_equation_a !! Boundary condition (left) procedure ( diffusion_equation_b ), deferred :: diffusion_equation_b !! Boundary condition (right) procedure ( kinetic_equation ), deferred :: kinetic_equation !! Kinetic equation procedure ( kinetic_equation_a ), deferred :: kinetic_equation_a !! Boundary condition (left) procedure ( kinetic_equation_b ), deferred :: kinetic_equation_b !! Boundary condition (right) ! These methods define miscellaneous utility functions procedure :: conf => material_conf !! Configures material parameters procedure :: save => material_save !! Saves the state of the material procedure :: load => material_load !! Loads the state of the material end type ! Declare submodule procedures interface module subroutine kinetic_update ( this ) class ( material ), target , intent ( inout ) :: this end subroutine module subroutine diffusion_update ( this ) class ( material ), target , intent ( inout ) :: this end subroutine end interface ! Declare subclass procedures abstract interface subroutine initialize ( this ) !! This interface is used for the deferred procedure initialize. import material , wp class ( material ), intent ( inout ) :: this end subroutine subroutine manipulate ( this ) !! This interface is used for the deferred procedures construct, update_prehook, and update_posthook. import material class ( material ), intent ( inout ) :: this end subroutine pure subroutine diffusion_equation ( this , p , e , z ) !! This interface is used for the deferred procedure diffusion_equation. import material , propagator , wp class ( material ), intent ( in ) :: this type ( propagator ), intent ( inout ) :: p complex ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: z end subroutine pure subroutine diffusion_equation_a ( this , p , a , r , rt ) !! This interface is used for the deferred procedure diffusion_equation_a. import material , propagator , spin , wp class ( material ), intent ( in ) :: this type ( propagator ), intent ( in ) :: p , a type ( spin ), intent ( inout ) :: r , rt end subroutine pure subroutine diffusion_equation_b ( this , p , b , r , rt ) !! This interface is used for the deferred procedure diffusion_equation_b. import material , propagator , spin , wp class ( material ), intent ( in ) :: this type ( propagator ), intent ( in ) :: p , b type ( spin ), intent ( inout ) :: r , rt end subroutine pure subroutine kinetic_equation ( this , Gp , R , z ) !! This interface is used for the deferred procedure kinetic_equation. import material , propagator , wp class ( material ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( inout ) :: R real ( wp ), intent ( in ) :: z end subroutine pure subroutine kinetic_equation_a ( this , Gp , Ga , Cp , Ca ) !! This interface is used for the deferred procedure kinetic_equation_a. import material , propagator , wp class ( material ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp , Ga complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( out ) :: Cp , Ca end subroutine pure subroutine kinetic_equation_b ( this , Gp , Gb , Cp , Cb ) !! This interface is used for the deferred procedure kinetic_equation_b. import material , propagator , wp class ( material ), intent ( in ) :: this type ( propagator ), intent ( in ) :: Gp , Gb complex ( wp ), dimension ( 0 : 7 , 0 : 7 ), intent ( out ) :: Cp , Cb end subroutine end interface contains !--------------------------------------------------------------------------------! !                    IMPLEMENTATION OF STATE UPDATE METHODS                      ! !--------------------------------------------------------------------------------! subroutine material_update ( this , bootstrap ) !! This subroutine updates the state of the material by solving the diffusion !! equations for the equilibrium propagators, the kinetic equations for the !! nonequilibrium propagators, and then calculating physical observables. class ( material ), intent ( inout ) :: this !! Material that will be updated logical , optional , intent ( in ) :: bootstrap !! Disable calculation of observables ! Only update materials with a positive order if ( this % order <= 0 ) then return end if ! Call the prehook method call this % update_prehook ! Status information if ( this % information >= 0 ) then block character ( len = 10 ) :: str write ( str , '(2x,\"\u001b[1m#\",i0)' ) this % order write ( stdout , '(a,a,20x)' ) str , trim ( this % type_string ) end block end if ! Reset the difference since last update to zero this % difference = 0.0_wp ! Solve the diffusion equations call this % update_diffusion ! Solve the kinetic equations if ( this % nonequilibrium ) then call this % update_kinetic end if ! Status information if ( this % information >= 0 ) then write ( stdout , '(6x,a,f10.8,a)' ) 'Max change: ' , this % difference , '                                        ' end if ! Stop here if bootstrapping if ( present ( bootstrap )) then if ( bootstrap ) then return end if end if ! Call the posthook method call this % update_posthook end subroutine !--------------------------------------------------------------------------------! !                      IMPLEMENTATION OF UTILITY METHODS                         ! !--------------------------------------------------------------------------------! subroutine material_conf ( this , key , val ) !! Configure a material property based on a key-value pair. use :: evaluate_m class ( material ), intent ( inout ) :: this character ( * ), intent ( in ) :: key character ( * ), intent ( in ) :: val select case ( key ) case ( \"length\" ) call evaluate ( val , this % length ) this % thouless = 1 / ( this % length ** 2 + eps ) case ( \"scattering\" ) call evaluate ( val , this % scattering ) case ( \"temperature\" ) call evaluate ( val , this % temperature ) case ( \"voltage\" ) call evaluate ( val , this % voltage ) case ( \"spinvoltage\" ) call evaluate ( val , this % spinvoltage ) case ( \"spintemperature\" ) call evaluate ( val , this % spintemperature ) case ( \"spinaxis\" ) call evaluate ( val , this % spinaxis ) this % spinaxis = unitvector ( this % spinaxis ) case ( \"transverse\" ) call evaluate ( val , this % transverse ) case ( \"transparent_a\" ) call evaluate ( val , this % transparent_a ) case ( \"transparent_b\" ) call evaluate ( val , this % transparent_b ) case ( \"order\" ) call evaluate ( val , this % order ) if ( this % order > 16 ) then call error ( \"The order of the material must be be maximum 16.\" ) else if ( this % order < 0 ) then call error ( \"The order of the material must be be minimum 0.\" ) end if case ( \"iteration\" ) call evaluate ( val , this % iteration ) case ( \"selfconsistent\" ) call evaluate ( val , this % selfconsistent ) case ( \"boost\" ) call evaluate ( val , this % boost ) case ( \"phaselock\" ) call evaluate ( val , this % phaselock ) case ( \"equilibrium\" ) call evaluate ( val , this % nonequilibrium ) this % nonequilibrium = . not . this % nonequilibrium case ( \"nonequilibrium\" ) call evaluate ( val , this % nonequilibrium ) case default call error ( \"Unknown material option '\" // key // \"'.\" ) end select end subroutine subroutine material_save ( this ) !! Save a backup of the current material state. class ( material ), intent ( inout ) :: this ! Make sure the backup exists if (. not . allocated ( this % backup )) then allocate ( this % backup ( size ( this % propagator , 1 ), size ( this % propagator , 2 ))) end if ! Make a backup of the propagators call this % propagator % save ( this % backup ) end subroutine subroutine material_load ( this ) !! Load a backup of a previous material state. class ( material ), intent ( inout ) :: this integer :: info ! Load saved propagators call this % propagator % load ( this % backup ) ! Disable status messages info = this % information if ( this % information >= 0 ) then this % information = - 1 end if ! Silently recalculate derived properties call this % update_posthook ! Reenable status messages this % information = info end subroutine end module","tags":"","loc":"sourcefile/material.f90.html"},{"title":"converge.f90 – GENEUS","text":"Contents Programs converge_p Source Code converge.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Programs !> !> Calculates general steady-state observables for a superconducting structure. program converge_p use :: structure_m use :: stdio_m use :: math_m !--------------------------------------------------------------------------! !                                GLOBAL VARIABLES                          ! !--------------------------------------------------------------------------! ! Declare the superconducting structure type ( structure ) :: stack ! Declare program control parameters real ( wp ), parameter :: threshold = 1e-2 real ( wp ), parameter :: tolerance = 1e-8 !--------------------------------------------------------------------------! !                           INITIALIZATION PROCEDURE                       ! !--------------------------------------------------------------------------! ! Construct the superconducting structure stack = structure () ! Define output files stack % supercurrent = output ( 'supercurrent.dat' ) stack % lossycurrent = output ( 'lossycurrent.dat' ) stack % accumulation = output ( 'accumulation.dat' ) stack % distribution = output ( 'distribution.dat' ) stack % correlation = output ( 'correlation.dat' ) stack % magnetization = output ( 'magnetization.dat' ) stack % density = output ( 'density.dat' ) !--------------------------------------------------------------------------! !                            CONVERGENCE PROCEDURE                         ! !--------------------------------------------------------------------------! ! Bootstrap procedure (not self-consistent) call stack % converge ( threshold = threshold , bootstrap = . true .) ! Convergence procedure (self-consistent) call stack % converge ( threshold = tolerance ) ! Write out the final results call finalize () !--------------------------------------------------------------------------! !                                 SUBROUTINES                              ! !--------------------------------------------------------------------------! contains subroutine finalize call status_head ( 'STEADY STATE' ) call status_body ( 'State difference' , stack % difference ()) call status_body ( 'Charge violation' , stack % chargeviolation ()) call status_foot () end subroutine end program","tags":"","loc":"sourcefile/converge.f90.html"},{"title":"sweep_voltage.f90 – GENEUS","text":"Contents Programs voltage_p Source Code sweep_voltage.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Programs !> !> Calculates the current-voltage relation of a superconducting structure. program voltage_p use :: structure_m use :: stdio_m use :: math_m !--------------------------------------------------------------------------! !                                GLOBAL VARIABLES                          ! !--------------------------------------------------------------------------! ! Declare the superconducting structure type ( structure ) :: stack type ( conductor ), target :: Ra , Rb ! Declare program control parameters real ( wp ), parameter :: threshold = 1e-2 real ( wp ), parameter :: tolerance = 1e-5 integer , parameter :: iterations = 100 ! Declare variables used by the program real ( wp ), dimension (:), allocatable :: voltage real ( wp ), dimension (:), allocatable :: current integer :: n !--------------------------------------------------------------------------! !                           INITIALIZATION PROCEDURE                       ! !--------------------------------------------------------------------------! ! Construct the central material stack stack = structure () ! Ensure that the voltage has an effect call stack % cmap ( 'nonequilibrium' , 'T' ) ! Construct the surrounding conductors call Ra % construct () call Rb % construct () ! Disable the conductors from updates call Ra % conf ( 'order' , '0' ) call Rb % conf ( 'order' , '0' ) ! Thermalize the surrounding conductors Ra % temperature = stack % a % temperature Rb % temperature = stack % b % temperature ! Reinitialize the conductor states call Ra % initialize () call Rb % initialize () ! Connect the conductors to the stack stack % a % material_a => Ra stack % b % material_b => Rb ! Initialize the voltage and current allocate ( voltage ( iterations ), current ( iterations )) call linspace ( voltage , 1e-6_wp , 2.00_wp ) ! Start with a bootstrap procedure (not self-consistent) call stack % converge ( threshold = threshold , bootstrap = . true .) !--------------------------------------------------------------------------! !                           LINEAR SEARCH PROCEDURE                        ! !--------------------------------------------------------------------------! ! Calculate the charge current as a function of voltage difference current = 0 do n = 1 , size ( voltage ) ! Update the voltage Ra % voltage = + voltage ( n ) Rb % voltage = - voltage ( n ) ! Reset the states call Ra % initialize () call Rb % initialize () ! Update the state call stack % converge ( threshold = tolerance , prehook = prehook , posthook = posthook ) ! Save the charge current to array current ( n ) = stack % a % supercurrent ( 0 , 1 ) + stack % a % lossycurrent ( 0 , 1 ) ! Write out the results call finalize () end do !--------------------------------------------------------------------------! !                                 SUBROUTINES                              ! !--------------------------------------------------------------------------! contains subroutine prehook call status_body ( 'Voltage difference' , voltage ( n )) end subroutine subroutine posthook character ( len = 5 ) :: filename write ( filename , '(f5.3)' ) voltage ( n ) end subroutine subroutine finalize call dump ( 'current.dat' , [ voltage , current ], [ 'Voltage           ' , 'Charge current    ' ]) end subroutine end program","tags":"","loc":"sourcefile/sweep_voltage.f90.html"},{"title":"sweep_phase.f90 – GENEUS","text":"Contents Programs phase_p Source Code sweep_phase.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Programs !> !> Calculates the current-phase relation of a superconducting structure. program phase_p use :: structure_m use :: stdio_m use :: math_m !--------------------------------------------------------------------------! !                                GLOBAL VARIABLES                          ! !--------------------------------------------------------------------------! ! Declare the superconducting structure type ( structure ) :: stack type ( superconductor ), target :: Ra , Rb ! Declare program control parameters real ( wp ), parameter :: threshold = 1e-2 real ( wp ), parameter :: tolerance = 1e-8 integer , parameter :: iterations = 51 ! Declare variables used by the program real ( wp ), dimension (:), allocatable :: phase real ( wp ), dimension (:), allocatable :: current real ( wp ) :: critical integer :: n , m !--------------------------------------------------------------------------! !                           INITIALIZATION PROCEDURE                       ! !--------------------------------------------------------------------------! ! Construct the central material stack stack = structure () ! Construct the surrounding superconductors call Ra % construct () call Rb % construct () ! DiRable the superconductors from updates call Ra % conf ( 'order' , '0' ) call Rb % conf ( 'order' , '0' ) ! Connect the superconductors to the stack stack % a % material_a => Ra stack % b % material_b => Rb ! Count the number of superconductors n = stack % superconductors () ! Depending on the number of enabled superconductors, we might get a 2πn ! periodicity instead of 2π periodicity, and need to account for this. m = ( n + 1 ) * ( iterations - 1 ) + 1 allocate ( phase ( m ), current ( m )) call linspace ( phase , 1e-6_wp , 2 * ( n + 1 ) - 1e-6_wp ) ! Start with a bootstrap procedure (not self-consistent) call stack % converge ( threshold = threshold , bootstrap = . true .) !--------------------------------------------------------------------------! !                           LINEAR SEARCH PROCEDURE                        ! !--------------------------------------------------------------------------! ! Calculate the charge current as a function of phase difference do n = 1 , size ( phase ) ! Update the phase Ra % correlation = exp ((( 0.0 , - 0.5 ) * pi ) * phase ( n )) Rb % correlation = exp ((( 0.0 , + 0.5 ) * pi ) * phase ( n )) ! Reset the states call Ra % initialize () call Rb % initialize () ! Update the state call stack % converge ( threshold = tolerance , prehook = prehook , posthook = posthook ) ! Save the charge current to array current ( n ) = stack % a % supercurrent ( 0 , 1 ) end do ! Calculate the critical current critical = maxval ( abs ( current )) ! Write out the final results call finalize () !--------------------------------------------------------------------------! !                                 SUBROUTINES                              ! !--------------------------------------------------------------------------! contains subroutine prehook call status_body ( 'Phase difference' , phase ( n )) end subroutine subroutine posthook character ( len = 5 ) :: filename write ( filename , '(f5.3)' ) phase ( n ) end subroutine subroutine finalize call status_head ( 'CRITICAL CURRENT' ) call status_body ( 'Result' , critical ) call status_foot () call dump ( 'current.dat' , [ phase , current ], [ 'Phase             ' , 'Charge current    ' ]) call dump ( 'critical.dat' , critical ) end subroutine end program","tags":"","loc":"sourcefile/sweep_phase.f90.html"},{"title":"critical.f90 – GENEUS","text":"Contents Programs critical_p Source Code critical.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Programs !> !> Calculates the critical temperature of a superconducting structure. program critical_p use :: structure_m use :: stdio_m use :: math_m !--------------------------------------------------------------------------! !                                GLOBAL VARIABLES                          ! !--------------------------------------------------------------------------! ! Declare the superconducting structure type ( structure ) :: stack ! Declare program control parameters integer , parameter :: bisections = 20 integer , parameter :: bootstraps = 10 integer , parameter :: iterations = 10 real ( wp ), parameter :: threshold = 1e-08_wp real ( wp ), parameter :: initgap = 1e-02_wp ! Declare variables used by the program real ( wp ) :: minimum = 0.00_wp real ( wp ) :: maximum = 1.00_wp real ( wp ) :: critical = 0.50_wp integer :: n = 0 !--------------------------------------------------------------------------! !                           INITIALIZATION PROCEDURE                       ! !--------------------------------------------------------------------------! ! Construct the material stack stack = structure () ! Disable convergence acceleration call stack % cmap ( 'boost' , . false .) ! Initialize the stack to a barely superconducting state call stack % cmap ( 'gap' , initgap ) ! Reset the states of the propagators throughout the stack call stack % initialize () ! Bootstrap the material states while locking the gap call stack % converge ( threshold = threshold , iterations = bootstraps , bootstrap = . true .) ! Save the current state of the materials call stack % save () !--------------------------------------------------------------------------! !                           BINARY SEARCH PROCEDURE                        ! !--------------------------------------------------------------------------! do n = 1 , bisections ! Set the temperature of the materials call stack % cmap ( 'temperature' , critical ) ! Reinitialize at the new temperature call stack % initialize () ! Load the saved material states call stack % load () ! Update the material states call stack % converge ( iterations = iterations , prehook = prehook ) ! Update the critical temperature estimate if ( stack % gap () . ge . initgap ) then minimum = critical else maximum = critical end if critical = ( minimum + maximum ) / 2 end do ! Write out the final results call finalize () !--------------------------------------------------------------------------! !                                 SUBROUTINES                              ! !--------------------------------------------------------------------------! contains subroutine prehook call status_body ( 'Temperature' , critical ) call status_body ( 'Bisection' , n ) end subroutine subroutine finalize call status_head ( 'CRITICAL TEMPERATURE' ) call status_body ( 'Result' , critical ) call status_foot () call dump ( 'critical.dat' , critical ) end subroutine end program","tags":"","loc":"sourcefile/critical.f90.html"},{"title":"flow.f90 – GENEUS","text":"Contents Programs flow_p Source Code flow.f90 Source Code !> Author:   Jabir Ali Ouassou !> Category: Programs !> !> Calculates the phase diagram of a superconducting structure. program flow_p use :: structure_m use :: stdio_m use :: math_m !--------------------------------------------------------------------------! !                                GLOBAL VARIABLES                          ! !--------------------------------------------------------------------------! ! Declare the superconducting structure type ( structure ) :: stack ! Declare program control parameters integer , parameter :: bootstraps = 10 integer , parameter :: iterations = 10 real ( wp ), parameter :: threshold = 1e-8_wp ! Declare variables used by the program real ( wp ) :: flow real ( wp ) :: init !--------------------------------------------------------------------------! !                           INITIALIZATION PROCEDURE                       ! !--------------------------------------------------------------------------! ! Construct the material stack stack = structure () ! Disable convergence acceleration call stack % cmap ( 'boost' , . false .) ! Find out what gap the user has initialized the system to init = stack % gap () flow = 1.0 ! Reset the states of the propagators throughout the stack call stack % initialize () ! Bootstrap the material states while locking the gap call stack % converge ( threshold = threshold , iterations = bootstraps , bootstrap = . true .) !--------------------------------------------------------------------------! !                          PHASE DIAGRAM EVALUATION                        ! !--------------------------------------------------------------------------! ! Update the material states call stack % converge ( iterations = iterations , prehook = prehook ) ! Calculate the gap changes flow = stack % gap () / init ! Write out the final results call finalize () !--------------------------------------------------------------------------! !                                 SUBROUTINES                              ! !--------------------------------------------------------------------------! contains subroutine prehook flow = stack % gap () / init call status_body ( 'Gap flow' , flow ) end subroutine subroutine finalize call status_head ( 'PHASE DIAGRAM' ) call status_body ( 'Gap flow' , flow ) call status_foot () call dump ( 'flow.dat' , flow ) end subroutine end program","tags":"","loc":"sourcefile/flow.f90.html"},{"title":"nambu – GENEUS ","text":"type, public :: nambu Contents Type-Bound Procedures nambu assignment(=) operator(+) operator(-) operator(*) operator(/) operator(**) Type-Bound Procedures generic, public :: nambu => cons_rscalar, cons_cscalar, cons_cmatrix, cons_nambu private pure function nambu_cons_rscalar(other) result(this) Constructs a nambu object from a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_cons_cscalar(other) result(this) Constructs a nambu object from a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_cons_cmatrix(other) result(this) Constructs a nambu object from a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (4,4) Return Value type( nambu ) private pure function nambu_cons_nambu(other) result(this) Constructs a nambu object from an existing one. Arguments Type Intent Optional Attributes Name type( nambu ), intent(in) :: other Return Value type( nambu ) generic, public :: assignment(=) => assr_rscalar, assr_cscalar, assr_cmatrix, assl_cmatrix private pure subroutine nambu_assr_rscalar(this, other) Imports data to a nambu object from a real scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(inout) :: this real(kind=wp), intent(in) :: other private pure subroutine nambu_assr_cscalar(this, other) Imports data to a nambu object from a complex scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(inout) :: this complex(kind=wp), intent(in) :: other private pure subroutine nambu_assr_cmatrix(this, other) Imports data to a nambu object from a complex matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(inout) :: this complex(kind=wp), intent(in) :: other (4,4) private pure subroutine nambu_assl_cmatrix(other, this) Exports data from a nambu object to a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(out) :: other (4,4) class( nambu ), intent(in) :: this generic, public :: operator(+) => addl_rscalar, addr_rscalar, addl_cscalar, addr_cscalar, addl_cmatrix, addr_cmatrix, add_nambu private pure function nambu_addl_rscalar(other, this) result(r) Defines left addition of a nambu matrix and a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_addr_rscalar(this, other) result(r) Defines right addition of a nambu matrix and a real scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_addl_cscalar(other, this) result(r) Defines left addition of a nambu matrix and a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_addr_cscalar(this, other) result(r) Defines right addition of a nambu matrix and a complex scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_addl_cmatrix(other, this) result(r) Defines left addition of a nambu matrix and a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (4,4) class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_addr_cmatrix(this, other) result(r) Defines right addition of a nambu matrix and a complex matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other (4,4) Return Value type( nambu ) private elemental function nambu_add_nambu(this, other) result(r) Defines addition of two nambu matrices. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this class( nambu ), intent(in) :: other Return Value type( nambu ) generic, public :: operator(-) => subl_rscalar, subr_rscalar, subl_cscalar, subr_cscalar, subl_cmatrix, subr_cmatrix, sub_nambu private pure function nambu_subl_rscalar(other, this) result(r) Defines left subtraction of a nambu matrix and a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_subr_rscalar(this, other) result(r) Defines right subtraction of a nambu matrix and a real scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_subl_cscalar(other, this) result(r) Defines left subtraction of a nambu matrix and a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_subr_cscalar(this, other) result(r) Defines right subtraction of a nambu matrix and a complex scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_subl_cmatrix(other, this) result(r) Defines left subtraction of a nambu matrix and a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (4,4) class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_subr_cmatrix(this, other) result(r) Defines right subtraction of a nambu matrix and a complex matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other (4,4) Return Value type( nambu ) private elemental function nambu_sub_nambu(this, other) result(r) Defines subtraction of two nambu matrices. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this class( nambu ), intent(in) :: other Return Value type( nambu ) generic, public :: operator(*) => mull_rscalar, mulr_rscalar, mull_cscalar, mulr_cscalar, mull_cmatrix, mulr_cmatrix, mul_nambu private pure function nambu_mull_rscalar(other, this) result(r) Defines left multiplication of a nambu matrix by a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_mulr_rscalar(this, other) result(r) Defines right multiplication of a nambu matrix by a real scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_mull_cscalar(other, this) result(r) Defines left multiplication of a nambu matrix by a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other class( nambu ), intent(in) :: this Return Value type( nambu ) private function nambu_mulr_cscalar(this, other) result(r) Defines right multiplication of a nambu matrix by a complex scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_mull_cmatrix(other, this) result(r) Defines left multiplication of a nambu matrix by a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (4,4) class( nambu ), intent(in) :: this Return Value type( nambu ) private pure function nambu_mulr_cmatrix(this, other) result(r) Defines right multiplication of a nambu matrix by a complex matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other (4,4) Return Value type( nambu ) private elemental function nambu_mul_nambu(this, other) result(r) Defines multiplication of two nambu matrices. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this class( nambu ), intent(in) :: other Return Value type( nambu ) generic, public :: operator(/) => divr_rscalar, divr_cscalar private pure function nambu_divr_rscalar(this, other) result(r) Defines division of a nambu matrix by a real scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( nambu ) private pure function nambu_divr_cscalar(this, other) result(r) Defines division of a nambu matrix by a complex scalar. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( nambu ) generic, public :: operator(**) => expr_iscalar private pure function nambu_expr_iscalar(this, other) result(r) Exponentiates the nambu object, where the power is a positive integer. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this integer, intent(in) :: other Return Value type( nambu )","tags":"","loc":"type/nambu.html"},{"title":"spin – GENEUS ","text":"type, public :: spin Contents Type-Bound Procedures spin assignment(=) operator(+) operator(-) operator(*) operator(/) operator(**) Type-Bound Procedures generic, public :: spin => cons_rscalar, cons_cscalar, cons_cmatrix, cons_rvector, cons_spin private pure function spin_cons_rscalar(other) result(this) Constructs a spin object from a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_cons_cscalar(other) result(this) Constructs a spin object from a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_cons_cmatrix(other) result(this) Constructs a spin object from a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (2,2) Return Value type( spin ) private pure function spin_cons_rvector(other) result(this) Constructs a spin object from a real vector. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other (8) Return Value type( spin ) private pure function spin_cons_spin(other) result(this) Constructs a spin object from an existing one. Arguments Type Intent Optional Attributes Name type( spin ), intent(in) :: other Return Value type( spin ) generic, public :: assignment(=) => assr_rscalar, assr_cscalar, assr_cmatrix, assr_rvector, assl_cmatrix, assl_rvector private pure subroutine spin_assr_rscalar(this, other) Imports data to a spin object from a real scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(inout) :: this real(kind=wp), intent(in) :: other private pure subroutine spin_assr_cscalar(this, other) Imports data to a spin object from a complex scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(inout) :: this complex(kind=wp), intent(in) :: other private pure subroutine spin_assr_cmatrix(this, other) Imports data to a spin object from a complex matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(inout) :: this complex(kind=wp), intent(in) :: other (2,2) private pure subroutine spin_assr_rvector(this, other) Imports data to a spin object from a real vector. Arguments Type Intent Optional Attributes Name class( spin ), intent(inout) :: this real(kind=wp), intent(in) :: other (8) private pure subroutine spin_assl_cmatrix(other, this) Exports data from a spin object to a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(out) :: other (2,2) class( spin ), intent(in) :: this private pure subroutine spin_assl_rvector(other, this) Exports data from a spin object to a real vector. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out) :: other (8) class( spin ), intent(in) :: this generic, public :: operator(+) => addl_rscalar, addr_rscalar, addl_cscalar, addr_cscalar, addl_cmatrix, addr_cmatrix, add_spin private pure function spin_addl_rscalar(other, this) result(r) Defines left addition of a spin matrix and a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_addr_rscalar(this, other) result(r) Defines right addition of a spin matrix and a real scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_addl_cscalar(other, this) result(r) Defines left addition of a spin matrix and a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_addr_cscalar(this, other) result(r) Defines right addition of a spin matrix and a complex scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_addl_cmatrix(other, this) result(r) Defines left addition of a spin matrix and a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (2,2) class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_addr_cmatrix(this, other) result(r) Defines right addition of a spin matrix and a complex matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other (2,2) Return Value type( spin ) private elemental function spin_add_spin(this, other) result(r) Defines addition of two spin matrices. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this class( spin ), intent(in) :: other Return Value type( spin ) generic, public :: operator(-) => subl_rscalar, subr_rscalar, subl_cscalar, subr_cscalar, subl_cmatrix, subr_cmatrix, sub_spin private pure function spin_subl_rscalar(other, this) result(r) Defines left subtraction of a spin matrix and a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_subr_rscalar(this, other) result(r) Defines right subtraction of a spin matrix and a real scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_subl_cscalar(other, this) result(r) Defines left subtraction of a spin matrix and a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_subr_cscalar(this, other) result(r) Defines right subtraction of a spin matrix and a complex scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_subl_cmatrix(other, this) result(r) Defines left subtraction of a spin matrix and a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (2,2) class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_subr_cmatrix(this, other) result(r) Defines right subtraction of a spin matrix and a complex matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other (2,2) Return Value type( spin ) private elemental function spin_sub_spin(this, other) result(r) Defines subtraction of two spin matrices. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this class( spin ), intent(in) :: other Return Value type( spin ) generic, public :: operator(*) => mull_rscalar, mulr_rscalar, mull_cscalar, mulr_cscalar, mull_cmatrix, mulr_cmatrix, mul_spin private pure function spin_mull_rscalar(other, this) result(r) Defines left multiplication of a spin matrix by a real scalar. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: other class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_mulr_rscalar(this, other) result(r) Defines right multiplication of a spin matrix by a real scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_mull_cscalar(other, this) result(r) Defines left multiplication of a spin matrix by a complex scalar. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other class( spin ), intent(in) :: this Return Value type( spin ) private function spin_mulr_cscalar(this, other) result(r) Defines right multiplication of a spin matrix by a complex scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_mull_cmatrix(other, this) result(r) Defines left multiplication of a spin matrix by a complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: other (2,2) class( spin ), intent(in) :: this Return Value type( spin ) private pure function spin_mulr_cmatrix(this, other) result(r) Defines right multiplication of a spin matrix by a complex matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other (2,2) Return Value type( spin ) private elemental function spin_mul_spin(this, other) result(r) Defines multiplication of two spin matrices. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this class( spin ), intent(in) :: other Return Value type( spin ) generic, public :: operator(/) => divr_rscalar, divr_cscalar private pure function spin_divr_rscalar(this, other) result(r) Defines division of a spin matrix by a real scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this real(kind=wp), intent(in) :: other Return Value type( spin ) private pure function spin_divr_cscalar(this, other) result(r) Defines division of a spin matrix by a complex scalar. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this complex(kind=wp), intent(in) :: other Return Value type( spin ) generic, public :: operator(**) => expr_iscalar private pure function spin_expr_iscalar(this, other) result(r) Exponentiates the spin object, where the power is a positive integer. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this integer, intent(in) :: other Return Value type( spin )","tags":"","loc":"type/spin.html"},{"title":"propagator – GENEUS ","text":"type, public :: propagator Contents Constructor propagator Type-Bound Procedures retarded retarded_gradient retarded_laplacian advanced advanced_gradient advanced_laplacian keldysh keldysh_gradient distribution distribution_gradient dissipation dissipation_gradient condensate condensate_gradient selfenergy1 selfenergy2 supercurrent lossycurrent accumulation correlation density save load Constructor public interface propagator private pure function propagator_construct_vacuum() result(this) Construct a vacuum propagator, i.e. a propagator which satisfies G=0. Arguments None Return Value type( propagator ) Constructed object private pure function propagator_construct_riccati(g, gt, dg, dgt) result(this) Construct an arbitrary state by explicitly providing Riccati parameters.\nUnspecified Riccati parameters default to zero due to spin constructors.\nThe distribution function defaults to equilibrium at zero temperature. Arguments Type Intent Optional Attributes Name type( spin ), intent(in) :: g Riccati parameter γ type( spin ), intent(in) :: gt Riccati parameter γ~ type( spin ), intent(in), optional :: dg Riccati parameter ∇γ type( spin ), intent(in), optional :: dgt Riccati parameter ∇γ~ Return Value type( propagator ) Constructed object private pure function propagator_construct_bcs(energy, gap) result(this) Constructs the state of a a BCS superconductor at a given energy, which\nmay have an imaginary term representing inelastic scattering. The second\nargument 'gap' is used to provide the superconducting order parameter Δ.\nThe distribution function defaults to equilibrium at zero temperature. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: energy Quasiparticle energy complex(kind=wp), intent(in) :: gap Order parameter Return Value type( propagator ) Constructed object Type-Bound Procedures procedure, public :: retarded => propagator_retarded Retarded propagator Gᴿ private pure function propagator_retarded(this) result(GR) Calculates the 4×4 retarded propagator Gᴿ. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value type( nambu ) Retarded propagator procedure, public :: retarded_gradient => propagator_retarded_gradient Retarded propagator ∇Gᴿ private pure function propagator_retarded_gradient(this, gauge) result(dGR) Calculates the 4×4 retarded propagator gradient ∇Gᴿ. If an optional\ngauge field is specified, it returns the gauge-covariant gradient. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object type( nambu ), intent(in), optional :: gauge Optional gauge field Return Value type( nambu ) Retarded gradient procedure, public :: retarded_laplacian => propagator_retarded_laplacian Retarded propagator ∇²Gᴿ private pure function propagator_retarded_laplacian(this) result(d2GR) Calculates the 4×4 retarded propagator gradient ∇²Gᴿ. Read more… Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value type( nambu ) Retarded laplacian procedure, public :: advanced => propagator_advanced Advanced propagator Gᴬ private pure function propagator_advanced(this) result(GA) Calculates the 4×4 advanced propagator Gᴬ. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value type( nambu ) Advanced propagator procedure, public :: advanced_gradient => propagator_advanced_gradient Advanced propagator ∇Gᴬ private pure function propagator_advanced_gradient(this, gauge) result(dGA) Calculates the 4×4 advanced propagator gradient ∇Gᴬ. If an optional\ngauge field is specified, it returns the gauge-covariant gradient. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object type( nambu ), intent(in), optional :: gauge Optional gauge field Return Value type( nambu ) Advanced gradient procedure, public :: advanced_laplacian => propagator_advanced_laplacian Advanced propagator ∇²Gᴬ private pure function propagator_advanced_laplacian(this) result(d2GA) Calculates the 4×4 retarded propagator gradient ∇²Gᴬ. Read more… Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value type( nambu ) Advanced laplacian procedure, public :: keldysh => propagator_keldysh Keldysh propagator Gᴷ private pure function propagator_keldysh(this) result(GK) Calculates the 4×4 Keldysh propagator Gᴷ. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value type( nambu ) Propagator matrix procedure, public :: keldysh_gradient => propagator_keldysh_gradient Keldysh propagator ∇Gᴷ private pure function propagator_keldysh_gradient(this, gauge) result(dGK) Calculates the 4×4 Keldysh propagator gradient ∇Gᴷ. If an optional\ngauge field is specified, it returns the gauge-covariant gradient. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object type( nambu ), intent(in), optional :: gauge Optional gauge field Return Value type( nambu ) Propagator gradient procedure, public :: distribution => propagator_distribution Distribution matrix H private pure function propagator_distribution(this) result(H) Calculates the 4×4 distribution function matrix H. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value type( nambu ) Distribution matrix procedure, public :: distribution_gradient => propagator_distribution_gradient Distribution matrix ∇H private pure function propagator_distribution_gradient(this, gauge) result(dH) Calculates the 4×4 distribution function gradient ∇H. If an optional\ngauge field is specified, it returns the gauge-covariant gradient. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object type( nambu ), intent(in), optional :: gauge Optional gauge field Return Value type( nambu ) Distribution gradient procedure, public :: dissipation => propagator_dissipation Dissipation matrix M private pure function propagator_dissipation(this) result(M) Calculates the dissipation matrix M = ∂J/∂H', where J is the\ncurrent and H' is the gradient of the distribution function. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Return Value complex(kind=wp),\n  dimension(0:7, 0:7) procedure, public :: dissipation_gradient => propagator_dissipation_gradient Dissipation matrix ∇M private pure function propagator_dissipation_gradient(this) result(dM) Calculates the gradient of the dissipation matrix M'. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Return Value complex(kind=wp),\n  dimension(0:7, 0:7) procedure, public :: condensate => propagator_condensate Condensate matrix Q private pure function propagator_condensate(this) result(Q) Calculates the condensate matrix Q = ∂J/∂H, where J is the\ncurrent and H is the nonequilibrium distribution function. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Return Value complex(kind=wp),\n  dimension(0:7, 0:7) procedure, public :: condensate_gradient => propagator_condensate_gradient Condensate matrix ∇Q private pure function propagator_condensate_gradient(this) result(dQ) Calculates the gradient of the condensate matrix Q'. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Return Value complex(kind=wp),\n  dimension(0:7, 0:7) procedure, public :: selfenergy1 => propagator_selfenergy1 Self-energy matrix R₁ private pure function propagator_selfenergy1(this, S) result(R) Calculates 1st-order self-energy contribution to the kinetic equations. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this type( nambu ), intent(in) :: S Return Value complex(kind=wp),\n  dimension(0:7, 0:7) procedure, public :: selfenergy2 => propagator_selfenergy2 Self-energy matrix R₂ private pure function propagator_selfenergy2(this, S) result(R) Calculates 2nd-order self-energy contribution to the kinetic equations. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this type( nambu ), intent(in) :: S Return Value complex(kind=wp),\n  dimension(0:7, 0:7) procedure, public :: supercurrent => propagator_supercurrent Spectral super currents private pure function propagator_supercurrent(this, gauge) result(J) Calculates the spectral super currents in the junction. The result is an\n8-vector encoding respectively charge, spin, heat, spin-heat currents. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object type( nambu ), intent(in), optional :: gauge Optional gauge field Return Value real(kind=wp),\n  dimension(0:7) Spectral supercurrent procedure, public :: lossycurrent => propagator_lossycurrent Spectral lossy currents private pure function propagator_lossycurrent(this, gauge) result(J) Calculates the spectral lossy currents in the junction. The result\nis an 8-vector containing charge, spin, heat, and spin-heat currents. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object type( nambu ), intent(in), optional :: gauge Optional gauge field Return Value real(kind=wp),\n  dimension(0:7) Spectral lossy current procedure, public :: accumulation => propagator_accumulation Spectral accumulations private pure function propagator_accumulation(this) result(Q) Calculates the spectral accumulations. The result is an 8-vector\ncontaining the charge, spin, heat, and spin-heat accumulations. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value real(kind=wp),\n  dimension(0:7) Spectral accumulation procedure, public :: correlation => propagator_correlation Spectral correlations private pure function propagator_correlation(this) result(r) Calculates the spectral pair-correlation function. This is useful to\nself-consistently calculate the superconducting gap in a superconductor. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Propagator object Return Value complex(kind=wp) Spectral correlation procedure, public :: density => propagator_density Local density of states private pure function propagator_density(this) result(D) Calculates the spin-resolved local density of states. Arguments Type Intent Optional Attributes Name class( propagator ), intent(in) :: this Return Value real(kind=wp),\n  dimension(0:7) procedure, public :: save => propagator_save Export Riccati parameters private elemental subroutine propagator_save(this, other) Defines a function for exporting Riccati parameters. Arguments Type Intent Optional Attributes Name class( propagator ), intent(inout) :: this class( propagator ), intent(inout) :: other procedure, public :: load => propagator_load Import Riccati parameters private elemental subroutine propagator_load(this, other) Defines a function for importing Riccati parameters. Arguments Type Intent Optional Attributes Name class( propagator ), intent(inout) :: this class( propagator ), intent(inout) :: other","tags":"","loc":"type/propagator.html"},{"title":"spinactive – GENEUS ","text":"type, public :: spinactive Contents Type-Bound Procedures diffusion_current kinetic_current update_prehook Type-Bound Procedures procedure, public :: diffusion_current => spinactive_diffusion_current private pure function spinactive_diffusion_current(this, G0, G1) result(I) Calculate the matrix current at an interface with spin-active properties. The equations\nimplemented here should be valid for an arbitrary interface polarization, and up to 2nd\norder in the transmission probabilities and spin-mixing angles of the interface. Arguments Type Intent Optional Attributes Name class( spinactive ), intent(in) :: this type( nambu ), intent(in) :: G0 Propagator matrices type( nambu ), intent(in) :: G1 Propagator matrices Return Value type( nambu ) Matrix current procedure, public :: kinetic_current => spinactive_kinetic_current private pure subroutine spinactive_kinetic_current(this, G0, G1, C0, C1) Calculate the kinetic boundary coefficients at an interface with spin-active properties.\nThese can be used to calculate the generalized current according to J = C₀H₀ - C₁H₁. Arguments Type Intent Optional Attributes Name class( spinactive ), intent(in) :: this type( propagator ), intent(in) :: G0 Propagator (this  side) type( propagator ), intent(in) :: G1 Propagator (other side) complex(kind=wp), intent(out), dimension(0:7,0:7) :: C0 Boundary coefficient (this  side) complex(kind=wp), intent(out), dimension(0:7,0:7) :: C1 Boundary coefficient (other side) procedure, public :: update_prehook => spinactive_update_prehook private subroutine spinactive_update_prehook(this) Updates the internal variables associated with spin-active interfaces. Arguments Type Intent Optional Attributes Name class( spinactive ), intent(inout) :: this","tags":"","loc":"type/spinactive.html"},{"title":"spinscattering – GENEUS ","text":"type, public :: spinscattering Contents Constructor spinscattering Type-Bound Procedures diffusion_equation kinetic_equation Constructor public interface spinscattering public function spinscattering_construct (parent) result(this) Constructs a spinscattering object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinscattering ) Type-Bound Procedures procedure, public :: diffusion_equation => spinscattering_diffusion_equation Diffusion equation private pure subroutine spinscattering_diffusion_equation(this, p) Calculate the spin-flip and spin-orbit scattering terms in the diffusion\nequation, and update the second derivatives of the Riccati parameters. Arguments Type Intent Optional Attributes Name class( spinscattering ), intent(in) :: this type( propagator ), intent(inout) :: p procedure, public :: kinetic_equation => spinscattering_kinetic_equation Kinetic equation private pure subroutine spinscattering_kinetic_equation(this, Gp, R) Calculate the self-energies in the kinetic equation. Arguments Type Intent Optional Attributes Name class( spinscattering ), intent(in) :: this type( propagator ), intent(in) :: Gp complex(kind=wp), intent(inout), dimension(0:7,0:7) :: R","tags":"","loc":"type/spinscattering.html"},{"title":"conductor – GENEUS ","text":"type, public, extends( material ) :: conductor Contents Type-Bound Procedures update update_diffusion update_kinetic save load construct initialize update_prehook update_posthook diffusion_equation diffusion_equation_a diffusion_equation_b kinetic_equation kinetic_equation_a kinetic_equation_b conf Type-Bound Procedures procedure, public :: update => material_update Calculate propagators private subroutine material_update(this, bootstrap) This subroutine updates the state of the material by solving the diffusion \nequations for the equilibrium propagators, the kinetic equations for the \nnonequilibrium propagators, and then calculating physical observables. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this Material that will be updated logical, intent(in), optional :: bootstrap Disable calculation of observables procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) interface private module subroutine diffusion_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) interface private module subroutine kinetic_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: save => material_save Saves the state of the material private subroutine material_save(this) Save a backup of the current material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: load => material_load Loads the state of the material public subroutine material_load (this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: construct => conductor_construct Constructs the object private subroutine conductor_construct(this) Constructs a conductor object initialized to a superconducting state. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: initialize => conductor_initialize Initializes propagators private subroutine conductor_initialize(this) Define the default initializer. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: update_prehook => conductor_update_prehook Code to execute before updates private subroutine conductor_update_prehook(this) Code to execute before running the update method of a class(conductor) object. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: update_posthook => conductor_update_posthook Code to execute after  updates private subroutine conductor_update_posthook(this) Code to execute after running the update method of a class(conductor) object.\nIn particular, this function calculates supercurrents, dissipative currents,\naccumulations, and density of states, and stores the results in the object. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: diffusion_equation => conductor_diffusion_equation Diffusion equation private pure subroutine conductor_diffusion_equation(this, p, e, z) Use the diffusion equation to calculate the second-derivatives \nof the Riccati parameters at an energy e and position z. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(inout) :: p complex(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: z procedure, public :: diffusion_equation_a => conductor_diffusion_equation_a Boundary condition (left) private pure subroutine conductor_diffusion_equation_a(this, p, a, r, rt) Calculate residuals from the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: p type( propagator ), intent(in) :: a type( spin ), intent(inout) :: r type( spin ), intent(inout) :: rt procedure, public :: diffusion_equation_b => conductor_diffusion_equation_b Boundary condition (right) private pure subroutine conductor_diffusion_equation_b(this, p, b, r, rt) Calculate residuals from the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: p type( propagator ), intent(in) :: b type( spin ), intent(inout) :: r type( spin ), intent(inout) :: rt procedure, public :: kinetic_equation => conductor_kinetic_equation Kinetic equation private pure subroutine conductor_kinetic_equation(this, Gp, R, z) Calculate the self-energies in the kinetic equation. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: Gp complex(kind=wp), intent(inout), dimension(0:7,0:7) :: R real(kind=wp), intent(in) :: z procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) private pure subroutine conductor_kinetic_equation_a(this, Gp, Ga, Cp, Ca) Calculate proportionality matrices for the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: Gp type( propagator ), intent(in) :: Ga complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Ca procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) private pure subroutine conductor_kinetic_equation_b(this, Gp, Gb, Cp, Cb) Calculate proportionality matrices for the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: Gp type( propagator ), intent(in) :: Gb complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cb procedure, public :: conf => conductor_conf Configures material parameters private subroutine conductor_conf(this, key, val) Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this character, intent(in) :: key character, intent(in) :: val","tags":"","loc":"type/conductor.html"},{"title":"halfmetal – GENEUS ","text":"type, public, extends( conductor ) :: halfmetal Contents Type-Bound Procedures update update_diffusion update_kinetic save load construct initialize kinetic_equation kinetic_equation_a kinetic_equation_b conf diffusion_equation diffusion_equation_a diffusion_equation_b update_prehook update_posthook update_density Type-Bound Procedures procedure, public :: update => material_update Calculate propagators private subroutine material_update(this, bootstrap) This subroutine updates the state of the material by solving the diffusion \nequations for the equilibrium propagators, the kinetic equations for the \nnonequilibrium propagators, and then calculating physical observables. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this Material that will be updated logical, intent(in), optional :: bootstrap Disable calculation of observables procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) interface private module subroutine diffusion_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) interface private module subroutine kinetic_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: save => material_save Saves the state of the material private subroutine material_save(this) Save a backup of the current material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: load => material_load Loads the state of the material public subroutine material_load (this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: construct => conductor_construct Constructs the object private subroutine conductor_construct(this) Constructs a conductor object initialized to a superconducting state. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: initialize => conductor_initialize Initializes propagators private subroutine conductor_initialize(this) Define the default initializer. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: kinetic_equation => conductor_kinetic_equation Kinetic equation private pure subroutine conductor_kinetic_equation(this, Gp, R, z) Calculate the self-energies in the kinetic equation. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: Gp complex(kind=wp), intent(inout), dimension(0:7,0:7) :: R real(kind=wp), intent(in) :: z procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) private pure subroutine conductor_kinetic_equation_a(this, Gp, Ga, Cp, Ca) Calculate proportionality matrices for the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: Gp type( propagator ), intent(in) :: Ga complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Ca procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) private pure subroutine conductor_kinetic_equation_b(this, Gp, Gb, Cp, Cb) Calculate proportionality matrices for the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: Gp type( propagator ), intent(in) :: Gb complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cb procedure, public :: conf => halfmetal_conf Configures the material parameters private subroutine halfmetal_conf(this, key, val) Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(inout) :: this character, intent(in) :: key character, intent(in) :: val procedure, public :: diffusion_equation => halfmetal_diffusion_equation Defines the Usadel diffusion equation private pure subroutine halfmetal_diffusion_equation(this, p, e, z) Use the diffusion equation to calculate the second-derivatives\nof the Riccati parameters at an energy e and a position z. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(in) :: this type( propagator ), intent(inout) :: p complex(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: z procedure, public :: diffusion_equation_a => halfmetal_diffusion_equation_a Boundary condition at the left  interface private pure subroutine halfmetal_diffusion_equation_a(this, p, a, r, rt) Calculate residuals from the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(in) :: this type( propagator ), intent(in) :: p type( propagator ), intent(in) :: a type( spin ), intent(inout) :: r type( spin ), intent(inout) :: rt procedure, public :: diffusion_equation_b => halfmetal_diffusion_equation_b Boundary condition at the right interface private pure subroutine halfmetal_diffusion_equation_b(this, p, b, r, rt) Calculate residuals from the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(in) :: this type( propagator ), intent(in) :: p type( propagator ), intent(in) :: b type( spin ), intent(inout) :: r type( spin ), intent(inout) :: rt procedure, public :: update_prehook => halfmetal_update_prehook Code to execute before calculating the propagators private subroutine halfmetal_update_prehook(this) Code to execute before running the update method of a class(halfmetal) object. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(inout) :: this procedure, public :: update_posthook => halfmetal_update_posthook Code to execute after  calculating the propagators private subroutine halfmetal_update_posthook(this) Code to execute after running the update method of a class(halfmetal) object. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(inout) :: this procedure, public :: update_density => halfmetal_update_density Calculates the density of states private pure subroutine halfmetal_update_density(this) Calculate the density of states in the halfmetal. Arguments Type Intent Optional Attributes Name class( halfmetal ), intent(inout) :: this","tags":"","loc":"type/halfmetal.html"},{"title":"spinorbit – GENEUS ","text":"type, public :: spinorbit Contents Constructor spinorbit Type-Bound Procedures diffusion_equation diffusion_equation_a diffusion_equation_b update_prehook Constructor public interface spinorbit public function spinorbit_construct (parent) result(this) Constructs a spinorbit object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinorbit ) Type-Bound Procedures procedure, public :: diffusion_equation => spinorbit_diffusion_equation Diffusion equation private pure subroutine spinorbit_diffusion_equation(this, p) Calculate the spin-orbit coupling terms in the diffusion equation,\nand update the second derivatives of the Riccati parameters. Arguments Type Intent Optional Attributes Name class( spinorbit ), intent(in) :: this type( propagator ), intent(inout) :: p procedure, public :: diffusion_equation_a => spinorbit_diffusion_equation_a Boundary condition (left) private pure subroutine spinorbit_diffusion_equation_a(this, p, r, rt) Calculate the spin-orbit coupling terms in the left boundary condition, and update the residuals. Arguments Type Intent Optional Attributes Name class( spinorbit ), intent(in), target :: this type( propagator ), intent(in) :: p type( spin ), intent(inout) :: r type( spin ), intent(inout) :: rt procedure, public :: diffusion_equation_b => spinorbit_diffusion_equation_b Boundary condition (right) private pure subroutine spinorbit_diffusion_equation_b(this, p, r, rt) Calculate the spin-orbit coupling terms in the right boundary condition, and update the residuals. Arguments Type Intent Optional Attributes Name class( spinorbit ), intent(in), target :: this type( propagator ), intent(in) :: p type( spin ), intent(inout) :: r type( spin ), intent(inout) :: rt procedure, public :: update_prehook => spinorbit_update_prehook Code to execute before updates private subroutine spinorbit_update_prehook(this) Updates the internal variables associated with spin-orbit coupling. Arguments Type Intent Optional Attributes Name class( spinorbit ), intent(inout) :: this","tags":"","loc":"type/spinorbit.html"},{"title":"structure – GENEUS ","text":"type, public :: structure Contents Constructor structure Type-Bound Procedures push conf cmap fmap initialize save load update update_prehook update_posthook converge write difference materials selfconsistency superconductors chargeviolation gap Constructor public interface structure private function structure_construct() result(this) Constructs a multilayer stack from a configuration file. Arguments None Return Value type( structure ) Type-Bound Procedures procedure, public :: push => structure_push Construct a single layer private subroutine structure_push(this, string) Constructs a new class(material) object at the bottom of the multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), intent(inout) :: this character, intent(in) :: string procedure, public :: conf => structure_conf Configure a single layer private subroutine structure_conf(this, key, val) Configures the last material pushed to the multilayer stack. Read more… Arguments Type Intent Optional Attributes Name class( structure ), intent(inout) :: this character, intent(in) :: key character, intent(in) :: val procedure, public :: cmap => structure_cmap Configure  all layers private subroutine structure_cmap(this, key, val) Maps a configuration option onto each element of the multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), intent(inout) :: this character, intent(in) :: key class(*), intent(in) :: val procedure, public :: fmap => structure_fmap Manipulate all layers private subroutine structure_fmap(this, routine, every) Maps a subroutine onto each element of the multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this procedure(mappable) :: routine logical, optional :: every procedure, public :: initialize => structure_initialize Reset the physical state private subroutine structure_initialize(this) Initializes the state of the entire multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this procedure, public :: save => structure_save Save the physical state private subroutine structure_save(this) Saves the state of the entire multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this procedure, public :: load => structure_load Load the physical state private subroutine structure_load(this) Loads the saved state of the multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this procedure, public :: update => structure_update Update the physical state private subroutine structure_update(this, bootstrap) Updates the state of the entire multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this logical, optional :: bootstrap procedure, public :: update_prehook => structure_update_prehook Execute all update prehooks private subroutine structure_update_prehook(this) Silently execute all update prehooks. Arguments Type Intent Optional Attributes Name class( structure ) :: this procedure, public :: update_posthook => structure_update_posthook Execute all update posthooks private subroutine structure_update_posthook(this) Silently execute all update posthooks. Arguments Type Intent Optional Attributes Name class( structure ) :: this procedure, public :: converge => structure_converge Update until convergence private subroutine structure_converge(this, threshold, iterations, bootstrap, prehook, posthook) Performs a convergence procedure, where the state of every material in the stack\nis repeatedly updated until the residuals drop below some specified threshold \nand/or a certain number of iterations have been performed. If bootstrap is set\nto true, the selfconsistency equations will only be solved once at the end, but\nnot inbetween the individual iterations. If a prehook and/or posthook is given,\nthose subroutines will be executed before/after each iteration of the update. Arguments Type Intent Optional Attributes Name class( structure ), target :: this real(kind=wp), optional :: threshold integer, optional :: iterations logical, optional :: bootstrap procedure(hook), optional :: prehook procedure(hook), optional :: posthook procedure, public :: write => structure_write Write out observables private subroutine structure_write(this) Writes physical observables to output files. Arguments Type Intent Optional Attributes Name class( structure ), target :: this procedure, public :: difference => structure_difference Check how much the physical state changes private function structure_difference(this) result(difference) Checks how much the multilayer stack has changed recently. Arguments Type Intent Optional Attributes Name class( structure ), target :: this Return Value real(kind=wp) procedure, public :: materials => structure_materials Check the number of enabled materials private function structure_materials(this) result(num) Checks the number of enabled materials in the multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this Return Value integer procedure, public :: selfconsistency => structure_selfconsistency Whether selfconsistency iteration is required private function structure_selfconsistency(this) result(res) Checks whether selfconsistency iteration is required. Arguments Type Intent Optional Attributes Name class( structure ), target :: this Return Value logical procedure, public :: superconductors => structure_superconductors Check the number of enables superconductors private function structure_superconductors(this) result(num) Checks the number of selfconsistent superconductors in the multilayer stack. Arguments Type Intent Optional Attributes Name class( structure ), target :: this Return Value integer procedure, public :: chargeviolation => structure_chargeviolation Check the violation of charge conservation private function structure_chargeviolation(this) result(difference) Checks how much the charge current varies with position. Since charge current\nis supposed to be conserved through the junction, this provides a measure of\ncharge conservation violation, i.e. if the solution is physically realistic. Arguments Type Intent Optional Attributes Name class( structure ), target :: this Return Value real(kind=wp) procedure, public :: gap => structure_gap Check the minimum superconducting gap private function structure_gap(this) result(gap) Obtains the mean gap in the enabled superconductor. If there are multiple such\nsuperconductors in the junction, then it returns the minimum of the mean gaps. Arguments Type Intent Optional Attributes Name class( structure ), target :: this Return Value real(kind=wp)","tags":"","loc":"type/structure.html"},{"title":"superconductor – GENEUS ","text":"type, public, extends( ferromagnet ) :: superconductor Contents Type-Bound Procedures update update_diffusion update_kinetic save load diffusion_equation_a diffusion_equation_b kinetic_equation_a kinetic_equation_b construct initialize diffusion_equation kinetic_equation update_gap update_boost update_prehook update_posthook gap conf Type-Bound Procedures procedure, public :: update => material_update Calculate propagators private subroutine material_update(this, bootstrap) This subroutine updates the state of the material by solving the diffusion \nequations for the equilibrium propagators, the kinetic equations for the \nnonequilibrium propagators, and then calculating physical observables. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this Material that will be updated logical, intent(in), optional :: bootstrap Disable calculation of observables procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) interface private module subroutine diffusion_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) interface private module subroutine kinetic_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: save => material_save Saves the state of the material private subroutine material_save(this) Save a backup of the current material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: load => material_load Loads the state of the material public subroutine material_load (this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: diffusion_equation_a => conductor_diffusion_equation_a Boundary condition (left) private pure subroutine conductor_diffusion_equation_a(this, p, a, r, rt) Calculate residuals from the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: p type( propagator ), intent(in) :: a type( spin ), intent(inout) :: r type( spin ), intent(inout) :: rt procedure, public :: diffusion_equation_b => conductor_diffusion_equation_b Boundary condition (right) private pure subroutine conductor_diffusion_equation_b(this, p, b, r, rt) Calculate residuals from the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: p type( propagator ), intent(in) :: b type( spin ), intent(inout) :: r type( spin ), intent(inout) :: rt procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) private pure subroutine conductor_kinetic_equation_a(this, Gp, Ga, Cp, Ca) Calculate proportionality matrices for the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: Gp type( propagator ), intent(in) :: Ga complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Ca procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) private pure subroutine conductor_kinetic_equation_b(this, Gp, Gb, Cp, Cb) Calculate proportionality matrices for the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: Gp type( propagator ), intent(in) :: Gb complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cb procedure, public :: construct => superconductor_construct Construct  propagators private subroutine superconductor_construct(this) Constructs a superconducting material that is initialized to a superconducting state. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this procedure, public :: initialize => superconductor_initialize Initialize propagators private subroutine superconductor_initialize(this) Redefine the default initializer. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this procedure, public :: diffusion_equation => superconductor_diffusion_equation Diffusion equation private pure subroutine superconductor_diffusion_equation(this, p, e, z) Use the diffusion equation to calculate the second derivatives of the Riccati parameters at point z. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(in) :: this type( propagator ), intent(inout) :: p complex(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: z procedure, public :: kinetic_equation => superconductor_kinetic_equation Kinetic equation private pure subroutine superconductor_kinetic_equation(this, Gp, R, z) Calculate the self-energies in the kinetic equation. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(in) :: this type( propagator ), intent(in) :: Gp complex(kind=wp), intent(inout), dimension(0:7,0:7) :: R real(kind=wp), intent(in) :: z procedure, public :: update_gap => superconductor_update_gap Calculate the superconducting order parameter private subroutine superconductor_update_gap(this) Interpolate the superconducting correlations Δ(z) to a higher resolution,\nto make the calculations more stable near strong ferromagnetic materials. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this Superconductor object procedure, public :: update_boost => superconductor_update_boost Boost the convergence of the order parameter (Steffensen's method) private subroutine superconductor_update_boost(this) Boost the convergence of the order parameter using Steffensen's method. Read more… Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this procedure, public :: update_prehook => superconductor_update_prehook Update the internal variables before calculating the propagators private subroutine superconductor_update_prehook(this) Code to execute before running the update method of a class(superconductor) object. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this procedure, public :: update_posthook => superconductor_update_posthook Update the superconducting order parameter from  the propagators private subroutine superconductor_update_posthook(this) Updates the superconducting order parameter based on the propagators of the system. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this procedure, public :: gap => superconductor_gap Return the superconducting order parameter at a given position private pure function superconductor_gap(this, location) result(gap) Returns the superconducting order parameter at the given location. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(in) :: this real(kind=wp), intent(in) :: location Return Value complex(kind=wp) procedure, public :: conf => superconductor_conf Configure material parameters private subroutine superconductor_conf(this, key, val) Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( superconductor ), intent(inout) :: this character, intent(in) :: key character, intent(in) :: val","tags":"","loc":"type/superconductor.html"},{"title":"ferromagnet – GENEUS ","text":"type, public, extends( conductor ) :: ferromagnet Contents Type-Bound Procedures update update_diffusion update_kinetic save load construct initialize update_posthook diffusion_equation_a diffusion_equation_b kinetic_equation_a kinetic_equation_b update_prehook diffusion_equation kinetic_equation conf Type-Bound Procedures procedure, public :: update => material_update Calculate propagators private subroutine material_update(this, bootstrap) This subroutine updates the state of the material by solving the diffusion \nequations for the equilibrium propagators, the kinetic equations for the \nnonequilibrium propagators, and then calculating physical observables. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this Material that will be updated logical, intent(in), optional :: bootstrap Disable calculation of observables procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) interface private module subroutine diffusion_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) interface private module subroutine kinetic_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: save => material_save Saves the state of the material private subroutine material_save(this) Save a backup of the current material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: load => material_load Loads the state of the material public subroutine material_load (this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: construct => conductor_construct Constructs the object private subroutine conductor_construct(this) Constructs a conductor object initialized to a superconducting state. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: initialize => conductor_initialize Initializes propagators private subroutine conductor_initialize(this) Define the default initializer. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: update_posthook => conductor_update_posthook Code to execute after  updates private subroutine conductor_update_posthook(this) Code to execute after running the update method of a class(conductor) object.\nIn particular, this function calculates supercurrents, dissipative currents,\naccumulations, and density of states, and stores the results in the object. Arguments Type Intent Optional Attributes Name class( conductor ), intent(inout) :: this procedure, public :: diffusion_equation_a => conductor_diffusion_equation_a Boundary condition (left) private pure subroutine conductor_diffusion_equation_a(this, p, a, r, rt) Calculate residuals from the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: p type( propagator ), intent(in) :: a type( spin ), intent(inout) :: r type( spin ), intent(inout) :: rt procedure, public :: diffusion_equation_b => conductor_diffusion_equation_b Boundary condition (right) private pure subroutine conductor_diffusion_equation_b(this, p, b, r, rt) Calculate residuals from the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: p type( propagator ), intent(in) :: b type( spin ), intent(inout) :: r type( spin ), intent(inout) :: rt procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) private pure subroutine conductor_kinetic_equation_a(this, Gp, Ga, Cp, Ca) Calculate proportionality matrices for the boundary conditions at the left interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: Gp type( propagator ), intent(in) :: Ga complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Ca procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) private pure subroutine conductor_kinetic_equation_b(this, Gp, Gb, Cp, Cb) Calculate proportionality matrices for the boundary conditions at the right interface. Arguments Type Intent Optional Attributes Name class( conductor ), intent(in) :: this type( propagator ), intent(in) :: Gp type( propagator ), intent(in) :: Gb complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cb procedure, public :: update_prehook => ferromagnet_update_prehook Code to execute before calculating the propagators private subroutine ferromagnet_update_prehook(this) Updates the exchange field terms in the diffusion equation. Arguments Type Intent Optional Attributes Name class( ferromagnet ), intent(inout) :: this procedure, public :: diffusion_equation => ferromagnet_diffusion_equation Diffusion equation private pure subroutine ferromagnet_diffusion_equation(this, p, e, z) Use the diffusion equation to calculate the second derivatives of the Riccati parameters at point z. Arguments Type Intent Optional Attributes Name class( ferromagnet ), intent(in) :: this type( propagator ), intent(inout) :: p complex(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: z procedure, public :: kinetic_equation => ferromagnet_kinetic_equation Kinetic equation private pure subroutine ferromagnet_kinetic_equation(this, Gp, R, z) Calculate the self-energies in the kinetic equation. Arguments Type Intent Optional Attributes Name class( ferromagnet ), intent(in) :: this type( propagator ), intent(in) :: Gp complex(kind=wp), intent(inout), dimension(0:7,0:7) :: R real(kind=wp), intent(in) :: z procedure, public :: conf => ferromagnet_conf Configures material parameters private subroutine ferromagnet_conf(this, key, val) Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( ferromagnet ), intent(inout) :: this character, intent(in) :: key character, intent(in) :: val","tags":"","loc":"type/ferromagnet.html"},{"title":"material – GENEUS ","text":"type, public, abstract :: material Contents Type-Bound Procedures construct initialize update_prehook update_posthook update update_diffusion update_kinetic diffusion_equation diffusion_equation_a diffusion_equation_b kinetic_equation kinetic_equation_a kinetic_equation_b conf save load Type-Bound Procedures procedure(manipulate), public, deferred :: construct Construct  object subroutine manipulate(this) Prototype This interface is used for the deferred procedures construct, update_prehook, and update_posthook. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure(initialize), public, deferred :: initialize Initialize object subroutine initialize(this) Prototype This interface is used for the deferred procedure initialize. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure(manipulate), public, deferred :: update_prehook Executed before update subroutine manipulate(this) Prototype This interface is used for the deferred procedures construct, update_prehook, and update_posthook. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure(manipulate), public, deferred :: update_posthook Executed after  update subroutine manipulate(this) Prototype This interface is used for the deferred procedures construct, update_prehook, and update_posthook. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: update => material_update Calculate propagators private subroutine material_update(this, bootstrap) This subroutine updates the state of the material by solving the diffusion \nequations for the equilibrium propagators, the kinetic equations for the \nnonequilibrium propagators, and then calculating physical observables. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this Material that will be updated logical, intent(in), optional :: bootstrap Disable calculation of observables procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) interface private module subroutine diffusion_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) interface private module subroutine kinetic_update(this) Arguments Type Intent Optional Attributes Name class( material ), intent(inout), target :: this procedure(diffusion_equation), public, deferred :: diffusion_equation Diffusion equation pure subroutine diffusion_equation(this, p, e, z) Prototype This interface is used for the deferred procedure diffusion_equation. Arguments Type Intent Optional Attributes Name class( material ), intent(in) :: this type( propagator ), intent(inout) :: p complex(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: z procedure(diffusion_equation_a), public, deferred :: diffusion_equation_a Boundary condition (left) pure subroutine diffusion_equation_a(this, p, a, r, rt) Prototype This interface is used for the deferred procedure diffusion_equation_a. Arguments Type Intent Optional Attributes Name class( material ), intent(in) :: this type( propagator ), intent(in) :: p type( propagator ), intent(in) :: a type( spin ), intent(inout) :: r type( spin ), intent(inout) :: rt procedure(diffusion_equation_b), public, deferred :: diffusion_equation_b Boundary condition (right) pure subroutine diffusion_equation_b(this, p, b, r, rt) Prototype This interface is used for the deferred procedure diffusion_equation_b. Arguments Type Intent Optional Attributes Name class( material ), intent(in) :: this type( propagator ), intent(in) :: p type( propagator ), intent(in) :: b type( spin ), intent(inout) :: r type( spin ), intent(inout) :: rt procedure(kinetic_equation), public, deferred :: kinetic_equation Kinetic equation pure subroutine kinetic_equation(this, Gp, R, z) Prototype This interface is used for the deferred procedure kinetic_equation. Arguments Type Intent Optional Attributes Name class( material ), intent(in) :: this type( propagator ), intent(in) :: Gp complex(kind=wp), intent(inout), dimension(0:7,0:7) :: R real(kind=wp), intent(in) :: z procedure(kinetic_equation_a), public, deferred :: kinetic_equation_a Boundary condition (left) pure subroutine kinetic_equation_a(this, Gp, Ga, Cp, Ca) Prototype This interface is used for the deferred procedure kinetic_equation_a. Arguments Type Intent Optional Attributes Name class( material ), intent(in) :: this type( propagator ), intent(in) :: Gp type( propagator ), intent(in) :: Ga complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Ca procedure(kinetic_equation_b), public, deferred :: kinetic_equation_b Boundary condition (right) pure subroutine kinetic_equation_b(this, Gp, Gb, Cp, Cb) Prototype This interface is used for the deferred procedure kinetic_equation_b. Arguments Type Intent Optional Attributes Name class( material ), intent(in) :: this type( propagator ), intent(in) :: Gp type( propagator ), intent(in) :: Gb complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cp complex(kind=wp), intent(out), dimension(0:7,0:7) :: Cb procedure, public :: conf => material_conf Configures material parameters public subroutine material_conf (this, key, val) Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this character, intent(in) :: key character, intent(in) :: val procedure, public :: save => material_save Saves the state of the material private subroutine material_save(this) Save a backup of the current material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this procedure, public :: load => material_load Loads the state of the material public subroutine material_load (this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this","tags":"","loc":"type/material.html"},{"title":"input – GENEUS","text":"public function input(file) result(unit) Open an input file for reading. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Return Value integer Contents None","tags":"","loc":"proc/input.html"},{"title":"output – GENEUS","text":"public function output(file) result(unit) Open an output file for writing. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Return Value integer Contents None","tags":"","loc":"proc/output.html"},{"title":"message – GENEUS","text":"public subroutine message(msg) Provides a way to report a status message. Arguments Type Intent Optional Attributes Name character, intent(in) :: msg Contents None","tags":"","loc":"proc/message.html"},{"title":"warning – GENEUS","text":"public subroutine warning(msg) Provides a way to report a warning message. Arguments Type Intent Optional Attributes Name character, intent(in) :: msg Contents None","tags":"","loc":"proc/warning.html"},{"title":"error – GENEUS","text":"public subroutine error(msg) Provides a way to report an error message and halt the program. Arguments Type Intent Optional Attributes Name character, intent(in) :: msg Contents None","tags":"","loc":"proc/error.html"},{"title":"status_head – GENEUS","text":"public subroutine status_head(title) Provides a way to write boxed status messages to standard out; in\nparticular, this routine writes out a boxed title with a timestamp. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Contents None","tags":"","loc":"proc/status_head.html"},{"title":"status_body – GENEUS","text":"public subroutine status_body(title, value) Provides a way to write boxed status messages to standard out; in\nparticular, this routine writes out the name and value of a variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title class(*), intent(in) :: value Contents None","tags":"","loc":"proc/status_body.html"},{"title":"status_foot – GENEUS","text":"public subroutine status_foot() Provides a way to write boxed status messages to standard out; in\nparticular, this routine writes out the bottom edge of such a box. Arguments None Contents None","tags":"","loc":"proc/status_foot.html"},{"title":"status_box – GENEUS","text":"public subroutine status_box(title) Provides a way to write boxed status messages to standard out. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Contents None","tags":"","loc":"proc/status_box.html"},{"title":"dump_arrays – GENEUS","text":"public subroutine dump_arrays(filename, arrays, header) Uses iso_fortran_env Dump numerical arrays to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in), dimension(:) :: arrays character(len=*), intent(in), dimension(:) :: header Contents None","tags":"","loc":"proc/dump_arrays.html"},{"title":"dump_scalar – GENEUS","text":"public subroutine dump_scalar(filename, scalar) Uses iso_fortran_env Dump a numerical result to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in) :: scalar Contents None","tags":"","loc":"proc/dump_scalar.html"},{"title":"dump – GENEUS","text":"public interface dump Contents Module Procedures dump_arrays dump_scalar Module Procedures public subroutine dump_arrays (filename, arrays, header) Dump numerical arrays to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in), dimension(:) :: arrays character(len=*), intent(in), dimension(:) :: header public subroutine dump_scalar (filename, scalar) Dump a numerical result to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in) :: scalar","tags":"","loc":"interface/dump.html"},{"title":"evaluate – GENEUS","text":"public interface evaluate Contents Module Procedures evaluate_scalar_value evaluate_scalar_field evaluate_vector_value evaluate_vector_field evaluate_logical_value evaluate_integer_value Module Procedures private subroutine evaluate_scalar_value(expression, value) Takes a scalar mathematical expression as input and returns the value. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: expression Mathematical expression real(kind=wp), intent(out) :: value Parsed result private subroutine evaluate_scalar_field(expression, domain, value) Evaluates a scalar-valued function of 'z' at the provided values for 'z'. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: expression Function of 'z' real(kind=wp), intent(in), dimension(:) :: domain Values of 'z' real(kind=wp), dimension(:), allocatable :: value Parsed result private subroutine evaluate_vector_value(expression, value) Takes a vector mathematical expression as input and returns the value. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: expression Mathematical expression real(kind=wp), intent(out), dimension(3) :: value Parsed result private subroutine evaluate_vector_field(expression, domain, value) Evaluates a vector-valued function of 'z' at the provided values for 'z'. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: expression Function of 'z' real(kind=wp), intent(in), dimension(:) :: domain Values of 'z' real(kind=wp), dimension(:, :), allocatable :: value Parsed result private subroutine evaluate_logical_value(expression, value) Takes a scalar logical expression as input and returns the value. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: expression Character 'T' or 'F' logical, intent(out) :: value Parsed expression private subroutine evaluate_integer_value(expression, value) Takes a scalar integer expression as input and returns the value. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: expression Numerical expression integer, intent(out) :: value Parsed result","tags":"","loc":"interface/evaluate.html"},{"title":"inverse – GENEUS","text":"public interface inverse Contents Module Procedures nambu_inv Module Procedures private pure function nambu_inv(this) result(r) Calculates the inverse of the nambu matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this Return Value type( nambu )","tags":"","loc":"interface/inverse~2.html"},{"title":"trace – GENEUS","text":"public interface trace Contents Module Procedures nambu_trace Module Procedures private elemental function nambu_trace(this) result(r) Calculates the trace of the nambu matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this Return Value complex(kind=wp)","tags":"","loc":"interface/trace~2.html"},{"title":"sum – GENEUS","text":"public interface sum Contents Module Procedures nambu_sum Module Procedures private pure function nambu_sum(this) result(r) Calculates the sum of an array of nambu matrices. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this (:) Return Value type( nambu )","tags":"","loc":"interface/sum.html"},{"title":"conjg – GENEUS","text":"public interface conjg Contents Module Procedures nambu_conjg Module Procedures private elemental function nambu_conjg(this) result(r) Calculates the complex conjugate of the nambu matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this Return Value type( nambu )","tags":"","loc":"interface/conjg.html"},{"title":"nambuv – GENEUS","text":"public interface nambuv Contents Module Procedures nambuv_scalar nambuv_vector Module Procedures private pure function nambuv_scalar(n) result(r) Constructs basis matrix number n in spin-nambu space. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value type( nambu ) private pure function nambuv_vector(v) result(r) Constructs a matrix representation of a vector. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:3) :: v Return Value type( nambu )","tags":"","loc":"interface/nambuv.html"},{"title":"re – GENEUS","text":"public elemental function re(z) result(x) Returns the real part of a complex number z=x+iy. Note :\n  This should be replaced by z%re when compilers support it. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: z Complex number Return Value real(kind=wp) Real part Contents None","tags":"","loc":"proc/re.html"},{"title":"im – GENEUS","text":"public elemental function im(z) result(y) Returns the imaginary part of a complex number z=x+iy. Note :\n  This should be replaced by z%im when compilers support it. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: z Complex number Return Value real(kind=wp) Imaginary part Contents None","tags":"","loc":"proc/im.html"},{"title":"cx – GENEUS","text":"public elemental function cx(x, y) result(z) Returns the complex number z=x+iy. Note :\n  This should be rewritten via z%re, z%im when compilers support it. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Real part real(kind=wp), intent(in), optional :: y Imaginary part Return Value complex(kind=wp) Complex number Contents None","tags":"","loc":"proc/cx.html"},{"title":"arg – GENEUS","text":"public elemental function arg(z) result(t) Returns the complex argument θ of a complex number z=r·exp(iθ). Note :\n  This should be rewritten via z%re, z%im when compilers support it. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: z Complex number Return Value real(kind=wp) Complex argument Contents None","tags":"","loc":"proc/arg.html"},{"title":"unitvector – GENEUS","text":"public pure function unitvector(v) result(r) If the argument has a finite norm, then it will be rescaled to a unit\nvector. If that norm is zero, then a zero vector is returned instead. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: v Input vector Return Value real(kind=wp),\n  dimension(3) Unit vector Contents None","tags":"","loc":"proc/unitvector.html"},{"title":"nonzero – GENEUS","text":"public pure function nonzero(v) result(r) Checks whether or not the argument has a finite norm. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: v Input vector Return Value logical Conclusion Contents None","tags":"","loc":"proc/nonzero.html"},{"title":"inverse – GENEUS","text":"public interface inverse Contents Module Procedures spin_inv Module Procedures private pure function spin_inv(this) result(r) Calculate the inverse of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value type( spin )","tags":"","loc":"interface/inverse~3.html"},{"title":"trace – GENEUS","text":"public interface trace Contents Module Procedures spin_trace Module Procedures private elemental function spin_trace(this) result(r) Calculate the trace of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value complex(kind=wp)","tags":"","loc":"interface/trace~3.html"},{"title":"sum – GENEUS","text":"public interface sum Contents Module Procedures spin_sum Module Procedures private pure function spin_sum(this) result(r) Calculate the sum of an array of spin matrices. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this (:) Return Value type( spin )","tags":"","loc":"interface/sum~2.html"},{"title":"conjg – GENEUS","text":"public interface conjg Contents Module Procedures spin_conjg Module Procedures private elemental function spin_conjg(this) result(r) Calculate the complex conjugate of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value type( spin )","tags":"","loc":"interface/conjg~2.html"},{"title":"norm2 – GENEUS","text":"public interface norm2 Contents Module Procedures spin_norm Module Procedures private elemental function spin_norm(this) result(r) Calculate the Frobenius norm of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value real(kind=wp)","tags":"","loc":"interface/norm2.html"},{"title":"trace – GENEUS","text":"public interface trace Public interface for functions that calculate a matrix trace. Contents Module Procedures matrix_trace Module Procedures public pure function matrix_trace (A) result(r) Calculates the trace of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Matrix [n×m] Return Value complex(kind=wp) r = Tr(A)","tags":"","loc":"interface/trace.html"},{"title":"inverse – GENEUS","text":"public interface inverse Public interface for functions that calculate a matrix inverse. Contents Module Procedures matrix_inverse_re matrix_inverse_cx Module Procedures public pure function matrix_inverse_re (A) result(R) Wrapper for matrix_inverse_cx that operates on real matrices. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:, :) :: A Matrix A [n×n] Return Value real(kind=wp),\n  dimension(size(A, 1), size(A, 1)) Matrix R=A¯¹ public pure function matrix_inverse_cx (A) result(R) Inverts a square matrix via Gauss-Jordan elimination with partial pivot\n(general) or a cofactoring algorithm (2x2 matrices). The implementation\nis based on Algorithm #2 in \"Efficient matrix inversion via Gauss-Jordan\nelimination and its parallelization\" by E.S. Quintana et al. (1998). Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Matrix A [n×n] Return Value complex(kind=wp),\n  dimension(size(A, 1), size(A, 1)) Matrix R=A¯¹","tags":"","loc":"interface/inverse.html"},{"title":"diag – GENEUS","text":"public interface diag Public interface for functions that deal with matrix diagonals. Contents Module Procedures matrix_diag vector_diag Module Procedures public pure function matrix_diag (A, B) result(R) Constructs a block-diagonal matrix R from two general matrices A and B. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Left  matrix [n×m] complex(kind=wp), intent(in), dimension(:, :) :: B Right matrix [p×q] Return Value complex(kind=wp),\n  dimension(size(A, 1) + size(B, 1), size(A, 2) + size(B, 2)) R = Diag(A,B) public pure function vector_diag (A) result(r) Extracts the diagonal of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Matrix [n×m] Return Value complex(kind=wp),\n  dimension(min(size(A, 1), size(A, 2))) r = Diag(A)","tags":"","loc":"interface/diag.html"},{"title":"mean – GENEUS","text":"public interface mean Public interface for routines that calculate the mean value. Contents Module Procedures mean_array_re mean_array_cx Module Procedures public pure function mean_array_re (x) result(r) Calculates the mean value of a real-valued array. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Real-valued array Return Value real(kind=wp) Mean value public pure function mean_array_cx (x) result(r) Calculates the mean value of a complex-valued array. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:) :: x Complex-valued array Return Value complex(kind=wp) Mean value","tags":"","loc":"interface/mean.html"},{"title":"differentiate – GENEUS","text":"public interface differentiate Public interface for various differentiation routines. Contents Module Procedures differentiate_array_re differentiate_array_cx Module Procedures public pure function differentiate_array_re (x, y) result(r) Calculates the numerical derivative of an array y wrt. x using central\ndifferences at the interior points and forward/backward differences at\nthe exterior points. All three approaches yield two-point approximations\nof the derivatives, thus the mesh spacing does not have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp),\n  dimension(size(x)) Derivative dy/dx public pure function differentiate_array_cx (x, y) result(r) Complex version of differentiate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp),\n  dimension(size(x)) Derivative dy/dx","tags":"","loc":"interface/differentiate.html"},{"title":"integrate – GENEUS","text":"public interface integrate Public interface for various integration routines. Contents Module Procedures integrate_array_re integrate_array_cx integrate_range_re integrate_range_cx Module Procedures public pure function integrate_array_re (x, y) result(r) Calculates the integral of an array y wrt. x using the trapezoid\nmethod. The mesh spacing does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp) Integral ∫y(x)·dx public pure function integrate_array_cx (x, y) result(r) Complex version of integrate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp) Integral ∫y(x)·dx public function integrate_range_re (x, y, a, b) result(r) Constructs a piecewise hermitian cubic interpolation of an array y(x)\nfrom discrete numerical data, and then integrates the interpolation in\nthe range (a, b). The mesh spacing does not have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value real(kind=wp) Integral ∫y(x)·dx public function integrate_range_cx (x, y, a, b) result(r) Complex version of integrate_range_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value complex(kind=wp) Integral ∫y(x)·dx","tags":"","loc":"interface/integrate.html"},{"title":"interpolate – GENEUS","text":"public interface interpolate Public interface for various interpolation routines. Contents Module Procedures interpolate_point_re interpolate_point_cx interpolate_array_re interpolate_array_cx interpolate_point_matrix_re Module Procedures public function interpolate_point_re (x, y, p) result(r) Wrapper for interpolate_array_re that accepts scalar arguments. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Single point p Return Value real(kind=wp) Interpolation y(p) public function interpolate_point_cx (x, y, p) result(r) Complex version of interpolate_point_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Single point p Return Value complex(kind=wp) Interpolation y(p) public function interpolate_array_re (x, y, p) result(r) Constructs a piecewise hermitian cubic interpolation of an array y(x)\nbased on discrete numerical data and evaluates the interpolation at p.\nNote that the mesh spacing does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Point array p Return Value real(kind=wp),\n  dimension(size(p)) Interpolation y(p) public function interpolate_array_cx (x, y, p) result(r) Complex version of interpolate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Point array p Return Value complex(kind=wp),\n  dimension(size(p)) Interpolation y(p) public pure function interpolate_point_matrix_re (x, y, p) result(r) Interpolates a matrix function using Catmull-Rom splines. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(:, :, :) :: y Function y(x) real(kind=wp), intent(in) :: p Single point p Return Value real(kind=wp),\n  dimension(size(y, 1), size(y, 2)) Interpolation y(p)","tags":"","loc":"interface/interpolate.html"},{"title":"linspace – GENEUS","text":"public interface linspace Public interface for routines that initialize arrays. Contents Module Procedures linspace_array_re Module Procedures public pure subroutine linspace_array_re (array, first, last) Populates an array with elements from first to last , inclusive. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: array Output array to populate real(kind=wp), intent(in) :: first Value of first element real(kind=wp), intent(in) :: last Value of last  element","tags":"","loc":"interface/linspace.html"},{"title":"mean_array_re – GENEUS","text":"public pure function mean_array_re(x) result(r) Calculates the mean value of a real-valued array. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Real-valued array Return Value real(kind=wp) Mean value Contents None","tags":"","loc":"proc/mean_array_re.html"},{"title":"mean_array_cx – GENEUS","text":"public pure function mean_array_cx(x) result(r) Calculates the mean value of a complex-valued array. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:) :: x Complex-valued array Return Value complex(kind=wp) Mean value Contents None","tags":"","loc":"proc/mean_array_cx.html"},{"title":"differentiate_array_re – GENEUS","text":"public pure function differentiate_array_re(x, y) result(r) Calculates the numerical derivative of an array y wrt. x using central\ndifferences at the interior points and forward/backward differences at\nthe exterior points. All three approaches yield two-point approximations\nof the derivatives, thus the mesh spacing does not have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp),\n  dimension(size(x)) Derivative dy/dx Contents None","tags":"","loc":"proc/differentiate_array_re.html"},{"title":"differentiate_array_cx – GENEUS","text":"public pure function differentiate_array_cx(x, y) result(r) Complex version of differentiate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp),\n  dimension(size(x)) Derivative dy/dx Contents None","tags":"","loc":"proc/differentiate_array_cx.html"},{"title":"integrate_array_re – GENEUS","text":"public pure function integrate_array_re(x, y) result(r) Calculates the integral of an array y wrt. x using the trapezoid\nmethod. The mesh spacing does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp) Integral ∫y(x)·dx Contents None","tags":"","loc":"proc/integrate_array_re.html"},{"title":"integrate_array_cx – GENEUS","text":"public pure function integrate_array_cx(x, y) result(r) Complex version of integrate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp) Integral ∫y(x)·dx Contents None","tags":"","loc":"proc/integrate_array_cx.html"},{"title":"integrate_range_re – GENEUS","text":"public function integrate_range_re(x, y, a, b) result(r) Constructs a piecewise hermitian cubic interpolation of an array y(x)\nfrom discrete numerical data, and then integrates the interpolation in\nthe range (a, b). The mesh spacing does not have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value real(kind=wp) Integral ∫y(x)·dx Contents None","tags":"","loc":"proc/integrate_range_re.html"},{"title":"integrate_range_cx – GENEUS","text":"public function integrate_range_cx(x, y, a, b) result(r) Complex version of integrate_range_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value complex(kind=wp) Integral ∫y(x)·dx Contents None","tags":"","loc":"proc/integrate_range_cx.html"},{"title":"interpolate_array_re – GENEUS","text":"public function interpolate_array_re(x, y, p) result(r) Constructs a piecewise hermitian cubic interpolation of an array y(x)\nbased on discrete numerical data and evaluates the interpolation at p.\nNote that the mesh spacing does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Point array p Return Value real(kind=wp),\n  dimension(size(p)) Interpolation y(p) Contents None","tags":"","loc":"proc/interpolate_array_re.html"},{"title":"interpolate_array_cx – GENEUS","text":"public function interpolate_array_cx(x, y, p) result(r) Complex version of interpolate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Point array p Return Value complex(kind=wp),\n  dimension(size(p)) Interpolation y(p) Contents None","tags":"","loc":"proc/interpolate_array_cx.html"},{"title":"interpolate_point_re – GENEUS","text":"public function interpolate_point_re(x, y, p) result(r) Wrapper for interpolate_array_re that accepts scalar arguments. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Single point p Return Value real(kind=wp) Interpolation y(p) Contents None","tags":"","loc":"proc/interpolate_point_re.html"},{"title":"interpolate_point_cx – GENEUS","text":"public function interpolate_point_cx(x, y, p) result(r) Complex version of interpolate_point_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Single point p Return Value complex(kind=wp) Interpolation y(p) Contents None","tags":"","loc":"proc/interpolate_point_cx.html"},{"title":"interpolate_point_matrix_re – GENEUS","text":"public pure function interpolate_point_matrix_re(x, y, p) result(r) Interpolates a matrix function using Catmull-Rom splines. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(:, :, :) :: y Function y(x) real(kind=wp), intent(in) :: p Single point p Return Value real(kind=wp),\n  dimension(size(y, 1), size(y, 2)) Interpolation y(p) Contents None","tags":"","loc":"proc/interpolate_point_matrix_re.html"},{"title":"linspace_array_re – GENEUS","text":"public pure subroutine linspace_array_re(array, first, last) Populates an array with elements from first to last , inclusive. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: array Output array to populate real(kind=wp), intent(in) :: first Value of first element real(kind=wp), intent(in) :: last Value of last  element Contents None","tags":"","loc":"proc/linspace_array_re.html"},{"title":"propagator – GENEUS","text":"public interface propagator Contents Module Procedures propagator_construct_vacuum propagator_construct_riccati propagator_construct_bcs Module Procedures private pure function propagator_construct_vacuum() result(this) Construct a vacuum propagator, i.e. a propagator which satisfies G=0. Arguments None Return Value type( propagator ) Constructed object private pure function propagator_construct_riccati(g, gt, dg, dgt) result(this) Construct an arbitrary state by explicitly providing Riccati parameters.\nUnspecified Riccati parameters default to zero due to spin constructors.\nThe distribution function defaults to equilibrium at zero temperature. Arguments Type Intent Optional Attributes Name type( spin ), intent(in) :: g Riccati parameter γ type( spin ), intent(in) :: gt Riccati parameter γ~ type( spin ), intent(in), optional :: dg Riccati parameter ∇γ type( spin ), intent(in), optional :: dgt Riccati parameter ∇γ~ Return Value type( propagator ) Constructed object private pure function propagator_construct_bcs(energy, gap) result(this) Constructs the state of a a BCS superconductor at a given energy, which\nmay have an imaginary term representing inelastic scattering. The second\nargument 'gap' is used to provide the superconducting order parameter Δ.\nThe distribution function defaults to equilibrium at zero temperature. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: energy Quasiparticle energy complex(kind=wp), intent(in) :: gap Order parameter Return Value type( propagator ) Constructed object","tags":"","loc":"interface/propagator.html"},{"title":"identity – GENEUS","text":"public pure function identity(n) result(R) Constructs an n×n identity matrix. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Matrix dimension Return Value real(kind=wp),\n  dimension(n, n) Identity matrix [n×n] Contents None","tags":"","loc":"proc/identity.html"},{"title":"matrix_inverse_re – GENEUS","text":"public pure function matrix_inverse_re(A) result(R) Wrapper for matrix_inverse_cx that operates on real matrices. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:, :) :: A Matrix A [n×n] Return Value real(kind=wp),\n  dimension(size(A, 1), size(A, 1)) Matrix R=A¯¹ Contents None","tags":"","loc":"proc/matrix_inverse_re.html"},{"title":"matrix_inverse_cx – GENEUS","text":"public pure function matrix_inverse_cx(A) result(R) Inverts a square matrix via Gauss-Jordan elimination with partial pivot\n(general) or a cofactoring algorithm (2x2 matrices). The implementation\nis based on Algorithm #2 in \"Efficient matrix inversion via Gauss-Jordan\nelimination and its parallelization\" by E.S. Quintana et al. (1998). Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Matrix A [n×n] Return Value complex(kind=wp),\n  dimension(size(A, 1), size(A, 1)) Matrix R=A¯¹ Contents None","tags":"","loc":"proc/matrix_inverse_cx.html"},{"title":"matrix_trace – GENEUS","text":"public pure function matrix_trace(A) result(r) Calculates the trace of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Matrix [n×m] Return Value complex(kind=wp) r = Tr(A) Contents None","tags":"","loc":"proc/matrix_trace.html"},{"title":"commutator – GENEUS","text":"public pure function commutator(A, B) result(R) Calculates the commutator between two complex square matrices. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Left  matrix [n×n] complex(kind=wp), intent(in), dimension(size(A, 1), size(A, 1)) :: B Right matrix [n×n] Return Value complex(kind=wp),\n  dimension(size(A, 1), size(A, 1)) Commutator R = [A,B] Contents None","tags":"","loc":"proc/commutator.html"},{"title":"anticommutator – GENEUS","text":"public pure function anticommutator(A, B) result(R) Calculates the anticommutator between two complex square matrices. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Left  matrix [n×n] complex(kind=wp), intent(in), dimension(size(A, 1), size(A, 1)) :: B Right matrix [n×n] Return Value complex(kind=wp),\n  dimension(size(A, 1), size(A, 1)) Anticommutator R = {A,B} Contents None","tags":"","loc":"proc/anticommutator.html"},{"title":"vector_diag – GENEUS","text":"public pure function vector_diag(A) result(r) Extracts the diagonal of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Matrix [n×m] Return Value complex(kind=wp),\n  dimension(min(size(A, 1), size(A, 2))) r = Diag(A) Contents None","tags":"","loc":"proc/vector_diag.html"},{"title":"matrix_diag – GENEUS","text":"public pure function matrix_diag(A, B) result(R) Constructs a block-diagonal matrix R from two general matrices A and B. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Left  matrix [n×m] complex(kind=wp), intent(in), dimension(:, :) :: B Right matrix [p×q] Return Value complex(kind=wp),\n  dimension(size(A, 1) + size(B, 1), size(A, 2) + size(B, 2)) R = Diag(A,B) Contents None","tags":"","loc":"proc/matrix_diag.html"},{"title":"spinscattering_construct – GENEUS","text":"public function spinscattering_construct(parent) result(this) Constructs a spinscattering object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinscattering ) Contents None","tags":"","loc":"proc/spinscattering_construct.html"},{"title":"spinscattering – GENEUS","text":"public interface spinscattering Contents Module Procedures spinscattering_construct Module Procedures public function spinscattering_construct (parent) result(this) Constructs a spinscattering object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinscattering )","tags":"","loc":"interface/spinscattering.html"},{"title":"spinorbit_construct – GENEUS","text":"public function spinorbit_construct(parent) result(this) Constructs a spinorbit object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinorbit ) Contents None","tags":"","loc":"proc/spinorbit_construct.html"},{"title":"spinorbit – GENEUS","text":"public interface spinorbit Contents Module Procedures spinorbit_construct Module Procedures public function spinorbit_construct (parent) result(this) Constructs a spinorbit object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinorbit )","tags":"","loc":"interface/spinorbit.html"},{"title":"structure – GENEUS","text":"public interface structure Contents Module Procedures structure_construct Module Procedures private function structure_construct() result(this) Constructs a multilayer stack from a configuration file. Arguments None Return Value type( structure )","tags":"","loc":"interface/structure.html"},{"title":"material_conf – GENEUS","text":"public subroutine material_conf(this, key, val) Uses evaluate_m Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this character, intent(in) :: key character, intent(in) :: val Contents None","tags":"","loc":"proc/material_conf.html"},{"title":"material_load – GENEUS","text":"public subroutine material_load(this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this Contents None","tags":"","loc":"proc/material_load.html"},{"title":"finalize – GENEUS","text":"subroutine finalize() Arguments None Contents None","tags":"","loc":"proc/finalize.html"},{"title":"prehook – GENEUS","text":"subroutine prehook() Arguments None Contents None","tags":"","loc":"proc/prehook.html"},{"title":"posthook – GENEUS","text":"subroutine posthook() Arguments None Contents None","tags":"","loc":"proc/posthook.html"},{"title":"finalize – GENEUS","text":"subroutine finalize() Arguments None Contents None","tags":"","loc":"proc/finalize~2.html"},{"title":"prehook – GENEUS","text":"subroutine prehook() Arguments None Contents None","tags":"","loc":"proc/prehook~2.html"},{"title":"posthook – GENEUS","text":"subroutine posthook() Arguments None Contents None","tags":"","loc":"proc/posthook~2.html"},{"title":"finalize – GENEUS","text":"subroutine finalize() Arguments None Contents None","tags":"","loc":"proc/finalize~3.html"},{"title":"prehook – GENEUS","text":"subroutine prehook() Arguments None Contents None","tags":"","loc":"proc/prehook~3.html"},{"title":"finalize – GENEUS","text":"subroutine finalize() Arguments None Contents None","tags":"","loc":"proc/finalize~4.html"},{"title":"prehook – GENEUS","text":"subroutine prehook() Arguments None Contents None","tags":"","loc":"proc/prehook~4.html"},{"title":"finalize – GENEUS","text":"subroutine finalize() Arguments None Contents None","tags":"","loc":"proc/finalize~5.html"},{"title":"stdio_m – GENEUS","text":"This file renames the ISO input/output units to the standard UNIX names,\ndefines the ANSI escape codes for colored output, and defines a number of\nauxiliary subroutines for e.g. writing out error and warning messages. Uses iso_fortran_env Contents Variables stdin stdout stderr color_none color_red color_green color_yellow color_blue color_purple color_cyan color_white Interfaces dump Functions input output Subroutines message warning error status_head status_body status_foot status_box dump_arrays dump_scalar Variables Type Visibility Attributes Name Initial integer, public :: stdin = input_unit integer, public :: stdout = output_unit integer, public :: stderr = error_unit character, public, parameter :: color_none = '\u001b[00m' character, public, parameter :: color_red = '\u001b[31m' character, public, parameter :: color_green = '\u001b[32m' character, public, parameter :: color_yellow = '\u001b[33m' character, public, parameter :: color_blue = '\u001b[34m' character, public, parameter :: color_purple = '\u001b[35m' character, public, parameter :: color_cyan = '\u001b[36m' character, public, parameter :: color_white = '\u001b[37m' Interfaces public interface dump public subroutine dump_arrays (filename, arrays, header) Dump numerical arrays to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in), dimension(:) :: arrays character(len=*), intent(in), dimension(:) :: header public subroutine dump_scalar (filename, scalar) Dump a numerical result to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in) :: scalar Functions public function input (file) result(unit) Open an input file for reading. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Return Value integer public function output (file) result(unit) Open an output file for writing. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Return Value integer Subroutines public subroutine message (msg) Provides a way to report a status message. Arguments Type Intent Optional Attributes Name character, intent(in) :: msg public subroutine warning (msg) Provides a way to report a warning message. Arguments Type Intent Optional Attributes Name character, intent(in) :: msg public subroutine error (msg) Provides a way to report an error message and halt the program. Arguments Type Intent Optional Attributes Name character, intent(in) :: msg public subroutine status_head (title) Provides a way to write boxed status messages to standard out; in\nparticular, this routine writes out a boxed title with a timestamp. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title public subroutine status_body (title, value) Provides a way to write boxed status messages to standard out; in\nparticular, this routine writes out the name and value of a variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title class(*), intent(in) :: value public subroutine status_foot () Provides a way to write boxed status messages to standard out; in\nparticular, this routine writes out the bottom edge of such a box. Arguments None public subroutine status_box (title) Provides a way to write boxed status messages to standard out. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title public subroutine dump_arrays (filename, arrays, header) Dump numerical arrays to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in), dimension(:) :: arrays character(len=*), intent(in), dimension(:) :: header public subroutine dump_scalar (filename, scalar) Dump a numerical result to an output file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=real64), intent(in) :: scalar","tags":"System","loc":"module/stdio_m.html"},{"title":"evaluate_m – GENEUS","text":"This module has functions that evaluate textual expressions as Fortran data.\nThis includes functions for converting mathematical expressions as arrays. Uses math_m stdio_m Contents Interfaces evaluate Interfaces public interface evaluate private subroutine evaluate_scalar_value(expression, value) Takes a scalar mathematical expression as input and returns the value. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: expression Mathematical expression real(kind=wp), intent(out) :: value Parsed result private subroutine evaluate_scalar_field(expression, domain, value) Evaluates a scalar-valued function of 'z' at the provided values for 'z'. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: expression Function of 'z' real(kind=wp), intent(in), dimension(:) :: domain Values of 'z' real(kind=wp), dimension(:), allocatable :: value Parsed result private subroutine evaluate_vector_value(expression, value) Takes a vector mathematical expression as input and returns the value. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: expression Mathematical expression real(kind=wp), intent(out), dimension(3) :: value Parsed result private subroutine evaluate_vector_field(expression, domain, value) Evaluates a vector-valued function of 'z' at the provided values for 'z'. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: expression Function of 'z' real(kind=wp), intent(in), dimension(:) :: domain Values of 'z' real(kind=wp), dimension(:, :), allocatable :: value Parsed result private subroutine evaluate_logical_value(expression, value) Takes a scalar logical expression as input and returns the value. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: expression Character 'T' or 'F' logical, intent(out) :: value Parsed expression private subroutine evaluate_integer_value(expression, value) Takes a scalar integer expression as input and returns the value. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: expression Numerical expression integer, intent(out) :: value Parsed result","tags":"Foundation","loc":"module/evaluate_m.html"},{"title":"nambu_m – GENEUS","text":"This module defines the new data type 'nambu', which represents 4×4 complex\nmatrices in spin and particle-hole space. It overloads arithmetic operators\nto work with the new type and exports relevant Pauli matrices as constants. Uses math_m spin_m Contents Interfaces inverse trace sum conjg nambuv Derived Types nambu Interfaces public interface inverse private pure function nambu_inv(this) result(r) Calculates the inverse of the nambu matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this Return Value type( nambu ) public interface trace private elemental function nambu_trace(this) result(r) Calculates the trace of the nambu matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this Return Value complex(kind=wp) public interface sum private pure function nambu_sum(this) result(r) Calculates the sum of an array of nambu matrices. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this (:) Return Value type( nambu ) public interface conjg private elemental function nambu_conjg(this) result(r) Calculates the complex conjugate of the nambu matrix. Arguments Type Intent Optional Attributes Name class( nambu ), intent(in) :: this Return Value type( nambu ) public interface nambuv private pure function nambuv_scalar(n) result(r) Constructs basis matrix number n in spin-nambu space. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value type( nambu ) private pure function nambuv_vector(v) result(r) Constructs a matrix representation of a vector. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(1:3) :: v Return Value type( nambu ) Derived Types type, public :: nambu Type-Bound Procedures generic, public :: nambu => cons_rscalar, cons_cscalar, cons_cmatrix, cons_nambu generic, public :: assignment(=) => assr_rscalar, assr_cscalar, assr_cmatrix, assl_cmatrix generic, public :: operator(+) => addl_rscalar, addr_rscalar, addl_cscalar, addr_cscalar, addl_cmatrix, addr_cmatrix, add_nambu generic, public :: operator(-) => subl_rscalar, subr_rscalar, subl_cscalar, subr_cscalar, subl_cmatrix, subr_cmatrix, sub_nambu generic, public :: operator(*) => mull_rscalar, mulr_rscalar, mull_cscalar, mulr_cscalar, mull_cmatrix, mulr_cmatrix, mul_nambu generic, public :: operator(/) => divr_rscalar, divr_cscalar generic, public :: operator(**) => expr_iscalar","tags":"Foundation","loc":"module/nambu_m.html"},{"title":"condmat_m – GENEUS","text":"This file provides a common interface to a library of mathematical objects\nthat can be useful for modelling materials in condensed matter physics. Uses propagator_m math_m nambu_m spin_m Contents None","tags":"Foundation","loc":"module/condmat_m.html"},{"title":"basic_m – GENEUS","text":"This module contains constants and functions for doing low-level numerics\nin Fortran. This includes standard real and complex precisions (sp, dp, qp),\na \"working precision\" (wp) that is used as the default precision in GENEUS;\nsome common numerical constants (like pi and the machine epsilon); as well\nas basic functions for e.g. constructing and deconstructing complex numbers. Uses iso_fortran_env Contents Variables sp dp qp wp inf eps pi Functions re im cx arg unitvector nonzero Variables Type Visibility Attributes Name Initial integer, public, parameter :: sp = real32 Single precision integer, public, parameter :: dp = real64 Double precision integer, public, parameter :: qp = real128 Quadruple precision integer, public, parameter :: wp = dp Working precision real(kind=wp), public, parameter :: inf = huge(1.0_wp) Infinity real(kind=wp), public, parameter :: eps = epsilon(1.0_wp) Infinitesimal real(kind=wp), public, parameter :: pi = atan(1.0_wp)*4.0_wp Circle constant Functions public elemental function re (z) result(x) Returns the real part of a complex number z=x+iy. Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: z Complex number Return Value real(kind=wp) Real part public elemental function im (z) result(y) Returns the imaginary part of a complex number z=x+iy. Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: z Complex number Return Value real(kind=wp) Imaginary part public elemental function cx (x, y) result(z) Returns the complex number z=x+iy. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Real part real(kind=wp), intent(in), optional :: y Imaginary part Return Value complex(kind=wp) Complex number public elemental function arg (z) result(t) Returns the complex argument θ of a complex number z=r·exp(iθ). Read more… Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: z Complex number Return Value real(kind=wp) Complex argument public pure function unitvector (v) result(r) If the argument has a finite norm, then it will be rescaled to a unit\nvector. If that norm is zero, then a zero vector is returned instead. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: v Input vector Return Value real(kind=wp),\n  dimension(3) Unit vector public pure function nonzero (v) result(r) Checks whether or not the argument has a finite norm. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: v Input vector Return Value logical Conclusion","tags":"Foundation","loc":"module/basic_m.html"},{"title":"spin_m – GENEUS","text":"This module defines the type 'spin', representing 2×2 complex matrices in\nspin space. The module overloads common arithmetic operators to work with\nthe new data type, and defines and exports the Pauli matrices as constants.\nTo make it easier to interact with common differential equation solvers,\nwhich often operate on real state vectors, the assignment operator is\noverloaded to make 'spin' easily importable/exportable to real vectors. Uses math_m Contents Variables pauli0 pauli1 pauli2 pauli3 pauli Interfaces inverse trace sum conjg norm2 Derived Types spin Variables Type Visibility Attributes Name Initial type( spin ), public, parameter :: pauli0 = spin(reshape([(1, 0), (0, 0), (0, 0), (1, 0)], [2, 2], order=[2, 1])) type( spin ), public, parameter :: pauli1 = spin(reshape([(0, 0), (1, 0), (1, 0), (0, 0)], [2, 2], order=[2, 1])) type( spin ), public, parameter :: pauli2 = spin(reshape([(0, 0), (0, -1), (0, 1), (0, 0)], [2, 2], order=[2, 1])) type( spin ), public, parameter :: pauli3 = spin(reshape([(1, 0), (0, 0), (0, 0), (-1, 0)], [2, 2], order=[2, 1])) type( spin ), public, parameter, dimension(0:3) :: pauli = [pauli0, pauli1, pauli2, pauli3] Interfaces public interface inverse private pure function spin_inv(this) result(r) Calculate the inverse of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value type( spin ) public interface trace private elemental function spin_trace(this) result(r) Calculate the trace of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value complex(kind=wp) public interface sum private pure function spin_sum(this) result(r) Calculate the sum of an array of spin matrices. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this (:) Return Value type( spin ) public interface conjg private elemental function spin_conjg(this) result(r) Calculate the complex conjugate of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value type( spin ) public interface norm2 private elemental function spin_norm(this) result(r) Calculate the Frobenius norm of the spin matrix. Arguments Type Intent Optional Attributes Name class( spin ), intent(in) :: this Return Value real(kind=wp) Derived Types type, public :: spin Type-Bound Procedures generic, public :: spin => cons_rscalar, cons_cscalar, cons_cmatrix, cons_rvector, cons_spin generic, public :: assignment(=) => assr_rscalar, assr_cscalar, assr_cmatrix, assr_rvector, assl_cmatrix, assl_rvector generic, public :: operator(+) => addl_rscalar, addr_rscalar, addl_cscalar, addr_cscalar, addl_cmatrix, addr_cmatrix, add_spin generic, public :: operator(-) => subl_rscalar, subr_rscalar, subl_cscalar, subr_cscalar, subl_cmatrix, subr_cmatrix, sub_spin generic, public :: operator(*) => mull_rscalar, mulr_rscalar, mull_cscalar, mulr_cscalar, mull_cmatrix, mulr_cmatrix, mul_spin generic, public :: operator(/) => divr_rscalar, divr_cscalar generic, public :: operator(**) => expr_iscalar","tags":"Foundation","loc":"module/spin_m.html"},{"title":"math_m – GENEUS","text":"This file provides a common interface to a large library of mathematical\nfunctions and subroutines. See the documentation of individual interfaces\nbelow for more information about the contents of the mathematical library. Uses calculus_m basic_m matrix_m Contents Interfaces trace inverse diag mean differentiate integrate interpolate linspace Interfaces public interface trace Public interface for functions that calculate a matrix trace. public pure function matrix_trace (A) result(r) Calculates the trace of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Matrix [n×m] Return Value complex(kind=wp) r = Tr(A) public interface inverse Public interface for functions that calculate a matrix inverse. public pure function matrix_inverse_re (A) result(R) Wrapper for matrix_inverse_cx that operates on real matrices. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:, :) :: A Matrix A [n×n] Return Value real(kind=wp),\n  dimension(size(A, 1), size(A, 1)) Matrix R=A¯¹ public pure function matrix_inverse_cx (A) result(R) Inverts a square matrix via Gauss-Jordan elimination with partial pivot\n(general) or a cofactoring algorithm (2x2 matrices). The implementation\nis based on Algorithm #2 in \"Efficient matrix inversion via Gauss-Jordan\nelimination and its parallelization\" by E.S. Quintana et al. (1998). Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Matrix A [n×n] Return Value complex(kind=wp),\n  dimension(size(A, 1), size(A, 1)) Matrix R=A¯¹ public interface diag Public interface for functions that deal with matrix diagonals. public pure function matrix_diag (A, B) result(R) Constructs a block-diagonal matrix R from two general matrices A and B. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Left  matrix [n×m] complex(kind=wp), intent(in), dimension(:, :) :: B Right matrix [p×q] Return Value complex(kind=wp),\n  dimension(size(A, 1) + size(B, 1), size(A, 2) + size(B, 2)) R = Diag(A,B) public pure function vector_diag (A) result(r) Extracts the diagonal of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Matrix [n×m] Return Value complex(kind=wp),\n  dimension(min(size(A, 1), size(A, 2))) r = Diag(A) public interface mean Public interface for routines that calculate the mean value. public pure function mean_array_re (x) result(r) Calculates the mean value of a real-valued array. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Real-valued array Return Value real(kind=wp) Mean value public pure function mean_array_cx (x) result(r) Calculates the mean value of a complex-valued array. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:) :: x Complex-valued array Return Value complex(kind=wp) Mean value public interface differentiate Public interface for various differentiation routines. public pure function differentiate_array_re (x, y) result(r) Calculates the numerical derivative of an array y wrt. x using central\ndifferences at the interior points and forward/backward differences at\nthe exterior points. All three approaches yield two-point approximations\nof the derivatives, thus the mesh spacing does not have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp),\n  dimension(size(x)) Derivative dy/dx public pure function differentiate_array_cx (x, y) result(r) Complex version of differentiate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp),\n  dimension(size(x)) Derivative dy/dx public interface integrate Public interface for various integration routines. public pure function integrate_array_re (x, y) result(r) Calculates the integral of an array y wrt. x using the trapezoid\nmethod. The mesh spacing does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp) Integral ∫y(x)·dx public pure function integrate_array_cx (x, y) result(r) Complex version of integrate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp) Integral ∫y(x)·dx public function integrate_range_re (x, y, a, b) result(r) Constructs a piecewise hermitian cubic interpolation of an array y(x)\nfrom discrete numerical data, and then integrates the interpolation in\nthe range (a, b). The mesh spacing does not have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value real(kind=wp) Integral ∫y(x)·dx public function integrate_range_cx (x, y, a, b) result(r) Complex version of integrate_range_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value complex(kind=wp) Integral ∫y(x)·dx public interface interpolate Public interface for various interpolation routines. public function interpolate_point_re (x, y, p) result(r) Wrapper for interpolate_array_re that accepts scalar arguments. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Single point p Return Value real(kind=wp) Interpolation y(p) public function interpolate_point_cx (x, y, p) result(r) Complex version of interpolate_point_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Single point p Return Value complex(kind=wp) Interpolation y(p) public function interpolate_array_re (x, y, p) result(r) Constructs a piecewise hermitian cubic interpolation of an array y(x)\nbased on discrete numerical data and evaluates the interpolation at p.\nNote that the mesh spacing does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Point array p Return Value real(kind=wp),\n  dimension(size(p)) Interpolation y(p) public function interpolate_array_cx (x, y, p) result(r) Complex version of interpolate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Point array p Return Value complex(kind=wp),\n  dimension(size(p)) Interpolation y(p) public pure function interpolate_point_matrix_re (x, y, p) result(r) Interpolates a matrix function using Catmull-Rom splines. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(:, :, :) :: y Function y(x) real(kind=wp), intent(in) :: p Single point p Return Value real(kind=wp),\n  dimension(size(y, 1), size(y, 2)) Interpolation y(p) public interface linspace Public interface for routines that initialize arrays. public pure subroutine linspace_array_re (array, first, last) Populates an array with elements from first to last , inclusive. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: array Output array to populate real(kind=wp), intent(in) :: first Value of first element real(kind=wp), intent(in) :: last Value of last  element","tags":"Foundation","loc":"module/math_m.html"},{"title":"calculus_m – GENEUS","text":"This module defines some functions that perform common calculus operations,\nincluding differentiating, integrating, and interpolating discretized data. Uses basic_m Contents Functions mean_array_re mean_array_cx differentiate_array_re differentiate_array_cx integrate_array_re integrate_array_cx integrate_range_re integrate_range_cx interpolate_array_re interpolate_array_cx interpolate_point_re interpolate_point_cx interpolate_point_matrix_re Subroutines linspace_array_re Functions public pure function mean_array_re (x) result(r) Calculates the mean value of a real-valued array. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Real-valued array Return Value real(kind=wp) Mean value public pure function mean_array_cx (x) result(r) Calculates the mean value of a complex-valued array. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:) :: x Complex-valued array Return Value complex(kind=wp) Mean value public pure function differentiate_array_re (x, y) result(r) Calculates the numerical derivative of an array y wrt. x using central\ndifferences at the interior points and forward/backward differences at\nthe exterior points. All three approaches yield two-point approximations\nof the derivatives, thus the mesh spacing does not have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp),\n  dimension(size(x)) Derivative dy/dx public pure function differentiate_array_cx (x, y) result(r) Complex version of differentiate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp),\n  dimension(size(x)) Derivative dy/dx public pure function integrate_array_re (x, y) result(r) Calculates the integral of an array y wrt. x using the trapezoid\nmethod. The mesh spacing does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value real(kind=wp) Integral ∫y(x)·dx public pure function integrate_array_cx (x, y) result(r) Complex version of integrate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) Return Value complex(kind=wp) Integral ∫y(x)·dx public function integrate_range_re (x, y, a, b) result(r) Constructs a piecewise hermitian cubic interpolation of an array y(x)\nfrom discrete numerical data, and then integrates the interpolation in\nthe range (a, b). The mesh spacing does not have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value real(kind=wp) Integral ∫y(x)·dx public function integrate_range_cx (x, y, a, b) result(r) Complex version of integrate_range_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: a Left endpoint real(kind=wp), intent(in) :: b Right endpoint Return Value complex(kind=wp) Integral ∫y(x)·dx public function interpolate_array_re (x, y, p) result(r) Constructs a piecewise hermitian cubic interpolation of an array y(x)\nbased on discrete numerical data and evaluates the interpolation at p.\nNote that the mesh spacing does not necessarily have to be uniform. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Point array p Return Value real(kind=wp),\n  dimension(size(p)) Interpolation y(p) public function interpolate_array_cx (x, y, p) result(r) Complex version of interpolate_array_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in), dimension(:) :: p Point array p Return Value complex(kind=wp),\n  dimension(size(p)) Interpolation y(p) public function interpolate_point_re (x, y, p) result(r) Wrapper for interpolate_array_re that accepts scalar arguments. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Single point p Return Value real(kind=wp) Interpolation y(p) public function interpolate_point_cx (x, y, p) result(r) Complex version of interpolate_point_re. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x complex(kind=wp), intent(in), dimension(size(x)) :: y Function y(x) real(kind=wp), intent(in) :: p Single point p Return Value complex(kind=wp) Interpolation y(p) public pure function interpolate_point_matrix_re (x, y, p) result(r) Interpolates a matrix function using Catmull-Rom splines. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Variable x real(kind=wp), intent(in), dimension(:, :, :) :: y Function y(x) real(kind=wp), intent(in) :: p Single point p Return Value real(kind=wp),\n  dimension(size(y, 1), size(y, 2)) Interpolation y(p) Subroutines public pure subroutine linspace_array_re (array, first, last) Populates an array with elements from first to last , inclusive. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: array Output array to populate real(kind=wp), intent(in) :: first Value of first element real(kind=wp), intent(in) :: last Value of last  element","tags":"Foundation","loc":"module/calculus_m.html"},{"title":"propagator_m – GENEUS","text":"This module defines a type 'propagator' which represents a propagator (also\nknown as a Green's function) for a given position and energy. The equilibrium\nparts (i.e. retarded and advanced) are represented via the Riccati parameters\nγ, γ~ and their derivatives, while the nonequilibrium part (i.e. Keldysh part)\nis represented by the traces of the distribution function and its derivatives.\nThese are together sufficient to reconstruct the full 8×8 propagator and its\nderivatives, and can be used to calculate the associated physical quantities\nsuch as the density of states, charge currents, spin currents, and so on. Uses math_m nambu_m spin_m Contents Interfaces propagator Derived Types propagator Interfaces public interface propagator private pure function propagator_construct_vacuum() result(this) Construct a vacuum propagator, i.e. a propagator which satisfies G=0. Arguments None Return Value type( propagator ) Constructed object private pure function propagator_construct_riccati(g, gt, dg, dgt) result(this) Construct an arbitrary state by explicitly providing Riccati parameters.\nUnspecified Riccati parameters default to zero due to spin constructors.\nThe distribution function defaults to equilibrium at zero temperature. Arguments Type Intent Optional Attributes Name type( spin ), intent(in) :: g Riccati parameter γ type( spin ), intent(in) :: gt Riccati parameter γ~ type( spin ), intent(in), optional :: dg Riccati parameter ∇γ type( spin ), intent(in), optional :: dgt Riccati parameter ∇γ~ Return Value type( propagator ) Constructed object private pure function propagator_construct_bcs(energy, gap) result(this) Constructs the state of a a BCS superconductor at a given energy, which\nmay have an imaginary term representing inelastic scattering. The second\nargument 'gap' is used to provide the superconducting order parameter Δ.\nThe distribution function defaults to equilibrium at zero temperature. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: energy Quasiparticle energy complex(kind=wp), intent(in) :: gap Order parameter Return Value type( propagator ) Constructed object Derived Types type, public :: propagator Constructor private pure function propagator_construct_vacuum () Construct a vacuum propagator, i.e. a propagator which satisfies G=0. private pure function propagator_construct_riccati (g, gt, dg, dgt) Construct an arbitrary state by explicitly providing Riccati parameters.\nUnspecified Riccati parameters default to zero due to spin constructors.\nThe distribution function defaults to equilibrium at zero temperature. private pure function propagator_construct_bcs (energy, gap) Constructs the state of a a BCS superconductor at a given energy, which\nmay have an imaginary term representing inelastic scattering. The second\nargument 'gap' is used to provide the superconducting order parameter Δ.\nThe distribution function defaults to equilibrium at zero temperature. Type-Bound Procedures procedure, public :: retarded => propagator_retarded Retarded propagator Gᴿ procedure, public :: retarded_gradient => propagator_retarded_gradient Retarded propagator ∇Gᴿ procedure, public :: retarded_laplacian => propagator_retarded_laplacian Retarded propagator ∇²Gᴿ procedure, public :: advanced => propagator_advanced Advanced propagator Gᴬ procedure, public :: advanced_gradient => propagator_advanced_gradient Advanced propagator ∇Gᴬ procedure, public :: advanced_laplacian => propagator_advanced_laplacian Advanced propagator ∇²Gᴬ procedure, public :: keldysh => propagator_keldysh Keldysh propagator Gᴷ procedure, public :: keldysh_gradient => propagator_keldysh_gradient Keldysh propagator ∇Gᴷ procedure, public :: distribution => propagator_distribution Distribution matrix H procedure, public :: distribution_gradient => propagator_distribution_gradient Distribution matrix ∇H procedure, public :: dissipation => propagator_dissipation Dissipation matrix M procedure, public :: dissipation_gradient => propagator_dissipation_gradient Dissipation matrix ∇M procedure, public :: condensate => propagator_condensate Condensate matrix Q procedure, public :: condensate_gradient => propagator_condensate_gradient Condensate matrix ∇Q procedure, public :: selfenergy1 => propagator_selfenergy1 Self-energy matrix R₁ procedure, public :: selfenergy2 => propagator_selfenergy2 Self-energy matrix R₂ procedure, public :: supercurrent => propagator_supercurrent Spectral super currents procedure, public :: lossycurrent => propagator_lossycurrent Spectral lossy currents procedure, public :: accumulation => propagator_accumulation Spectral accumulations procedure, public :: correlation => propagator_correlation Spectral correlations procedure, public :: density => propagator_density Local density of states procedure, public :: save => propagator_save Export Riccati parameters procedure, public :: load => propagator_load Import Riccati parameters","tags":"Foundation","loc":"module/propagator_m.html"},{"title":"matrix_m – GENEUS","text":"This module implements standard operations from linear algebra, including\nincluding matrix construction, inversion, commutation, and taking traces. Uses basic_m Contents Functions identity matrix_inverse_re matrix_inverse_cx matrix_trace commutator anticommutator vector_diag matrix_diag Functions public pure function identity (n) result(R) Constructs an n×n identity matrix. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Matrix dimension Return Value real(kind=wp),\n  dimension(n, n) Identity matrix [n×n] public pure function matrix_inverse_re (A) result(R) Wrapper for matrix_inverse_cx that operates on real matrices. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:, :) :: A Matrix A [n×n] Return Value real(kind=wp),\n  dimension(size(A, 1), size(A, 1)) Matrix R=A¯¹ public pure function matrix_inverse_cx (A) result(R) Inverts a square matrix via Gauss-Jordan elimination with partial pivot\n(general) or a cofactoring algorithm (2x2 matrices). The implementation\nis based on Algorithm #2 in \"Efficient matrix inversion via Gauss-Jordan\nelimination and its parallelization\" by E.S. Quintana et al. (1998). Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Matrix A [n×n] Return Value complex(kind=wp),\n  dimension(size(A, 1), size(A, 1)) Matrix R=A¯¹ public pure function matrix_trace (A) result(r) Calculates the trace of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Matrix [n×m] Return Value complex(kind=wp) r = Tr(A) public pure function commutator (A, B) result(R) Calculates the commutator between two complex square matrices. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Left  matrix [n×n] complex(kind=wp), intent(in), dimension(size(A, 1), size(A, 1)) :: B Right matrix [n×n] Return Value complex(kind=wp),\n  dimension(size(A, 1), size(A, 1)) Commutator R = [A,B] public pure function anticommutator (A, B) result(R) Calculates the anticommutator between two complex square matrices. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Left  matrix [n×n] complex(kind=wp), intent(in), dimension(size(A, 1), size(A, 1)) :: B Right matrix [n×n] Return Value complex(kind=wp),\n  dimension(size(A, 1), size(A, 1)) Anticommutator R = {A,B} public pure function vector_diag (A) result(r) Extracts the diagonal of a general complex matrix. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Matrix [n×m] Return Value complex(kind=wp),\n  dimension(min(size(A, 1), size(A, 2))) r = Diag(A) public pure function matrix_diag (A, B) result(R) Constructs a block-diagonal matrix R from two general matrices A and B. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in), dimension(:, :) :: A Left  matrix [n×m] complex(kind=wp), intent(in), dimension(:, :) :: B Right matrix [p×q] Return Value complex(kind=wp),\n  dimension(size(A, 1) + size(B, 1), size(A, 2) + size(B, 2)) R = Diag(A,B)","tags":"Foundation","loc":"module/matrix_m.html"},{"title":"spinactive_m – GENEUS","text":"This submodule is included by conductor.f, and contains the equations which model spin-active interfaces. Todo Reimplement shortcut-evaluation of the current for nonmagnetic interfaces. Uses propagator_m material_m condmat_m Contents Derived Types spinactive Derived Types type, public :: spinactive Type-Bound Procedures procedure, public :: diffusion_current => spinactive_diffusion_current procedure, public :: kinetic_current => spinactive_kinetic_current procedure, public :: update_prehook => spinactive_update_prehook","tags":"Materials","loc":"module/spinactive_m.html"},{"title":"spinscattering_m – GENEUS","text":"This submodule is included by conductor.f, and contains equations which model \nspin-flip scattering, spin-orbit scattering, and magnetic orbital depairing. Uses material_m condmat_m Contents Interfaces spinscattering Derived Types spinscattering Functions spinscattering_construct Interfaces public interface spinscattering public function spinscattering_construct (parent) result(this) Constructs a spinscattering object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinscattering ) Derived Types type, public :: spinscattering Constructor public  function spinscattering_construct (parent) Constructs a spinscattering object with a given parent material. Type-Bound Procedures procedure, public :: diffusion_equation => spinscattering_diffusion_equation Diffusion equation procedure, public :: kinetic_equation => spinscattering_kinetic_equation Kinetic equation Functions public function spinscattering_construct (parent) result(this) Constructs a spinscattering object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinscattering )","tags":"Materials","loc":"module/spinscattering_m.html"},{"title":"conductor_m – GENEUS","text":"This module defines the data type 'conductor', which models the physical state of a conductor for a discretized range\nof positions and energies.  It has two main applications: (i) it can be used as a base type for more exotic materials,\nsuch as superconductors and ferromagnets; (ii) it can be used in conjunction with such materials in hybrid structures. Uses spinactive_m spinorbit_m material_m condmat_m stdio_m spinscattering_m Contents Derived Types conductor Derived Types type, public, extends( material ) :: conductor Type-Bound Procedures procedure, public :: update => material_update Calculate propagators procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) procedure, public :: save => material_save Saves the state of the material procedure, public :: load => material_load Loads the state of the material procedure, public :: construct => conductor_construct Constructs the object procedure, public :: initialize => conductor_initialize Initializes propagators procedure, public :: update_prehook => conductor_update_prehook Code to execute before updates procedure, public :: update_posthook => conductor_update_posthook Code to execute after  updates procedure, public :: diffusion_equation => conductor_diffusion_equation Diffusion equation procedure, public :: diffusion_equation_a => conductor_diffusion_equation_a Boundary condition (left) procedure, public :: diffusion_equation_b => conductor_diffusion_equation_b Boundary condition (right) procedure, public :: kinetic_equation => conductor_kinetic_equation Kinetic equation procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) procedure, public :: conf => conductor_conf Configures material parameters","tags":"Materials","loc":"module/conductor_m.html"},{"title":"halfmetal_m – GENEUS","text":"This module defines the data type 'halfmetal', which models the physical state of a strong or halfmetallic ferromagnet.\nThe type is a member of class(conductor), and inherits the internal structure and generic methods defined there. Todo Add an update_posthook to rescale density(:) and current(:) with the dependence of the diffusion constant matrix\n  on the polarization. Remember to check how the polarization dependence varies with the number of dimensions. Todo Check if a non-linear dependence of the polarization matrix on the polarization is more sensible? Uses material_m conductor_m condmat_m stdio_m Contents Derived Types halfmetal Derived Types type, public, extends( conductor ) :: halfmetal Type-Bound Procedures procedure, public :: update => material_update Calculate propagators procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) procedure, public :: save => material_save Saves the state of the material procedure, public :: load => material_load Loads the state of the material procedure, public :: construct => conductor_construct Constructs the object procedure, public :: initialize => conductor_initialize Initializes propagators procedure, public :: kinetic_equation => conductor_kinetic_equation Kinetic equation procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) procedure, public :: conf => halfmetal_conf Configures the material parameters procedure, public :: diffusion_equation => halfmetal_diffusion_equation Defines the Usadel diffusion equation procedure, public :: diffusion_equation_a => halfmetal_diffusion_equation_a Boundary condition at the left  interface procedure, public :: diffusion_equation_b => halfmetal_diffusion_equation_b Boundary condition at the right interface procedure, public :: update_prehook => halfmetal_update_prehook Code to execute before calculating the propagators procedure, public :: update_posthook => halfmetal_update_posthook Code to execute after  calculating the propagators procedure, public :: update_density => halfmetal_update_density Calculates the density of states","tags":"Materials","loc":"module/halfmetal_m.html"},{"title":"spinorbit_m – GENEUS","text":"This submodule is included by conductor.f, and contains the equations which model spin-orbit coupling in diffusive materials. Uses material_m condmat_m Contents Interfaces spinorbit Derived Types spinorbit Functions spinorbit_construct Interfaces public interface spinorbit public function spinorbit_construct (parent) result(this) Constructs a spinorbit object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinorbit ) Derived Types type, public :: spinorbit Constructor public  function spinorbit_construct (parent) Constructs a spinorbit object with a given parent material. Type-Bound Procedures procedure, public :: diffusion_equation => spinorbit_diffusion_equation Diffusion equation procedure, public :: diffusion_equation_a => spinorbit_diffusion_equation_a Boundary condition (left) procedure, public :: diffusion_equation_b => spinorbit_diffusion_equation_b Boundary condition (right) procedure, public :: update_prehook => spinorbit_update_prehook Code to execute before updates Functions public function spinorbit_construct (parent) result(this) Constructs a spinorbit object with a given parent material. Arguments Type Intent Optional Attributes Name class( material ), target :: parent Return Value type( spinorbit )","tags":"Materials","loc":"module/spinorbit_m.html"},{"title":"structure_m – GENEUS","text":"This module defines a data type 'structure', which is useful for constructing and using multilayer hybrid structures. It\nalso exports the type definitions and constructors for all class(material) types, although these should rarely be needed. Uses halfmetal_m material_m condmat_m ferromagnet_m conductor_m stdio_m superconductor_m Contents Interfaces structure Derived Types structure Interfaces public interface structure private function structure_construct() result(this) Constructs a multilayer stack from a configuration file. Arguments None Return Value type( structure ) Derived Types type, public :: structure Constructor private  function structure_construct () Constructs a multilayer stack from a configuration file. Type-Bound Procedures procedure, public :: push => structure_push Construct a single layer procedure, public :: conf => structure_conf Configure a single layer procedure, public :: cmap => structure_cmap Configure  all layers procedure, public :: fmap => structure_fmap Manipulate all layers procedure, public :: initialize => structure_initialize Reset the physical state procedure, public :: save => structure_save Save the physical state procedure, public :: load => structure_load Load the physical state procedure, public :: update => structure_update Update the physical state procedure, public :: update_prehook => structure_update_prehook Execute all update prehooks procedure, public :: update_posthook => structure_update_posthook Execute all update posthooks procedure, public :: converge => structure_converge Update until convergence procedure, public :: write => structure_write Write out observables procedure, public :: difference => structure_difference Check how much the physical state changes procedure, public :: materials => structure_materials Check the number of enabled materials procedure, public :: selfconsistency => structure_selfconsistency Whether selfconsistency iteration is required procedure, public :: superconductors => structure_superconductors Check the number of enables superconductors procedure, public :: chargeviolation => structure_chargeviolation Check the violation of charge conservation procedure, public :: gap => structure_gap Check the minimum superconducting gap","tags":"Materials","loc":"module/structure_m.html"},{"title":"superconductor_m – GENEUS","text":"This module defines the data type 'superconductor', which models the physical state of a superconductor. The type is\na member of class(conductor), and thus inherits the internal structure and generic methods defined in conductor_m. Uses ferromagnet_m conductor_m condmat_m stdio_m Contents Derived Types superconductor Derived Types type, public, extends( ferromagnet ) :: superconductor Type-Bound Procedures procedure, public :: update => material_update Calculate propagators procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) procedure, public :: save => material_save Saves the state of the material procedure, public :: load => material_load Loads the state of the material procedure, public :: diffusion_equation_a => conductor_diffusion_equation_a Boundary condition (left) procedure, public :: diffusion_equation_b => conductor_diffusion_equation_b Boundary condition (right) procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) procedure, public :: construct => superconductor_construct Construct  propagators procedure, public :: initialize => superconductor_initialize Initialize propagators procedure, public :: diffusion_equation => superconductor_diffusion_equation Diffusion equation procedure, public :: kinetic_equation => superconductor_kinetic_equation Kinetic equation procedure, public :: update_gap => superconductor_update_gap Calculate the superconducting order parameter procedure, public :: update_boost => superconductor_update_boost Boost the convergence of the order parameter (Steffensen's method) procedure, public :: update_prehook => superconductor_update_prehook Update the internal variables before calculating the propagators procedure, public :: update_posthook => superconductor_update_posthook Update the superconducting order parameter from  the propagators procedure, public :: gap => superconductor_gap Return the superconducting order parameter at a given position procedure, public :: conf => superconductor_conf Configure material parameters","tags":"Materials","loc":"module/superconductor_m.html"},{"title":"ferromagnet_m – GENEUS","text":"This module defines the data type 'ferromagnet', which models the physical state of a ferromagnet. The type is a\nmember of class(conductor), and thus inherits the internal structure and generic methods defined in conductor_m. Uses conductor_m condmat_m stdio_m Contents Derived Types ferromagnet Derived Types type, public, extends( conductor ) :: ferromagnet Type-Bound Procedures procedure, public :: update => material_update Calculate propagators procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) procedure, public :: save => material_save Saves the state of the material procedure, public :: load => material_load Loads the state of the material procedure, public :: construct => conductor_construct Constructs the object procedure, public :: initialize => conductor_initialize Initializes propagators procedure, public :: update_posthook => conductor_update_posthook Code to execute after  updates procedure, public :: diffusion_equation_a => conductor_diffusion_equation_a Boundary condition (left) procedure, public :: diffusion_equation_b => conductor_diffusion_equation_b Boundary condition (right) procedure, public :: kinetic_equation_a => conductor_kinetic_equation_a Boundary condition (left) procedure, public :: kinetic_equation_b => conductor_kinetic_equation_b Boundary condition (right) procedure, public :: update_prehook => ferromagnet_update_prehook Code to execute before calculating the propagators procedure, public :: diffusion_equation => ferromagnet_diffusion_equation Diffusion equation procedure, public :: kinetic_equation => ferromagnet_kinetic_equation Kinetic equation procedure, public :: conf => ferromagnet_conf Configures material parameters","tags":"Materials","loc":"module/ferromagnet_m.html"},{"title":"material_m – GENEUS","text":"This module defines the data type 'material',  which models the state of a physical material for a discretized range of\npositions and energies. This is an abstract type, meaning that it is not intended to be instantiated on its own, but is\nintended as a base type for physical materials like conductors, superconductors, and ferromagnets. In other words, this\ntype defines the essential data structures and program structure, while the derived subtypes will define actual physics. Uses condmat_m stdio_m Contents Derived Types material Subroutines material_conf material_load Derived Types type, public, abstract :: material Type-Bound Procedures procedure(manipulate), public :: construct Construct  object procedure(initialize), public :: initialize Initialize object procedure(manipulate), public :: update_prehook Executed before update procedure(manipulate), public :: update_posthook Executed after  update procedure, public :: update => material_update Calculate propagators procedure, public :: update_diffusion => diffusion_update Calculate propagators (in equilibrium) procedure, public :: update_kinetic => kinetic_update Calculate propagators (nonequilibrium) procedure(diffusion_equation), public :: diffusion_equation Diffusion equation procedure(diffusion_equation_a), public :: diffusion_equation_a Boundary condition (left) procedure(diffusion_equation_b), public :: diffusion_equation_b Boundary condition (right) procedure(kinetic_equation), public :: kinetic_equation Kinetic equation procedure(kinetic_equation_a), public :: kinetic_equation_a Boundary condition (left) procedure(kinetic_equation_b), public :: kinetic_equation_b Boundary condition (right) procedure, public :: conf => material_conf Configures material parameters procedure, public :: save => material_save Saves the state of the material procedure, public :: load => material_load Loads the state of the material Subroutines public subroutine material_conf (this, key, val) Configure a material property based on a key-value pair. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this character, intent(in) :: key character, intent(in) :: val public subroutine material_load (this) Load a backup of a previous material state. Arguments Type Intent Optional Attributes Name class( material ), intent(inout) :: this","tags":"Materials","loc":"module/material_m.html"},{"title":"converge_p – GENEUS","text":"Uses math_m structure_m stdio_m Calculates general steady-state observables for a superconducting structure. Contents Variables stack threshold tolerance Subroutines finalize Variables Type Attributes Name Initial type( structure ) :: stack real(kind=wp), parameter :: threshold = 1e-2 real(kind=wp), parameter :: tolerance = 1e-8 Subroutines subroutine finalize () Arguments None","tags":"Programs","loc":"program/converge_p.html"},{"title":"voltage_p – GENEUS","text":"Uses math_m structure_m stdio_m Calculates the current-voltage relation of a superconducting structure. Contents Variables stack Ra Rb threshold tolerance iterations voltage current n Subroutines prehook posthook finalize Variables Type Attributes Name Initial type( structure ) :: stack type( conductor ), target :: Ra type( conductor ), target :: Rb real(kind=wp), parameter :: threshold = 1e-2 real(kind=wp), parameter :: tolerance = 1e-5 integer, parameter :: iterations = 100 real(kind=wp), dimension(:), allocatable :: voltage real(kind=wp), dimension(:), allocatable :: current integer :: n Subroutines subroutine prehook () Arguments None subroutine posthook () Arguments None subroutine finalize () Arguments None","tags":"Programs","loc":"program/voltage_p.html"},{"title":"phase_p – GENEUS","text":"Uses math_m structure_m stdio_m Calculates the current-phase relation of a superconducting structure. Contents Variables stack Ra Rb threshold tolerance iterations phase current critical n m Subroutines prehook posthook finalize Variables Type Attributes Name Initial type( structure ) :: stack type( superconductor ), target :: Ra type( superconductor ), target :: Rb real(kind=wp), parameter :: threshold = 1e-2 real(kind=wp), parameter :: tolerance = 1e-8 integer, parameter :: iterations = 51 real(kind=wp), dimension(:), allocatable :: phase real(kind=wp), dimension(:), allocatable :: current real(kind=wp) :: critical integer :: n integer :: m Subroutines subroutine prehook () Arguments None subroutine posthook () Arguments None subroutine finalize () Arguments None","tags":"Programs","loc":"program/phase_p.html"},{"title":"critical_p – GENEUS","text":"Uses math_m structure_m stdio_m Calculates the critical temperature of a superconducting structure. Contents Variables stack bisections bootstraps iterations threshold initgap minimum maximum critical n Subroutines prehook finalize Variables Type Attributes Name Initial type( structure ) :: stack integer, parameter :: bisections = 20 integer, parameter :: bootstraps = 10 integer, parameter :: iterations = 10 real(kind=wp), parameter :: threshold = 1e-08_wp real(kind=wp), parameter :: initgap = 1e-02_wp real(kind=wp) :: minimum = 0.00_wp real(kind=wp) :: maximum = 1.00_wp real(kind=wp) :: critical = 0.50_wp integer :: n = 0 Subroutines subroutine prehook () Arguments None subroutine finalize () Arguments None","tags":"Programs","loc":"program/critical_p.html"},{"title":"flow_p – GENEUS","text":"Uses math_m structure_m stdio_m Calculates the phase diagram of a superconducting structure. Contents Variables stack bootstraps iterations threshold flow init Subroutines prehook finalize Variables Type Attributes Name Initial type( structure ) :: stack integer, parameter :: bootstraps = 10 integer, parameter :: iterations = 10 real(kind=wp), parameter :: threshold = 1e-8_wp real(kind=wp) :: flow real(kind=wp) :: init Subroutines subroutine prehook () Arguments None subroutine finalize () Arguments None","tags":"Programs","loc":"program/flow_p.html"},{"title":"Overview – GENEUS","text":"GENEUS: General Non-Equilibrium Usadel Solver GENEUS (pronounced \"genius\") is a set of numerical programs for solving the Usadel diffusion equation in one-dimensional superconducting nanostructures, both in and out of equilibrium.\nThe programs are quite flexible, being able to treat systems with e.g. magnetic elements, spin-orbit coupling, spin-dependent scattering, strongly polarized magnetic interfaces, voltage gradients, and temperature gradients.\nThe suite also contains specialized programs for calculating the critical temperature and phase diagrams of all these hybrid structures.\nThe programs are also built to be user-friendly: they are configured using simple configuration files, which can include mathematical expressions to initialize the physical system, and the output is easily imported in e.g. Gnuplot or Matlab.\nFinally, the code is written in modern object-oriented Fortran, making it both simple and efficient. This software was developed by Jabir Ali Ouassou during his doctoral research.\nThe research was supervised by Prof. Jacob Linder at the Center for Quantum Spintronics , NTNU, Norway.\nThe software itself is released under the MIT open-source licence ;\nthis basically means that you are free to use it for any purpose, as long as you give credit where appropriate.\nThe source is available on Github . The project also relies on the external libraries bvp_solver , fparser , and pchip .\nThese are available under a mixture of open-source licences, as indicated in the source files themselves.\nFor convenience, these libraries have been bundled with this software page, and their sources are located under src/external . For instructions on how to install GENEUS, continue to the next part of the manual.\nAfter that, the different sections shown in the table of contents on the left will guide you through the use of the programs themselves.","tags":"","loc":"page//index.html"},{"title":"Installation – GENEUS","text":"Installation For up-to-date installation instructions, see the README on GitHub . Note that the tutorial herein uses Gnuplot for data visualization, so it may be easier to follow the examples if you have that installed.\nIf you are unfamiliar with Gnuplot, take a look at this page for examples of how to generate publication-quality plots with Gnuplot.","tags":"","loc":"page/./01-installation.html"},{"title":"Tutorial – GENEUS","text":"Introduction In this tutorial, we demonstrate how to model some common superconducting spintronics devices using the GENEUS software suite.\nThe first few sections will gradually introduce basic calculations, selfconsistent calculations, and nonequilibrium calculations.\nAfter that, we will demonstrate some more advanced features of the configuration files, such as how to initialize a system using mathematical equations, and how to set system parameters using command-line arguments.\nFinally, we will show how to use more specialized simulation programs to calculate phase diagrams and the superconducting critical temperature.\nThe instructions assume that you use Bash as your terminal shell, and have Gnuplot available for data visualization. Basic calculations As the first example, we consider an S/N/S Josephson junction.\nThis consists of a normal-metal layer in-between two bulk superconductors, which we treat as reservoirs with fixed order parameters .\nThis produces a phase-difference and maximizes the charge supercurrent .\nThe normal-metal layer is assumed to have a length , where is the superconducting coherence length.\nFinally, the interfaces are assumed to have tunneling conductances , where is the normal-state conductance of the normal-metal layer. First, we have to write an INI-like configuration file that describes the physical system above.\nThe format used for these configuration files is simple but flexible: Sections like [material] defines a new material layer in a one-dimensional nanostructure.\n    Possible materials include superconductor , conductor , ferromagnet , and halfmetal . The physical properties and numerical model used for each material is configured using key-value pairs with the syntax key: value .\n    Depending on the property, this can be either a boolean variable (T or F), an integer (e.g. 1), a real number (e.g. 1.0), or a real vector (e.g. [1.0,0,0]). Material properties can also be specified using mathematical functions or command-line options.\n    This functionality will be discussed in more detail later in the tutorial. Spaces are ignored by the configuration parser, and empty lines are permitted as well.\n    However, tabs are not permitted anywhere, and newlines are not permitted within a key-value pair. Everything after # is regarded as a comment, and ignored by the configuration parser. Here is a configuration file that describes the physical setup above: # S/N/S Josephson junction # with π/2 phase difference [superconductor] order:         0 gap:           1.00 phase:        +0.25 [conductor] order:         1 length:        3.00 conductance_a: 0.30 conductance_b: 0.30 [superconductor] order:         0 gap:           1.00 phase:        -0.25 Sections like [superconductor] and [conductor] specify that we wish to simulate an S/N/S junction.\nBelow each section, the physical properties of that material layer is specified using key-value pairs. Let us first consider their physical properties.\nFor the superconductors, the parameter phase sets the phases of the order parameters (in units of ), while the parameter gap sets the magnitude (in units of ).\nSince is the default value for superconducting layers, specifying the gap is in this case optional. For the normal metal, the parameters conductance_a and conductance_b define the tunneling conductance of the \"left\" and \"right\" interfaces, respectively.\nHere, \"left\" refers to the material defined above, and \"right\" the material defined below.\nThese conductance values are normalized relative to the bulk conductance of the normal metal.\nThe length of the material is obviously defined using the length parameter (in units of ). In addition to these physical parameters, a property order is used to control the numerical procedure.\nThe simulation programs work by solving the Usadel diffusion equation in one layer at a time, and this property can be used to control in what order this happens.\nThis is particularly useful in large multilayer structures, where some iteration orders may converge faster than others due to e.g. symmetry reasons.\nThe special value 0 is used to disable simulations entirely in a material, thus making it into a reservoir.\nThis is what we have done in the example above: since both superconductors have the order set to 0, they are treated as bulk reservoirs by the simulation program.\nNote that since the order defaults to 1, it is optional to define it for the normal metal here. After saving the above configuration file in a suitable folder as e.g. josephson.conf , open a terminal in that directory.\nThe simulation can now be started using the converge program: converge josephson.conf & The simulation program should now run in the background.\nIt will continuously write status information to the file output.log , while information about any errors that might occur is written to error.log .\nIn order to track the progress of the simulation, you can use the command tail : tail -n +0 -f *.log If you compiled the program using IFort, and have a modern processor (e.g. an Intel Core i7 in my case), the simulation should finish in less than a minute.\nDuring that time, it solves the Usadel equation as a function of position for 1000 energies in the range .\nPhysical observables such as the density of states and supercurrents are subsequently calculated from the propagators, and the results saved to DAT files. For this system, we may be especially interested in displaying the charge supercurrent in the system.\nIf you have Gnuplot installed, you can visualize the results by running gnuplot in the terminal, and then typing: set xlabel 'Position' set ylabel 'Charge current' set yrange [ -0 .012 : 0.012 ] plot 'supercurrent.dat' using 1 : 2 The data files are formatted using tab-separated values (TSV files), where the first two columns correspond to the position and charge current, respectively.\nIf you wish to use a different visualization tool, it should be straight-forward to import the file supercurrent.dat , and plot the first two columns against each other. Another quantity that might be interesting for this system, is to look at the superconducting phase as a function of position.\nThe file correlation.dat contains three data columns, which corresponds to the position, the gap magnitude, and the superconducting phase, respectively.\nThus, this information can be plotted as follows: set xlabel 'Position' set ylabel 'Superconducting phase' set yrange [ -0 .25 : 0.25 ] plot 'correlation.dat' using 1 : 3 Selfconsistent calculations For the next example, we consider an S/F bilayer with spin-orbit coupling in the ferromagnet.\nWe take the superconductor length to be , and treat its order parameter selfconsistently.\nThe ferromagnet has length , magnetic exchange field , Rashba coupling , and Dresselhaus coupling .\nThe spin-orbit coupling is in-plane; since the junction direction is along the -axis, this corresponds to a Rashba Hamiltonian and Dresselhaus Hamiltonian .\nThe goal will be to calculate the local density of states in the junction. An appropriate configuration file for this system would be: # S/F bilayer with SOC [superconductor] order:         2 length:        2.5 conductance_b: 0.3 [ferromagnet] order:         1 length:        0.5 rashba:        1.0 dresselhaus:   1.0 magnetization: [3,0,0] conductance_a: 0.3 Save this file as e.g. bilayer.conf .\nNote that there is no need to define boundary conditions for the \"outer\" interfaces: when no material is defined there, the program will automatically select vacuum boundary conditions.\nThe only thing needed to perform a selfconsistent calculation in the superconductor, is to specify a positive order for that layer (in this case 2).\nThe simulation can again be performed using the converge program: converge bilayer.conf & The simulation program will alternate between solving the Usadel equation in the two layers.\nNote that for the first few iterations, the order parameter in the superconductor is locked to .\nThis is because the state changes rapidly between iterations in the beginning, and selfconsistently updating the order parameter before the initial boundary conditions are approximately satisfied can slow down the convergence.\nThis \"bootstrap procedure\" continues until the change in the Riccati parameters between iterations is below 1%.\nAfter that, the program start to perform proper selfconsistency iterations, where it both solves the Usadel equation and updates the order parameter.\nAfter each such iteration, the physical observables in the system is written to output files, making it possible to preview the results.\nFinally, every 8th iteration, a simple convergence acceleration procedure (Steffensen's method) is used predict what value the order parameter is converging towards, thus shortening the required simulation time.\nUsing IFort and a modern processor, the entire simulation should require roughly 30 min to converge (using a default error tolerance of for the Riccati parameters). Once the simulation has finished, the relevant output file is density.dat .\nThe first three columns of this file correspond to the position, energy, and the spin-independent local density of states, respectively.\nThe results are easily visualized as a contour plot in Gnuplot: set xlabel 'Position' set ylabel 'Energy' set title 'Density of states' set yrange [ -3 : 3 ] set cbrange [ 0 : 2 ] set pm3d map splot 'density.dat' using 1 : 2 : 3 Nonequilibrium calculations In this section, we consider a voltage-biased N/S/N junction.\nThe voltage-biased contacts are used to inject a resistive charge current into the superconductor.\nOnce inside the superconductor, this resistive current decays as it is converted to a supercurrent.\nBelow, we intend to calculate and visualize that conversion process.\nThe superconductor is taken to have length , and its order parameter has to be determined selfconsistently to obtain physically reasonable results.\nFurthermore, due to the voltage bias, the system is necessarily out-of-equilibrium, which means that we also need to solve the kinetic equations numerically.\nAs for the normal metals, we will treat these as reservoirs at voltages . An appropriate configuration file for the system above is: # Voltage-biased superconductor [conductor] order:           0 voltage:        -0.1 [superconductor] order:           1 nonequilibrium:  T boost:           F length:          5.0 conductance_a:   0.3 conductance_b:   0.3 [conductor] order:           0 voltage:        +0.1 Save the configuration above as voltage.conf , and start the simulation: converge voltage.conf & By default, a convergence acceleration method is invoked every 8th selfconsistency iteration.\nFor systems without phase gradients (i.e. charge supercurrents), this can speed up convergence by a factor 2-5x.\nHowever, for systems with such phase gradients, the convergence acceleration procedure fails miserably, and should be disabled.\nThis is done by setting the parameter boost to false in the example above. Note that you explicitly need to set nonequilibrium to true in each layer where you wish to solve the out-of-equilibrium kinetic equations.\nWithout this switch, the simulation program will assume that it is dealing with an equilibrium problem, and only solve the Usadel equation for the retarded propagators. The example above is among the slowest single-layer junctions you can simulate with the code: using IFort and a modern processor, it takes roughly 90 min to converge completely.\nThis is because the code in general requires a large number of iterations to perform selfconsistent calculations with phase gradients, a problem that is further exacerbated by the lack of convergence acceleration.\nIf you wish to perform some faster numerical experiments to explore the out-of-equilibrium functionality, I would recommend testing N/N/N systems first. Once the simulation finishes, the resistive current and supercurrent can be visualized together using Gnuplot: set xlabel 'Position' set ylabel 'Charge current' set yrange [ 0 : 0.002 ] plot 'supercurrent.dat' using 1 : 2 title 'Super' , \\ 'lossycurrent.dat' using 1 : 2 title 'Resistive' Advanced functionality In this section, we introduce some more advanced capabilities of the configuration format: mathematical expressions and command-line arguments.\nIn the configuration file, you may replace any real number or vector by a mathematical expression.\nThe simulation program uses the fparser library to parse these expressions, and supports all functionality of that library.\nThis basically means that you can use all elementary mathematical operators supported by Fortran itself ( ** , * , / , + , - ), in addition to the most common elementary functions ( sin , cos , exp , log , sqrt , etc.).\nFor more information, see the fparser documentation . When defining mathematical expressions, there are two special variables available.\nOne of them is pi , which just refers to the mathematical constant ( ).\nThe second is z , which refers to the position inside a material.\nThe latter can be used to initialize physical fields using an analytical function of position, and is normalized so that that at the left and at the right interface of each material. You can also feed the simulation programs command-line arguments.\nThese can then be referred to in the configuration file using the syntax {1} for the first command-line argument, {2} for the second, and so on.\nIn this way, the configuration files themselves specify how to interpret these arguments.\nNote that if a command-line argument is referred to in the configuration file but not provided, the simulation program exits with an error. Let us now consider a physical example where the functionality above might be useful.\nImagine an S/F/S Josephson junction, where the central layer is a helical ferromagnet like Ho.\nIts magnetization texture can then be specified as a vector-valued function of position: . As for the superconductors, these are modelled as reservoirs with fixed order parameters.\nHowever, we wish to investigate the current-phase relation for multiple phase differences.\nWe therefore set the reservoir phases to , where the phase difference is provided as a command-line argument {1} .\nThis allows us to perform simulations for different in parallel without having to write multiple configuration files. An appropriate configuration file is then: # Josephson junction with a helical ferromagnet. [superconductor] order:         0 phase:        -{1}/2 [ferromagnet] length:        3.0 magnetization: [3*cos(pi*z/2), 3*sin(pi*z/2), 1] conductance_a: 0.3 conductance_b: 0.3 [superconductor] order:         0 phase:        +{1}/2 Save this file as e.g. helical.conf and open a terminal in the same folder.\nWe can then use a Bash loop to start multiple parallel simulations with different in separate subdirectories: for n in $( seq 0 .0 0 .1 1 .0 ) ; do mkdir sim_ ${ n } ; cd sim_ ${ n } ; converge ../helical.conf ${ n } & cd .. ; done With IFort and an Intel Core i7, it takes roughly 3 min for all the simulations to complete.\nSince the simulation results are scattered in multiple files in multiple folders, some postprocessing is required to collect the results afterwards.\nThe charge current is conserved, so we can extract it at any point in the ferromagnet; in this case, we use tail -n 1 to extract it from the right end.\nIn Bash, these results can then be collected by running: for n in $( seq 0 .0 0 .1 1 .0 ) ; do echo -n ${ n } >> current.dat ; tail -n 1 sim_ ${ n } /supercurrent.dat >> current.dat done Finally, the resulting current-phase relation can be plotted using: set ylabel 'Charge current' set xlabel 'Phase difference' plot 'current.dat' using 1 : 3 Critical temperature In all of the examples above, we have focused on a single program converge , which essentially calculates the steady-state solution for a physical system with known parameters.\nIn this section, we will demonstrate how to calculate the critical temperature of a superconducting junction using a more specialized program critical .\nThe program uses a kind of binary search algorithm to drastically improve the calculation time needed to determine the critical temperature with a high precision.\nThe ideas behind this algorithm are explained in more detail in the appendix of Scientific Reports 6, 29312 (2016) . As a model system, we consider an FI/S/FI spin-valve setup.\nThe ferromagnetic insulators are modelled as spin-active interfaces with spin-mixing conductances , where is the normal-state conductance of the superconductor.\nTheir magnetization directions are set to , where the relative magnetization angle will be provided as a command-line argument. An appropriate model for this spin-valve setup is: # FI/S/FI Spin-valve setup. [superconductor] # Material itself length:          1.0 # Left interface magnetization_a: [cos(-{1}*pi/2),sin(-{1}*pi/2),0] spinmixing_a:    0.5 # Right interface magnetization_b: [cos(+{1}*pi/2),sin(+{1}*pi/2),0] spinmixing_b:    0.5 Save this configuration file as e.g. spinvalve.conf and open a terminal in the same folder.\nWe then perform parallel simulations for magnetization angles : for n in $( seq 0 .0 0 .1 1 .0 ) ; do mkdir sim_ ${ n } ; cd sim_ ${ n } ; critical ../spinvalve.conf ${ n } & cd .. ; done These simulations may take a few hours to complete.\nWhen the simulations are finished, they will write both the command-line options used to invoke each process and the calculated critical temperature to critical.dat output files.\nThe critical temperature result is normalized to the critical temperature of a bulk superconductor.\nThe results can be collected into a single output file as follows: cat sim_*/critical.dat | cut -f 2 ,3 > critical.dat It is then trivial to plot the results in Gnuplot: set xlabel 'Magnetization angle' set ylabel 'Critical temperature' plot 'critical.dat' u 1 : 2 notitle Phase diagrams In this example, we demonstrate another specialized program flow , which can be used to rapidly map out the phase diagram of a superconducting system.\nThe program is based on analysing the \"flow\" of the order parameter during selfconsistency iterations; the concept is explained in more detail in the supplemental information of arXiv:1803.07076 .\nThe program will be illustrated using a spin-valve setup similar to the previous section.\nHowever, in this case we will assume zero temperature and perpendicular magnetizations, and investigate how the spin-mixing conductance affects the stability of superconductivity. An appropriate configuration file is: # FI/S/FI Spin-valve setup. [superconductor] # Material itself gap:             0.01 length:          1.00 # Left interface magnetization_a: [1,0,0] spinmixing_a:    {1} # Right interface magnetization_b: [0,1,0] spinmixing_b:    {1} Save the file above as e.g. spinvalve2.conf , and run the following commands to start the simulations: for n in $( seq 0 .0 0 .1 1 .0 ) ; do mkdir sim_ ${ n } ; cd sim_ ${ n } ; flow ../spinvalve2.conf ${ n } & cd .. ; done According to the configuration file above, the order parameter is initially set to a small value .\nThe simulation program then performs a fixed number of selfconsistency iterations, and determines whether the order parameter is spontaneously increasing (>1) or decreasing (<1) compared to its initial value.\nThis can be used to classify regions in parameter space as having a stable or unstable superconducting solution branch. The simulations should take about 10 min to complete. \nThe results can then be collected to a single output file: cat sim_*/flow.dat | cut -f 2 ,3 > flow.dat They are then straight-forward to visualize in Gnuplot: set xlabel 'Spin-mixing conductance' set ytics ( 'Normal' 0 , 'Super' 1 ) plot 'flow.dat' u 1 : ( $ 2 > 1 ) notitle","tags":"","loc":"page/./02-examples.html"},{"title":"Configuration – GENEUS","text":"Todo This page is still under construction. This page should contain a more detailed description of the configuration files:\nwhat materials are available, what material parameters are available, and how the physical parameters are normalized.","tags":"","loc":"page/./03-config.html"},{"title":"Output files – GENEUS","text":"Todo This page is still under construction. This page should describe the output files generated by the programs:\nwhat files are generated, what they contain, and how the results are normalized.","tags":"","loc":"page/./04-data.html"}]}