<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   
   <meta name="description" content="Please click here for the documentation or here for the code.">
    
    <meta name="author" content="Jabir Ali Ouassou" >
    <link rel="icon" href="../favicon.png">

    <title>Tutorial &ndash; GENEUS</title>

    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
    
    <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script src="../js/jquery-2.1.3.min.js"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>

  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">GENEUS </a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
        
            <li><a href='../page/index.html'>Overview</a></li>
      
            <li class="dropdown hidden-xs visible-sm visible-md hidden-lg">
              <a href="#" class="dropdown-toggle"
              data-toggle="dropdown" role="button"
              aria-haspopup="true"
     aria-expanded="false">Contents <span class="caret"></span></a>
        <ul class="dropdown-menu">
          
              
            <li><a href="../lists/files.html">Source Files</a></li>
        
        
        
            <li><a href="../lists/modules.html">Modules</a></li>
        
            
                                
            <li><a href="../lists/procedures.html">Procedures</a></li>
        
               
            <li><a href="../lists/types.html">Derived Types</a></li>
        
        
            <li><a href="../lists/programs.html">Programs</a></li>
               
        
        
            </ul>
        
            </li>


<li class="visible-xs hidden-sm visible-lg"><a href="../lists/files.html">Source Files</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/modules.html">Modules</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/procedures.html">Procedures</a></li>

                             
<li class="visible-xs hidden-sm visible-lg"><a href="../lists/types.html">Derived Types</a></li>


<li class="visible-xs hidden-sm visible-lg"><a href="../lists/programs.html">Programs</a></li>



          </ul>
        
        <form action="../search.html" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
        </div>
<!--
        <button type="submit" class="btn btn-default">Submit</button>
-->
        </form>
        
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
    
  <div class="row">
    <h1>Tutorial</h1>
    <div class="row">
    <div class="col-lg-12">
    <div class="well well-sm" style="min-height: 40px;">
      <ul class="list-inline" style="margin-bottom:0px; display:inline">
         
        <li><i class="fa fa-pencil"></i> Jabir Ali Ouassou</li>
         
         
        <li><i class="fa fa-calendar-o"></i> 2018-09-03</li>
         
<!--
        
-->
      </ul>
        <ol class="breadcrumb in-well">
      
         <li><a href='../page/index.html'>Overview</a></li>
      
         <li class="active">Tutorial</li>
      </ol>
    </div>
    </div>
    </div>
  </div>
  
  <div class="row">
    <div class="col-md-9 col-md-push-3" id='text'>
      <h3>Introduction</h3>
<p>In this tutorial, we demonstrate how to model some common superconducting spintronics devices using the GENEUS software suite.
The first few sections will gradually introduce basic calculations, selfconsistent calculations, and nonequilibrium calculations.
After that, we will demonstrate some more advanced features of the configuration files, such as how to initialize a system using mathematical equations, and how to set system parameters using command-line arguments.
Finally, we will show how to use more specialized simulation programs to calculate phase diagrams and the superconducting critical temperature.
The instructions assume that you use Bash as your terminal shell, and have Gnuplot available for data visualization.</p>
<h3>Basic calculations</h3>
<p>As the first example, we consider an S/N/S Josephson junction.
This consists of a normal-metal layer in-between two bulk superconductors, which we treat as reservoirs with fixed order parameters <script type="math/tex">\Delta = \Delta_0 e^{\pm i\pi/4}</script>.
This produces a phase-difference <script type="math/tex">\delta\varphi = \pi/2</script> and maximizes the charge supercurrent <script type="math/tex">J_{\mathrm{e}} = J_{\mathrm{e}0} \sin(\delta\varphi)</script>.
The normal-metal layer is assumed to have a length <script type="math/tex">L=3\xi</script>, where <script type="math/tex">\xi</script> is the superconducting coherence length.
Finally, the interfaces are assumed to have tunneling conductances <script type="math/tex">G_{\mathrm{T}} = 0.3G_{\mathrm{N}}</script>, where <script type="math/tex">G_{\mathrm{N}}</script> is the normal-state conductance of the normal-metal layer.</p>
<p>First, we have to write an INI-like configuration file that describes the physical system above.
The format used for these configuration files is simple but flexible: </p>
<ul>
<li>Sections like <code>[material]</code> defines a new material layer in a one-dimensional nanostructure.
    Possible materials include <code>superconductor</code>, <code>conductor</code>, <code>ferromagnet</code>, and <code>halfmetal</code>.</li>
<li>The physical properties and numerical model used for each material is configured using key-value pairs with the syntax <code>key: value</code>.
    Depending on the property, this can be either a boolean variable (T or F), an integer (e.g. 1), a real number (e.g. 1.0), or a real vector (e.g. [1.0,0,0]).</li>
<li>Material properties can also be specified using mathematical functions or command-line options.
    This functionality will be discussed in more detail later in the tutorial.</li>
<li>Spaces are ignored by the configuration parser, and empty lines are permitted as well.
    However, tabs are <em>not</em> permitted anywhere, and newlines are <em>not</em> permitted within a key-value pair.</li>
<li>Everything after <code>#</code> is regarded as a comment, and ignored by the configuration parser.</li>
</ul>
<p>Here is a configuration file that describes the physical setup above:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># S/N/S Josephson junction</span><span class="w"></span>
<span class="c1"># with π/2 phase difference</span><span class="w"></span>

<span class="k">[superconductor]</span><span class="w"></span>
<span class="w">  </span><span class="na">order:         0</span><span class="w"></span>
<span class="w">  </span><span class="na">gap:           1.00</span><span class="w"></span>
<span class="w">  </span><span class="na">phase:        +0.25</span><span class="w"></span>

<span class="k">[conductor]</span><span class="w"></span>
<span class="w">  </span><span class="na">order:         1</span><span class="w"></span>
<span class="w">  </span><span class="na">length:        3.00</span><span class="w"></span>
<span class="w">  </span><span class="na">conductance_a: 0.30</span><span class="w"></span>
<span class="w">  </span><span class="na">conductance_b: 0.30</span><span class="w"></span>

<span class="k">[superconductor]</span><span class="w"></span>
<span class="w">  </span><span class="na">order:         0</span><span class="w"></span>
<span class="w">  </span><span class="na">gap:           1.00</span><span class="w"></span>
<span class="w">  </span><span class="na">phase:        -0.25</span><span class="w"></span>
</code></pre></div>

<p>Sections like <code>[superconductor]</code> and <code>[conductor]</code> specify that we wish to simulate an S/N/S junction.
Below each section, the physical properties of that material layer is specified using key-value pairs.</p>
<p>Let us first consider their physical properties.
For the superconductors, the parameter <code>phase</code> sets the phases of the order parameters (in units of <script type="math/tex">\pi</script>), while the parameter <code>gap</code> sets the magnitude (in units of <script type="math/tex">\Delta_0</script>).
Since <script type="math/tex">\Delta = \Delta_0</script> is the default value for superconducting layers, specifying the <code>gap</code> is in this case optional.</p>
<p>For the normal metal, the parameters <code>conductance_a</code> and <code>conductance_b</code> define the tunneling conductance of the "left" and "right" interfaces, respectively.
Here, "left" refers to the material defined above, and "right" the material defined below.
These conductance values are normalized relative to the bulk conductance of the normal metal.
The length of the material is obviously defined using the <code>length</code> parameter (in units of <script type="math/tex">\xi</script>).</p>
<p>In addition to these physical parameters, a property <code>order</code> is used to control the numerical procedure.
The simulation programs work by solving the Usadel diffusion equation in one layer at a time, and this property can be used to control in what order this happens.
This is particularly useful in large multilayer structures, where some iteration orders may converge faster than others due to e.g. symmetry reasons.
The special value 0 is used to disable simulations entirely in a material, thus making it into a reservoir.
This is what we have done in the example above: since both superconductors have the order set to 0, they are treated as bulk reservoirs by the simulation program.
Note that since the order defaults to 1, it is optional to define it for the normal metal here.</p>
<p>After saving the above configuration file in a suitable folder as e.g.  <code>josephson.conf</code>, open a terminal in that directory.
The simulation can now be started using the <code>converge</code> program:</p>
<div class="codehilite"><pre><span></span><code>converge josephson.conf
</code></pre></div>

<p>The simulation program should now solve the Usadel equation as a function of position for 1000 energies in the range <script type="math/tex">(0,30\Delta_0)</script>.
Physical observables such as the density of states and supercurrents are subsequently calculated from the propagators, and the results saved to DAT files.</p>
<p>For this system, we may be especially interested in displaying the charge supercurrent in the system.
If you have Gnuplot installed, you can visualize the results by running <code>gnuplot</code> in the terminal, and then typing:</p>
<div class="codehilite"><pre><span></span><code><span class="k">set</span><span class="w"> </span><span class="nb">xlabel</span><span class="w"> </span><span class="s">&#39;Position&#39;</span><span class="w"></span>
<span class="k">set</span><span class="w"> </span><span class="nb">ylabel</span><span class="w"> </span><span class="s">&#39;Charge current&#39;</span><span class="w"></span>
<span class="k">set</span><span class="w"> </span><span class="nb">yrange</span><span class="w"> </span><span class="p">[</span><span class="mi">-0</span><span class="mf">.012</span><span class="o">:</span><span class="mf">0.012</span><span class="p">]</span><span class="w"></span>

<span class="k">plot</span><span class="w"> </span><span class="s">&#39;supercurrent.dat&#39;</span><span class="w"> </span><span class="nb">using</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="w"></span>
</code></pre></div>

<p>The data files are formatted using tab-separated values (TSV files), where the first two columns correspond to the position and charge current, respectively.
If you wish to use a different visualization tool, it should be straight-forward to import the file <code>supercurrent.dat</code>, and plot the first two columns against each other.</p>
<p>Another quantity that might be interesting for this system, is to look at the superconducting phase as a function of position.
The file <code>correlation.dat</code> contains three data columns, which corresponds to the position, the gap magnitude, and the superconducting phase, respectively.
Thus, this information can be plotted as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="k">set</span><span class="w"> </span><span class="nb">xlabel</span><span class="w"> </span><span class="s">&#39;Position&#39;</span><span class="w"></span>
<span class="k">set</span><span class="w"> </span><span class="nb">ylabel</span><span class="w"> </span><span class="s">&#39;Superconducting phase&#39;</span><span class="w"></span>
<span class="k">set</span><span class="w"> </span><span class="nb">yrange</span><span class="w"> </span><span class="p">[</span><span class="mi">-0</span><span class="mf">.25</span><span class="o">:</span><span class="mf">0.25</span><span class="p">]</span><span class="w"></span>

<span class="k">plot</span><span class="w"> </span><span class="s">&#39;correlation.dat&#39;</span><span class="w"> </span><span class="nb">using</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="mi">3</span><span class="w"></span>
</code></pre></div>

<h3>Selfconsistent calculations</h3>
<p>For the next example, we consider an S/F bilayer with spin-orbit coupling in the ferromagnet.
We take the superconductor length to be <script type="math/tex"> L_{\mathrm{S}} = 2.5\xi </script>, and treat its order parameter selfconsistently.
The ferromagnet has length <script type="math/tex"> L_{\mathrm{F}} = 0.5\xi </script>, magnetic exchange field <script type="math/tex"> \boldsymbol{m} = 3\Delta_0\boldsymbol{e}_x </script>, Rashba coupling <script type="math/tex"> \alpha\xi = 1 </script>, and Dresselhaus coupling <script type="math/tex"> \beta\xi = 1 </script>.
The spin-orbit coupling is in-plane; since the junction direction is along the <script type="math/tex">z</script>-axis, this corresponds to a Rashba Hamiltonian <script type="math/tex"> \mathcal{H}_{\mathrm{R}} \sim \alpha(p_y \sigma_x - p_x \sigma_y) </script> and Dresselhaus Hamiltonian <script type="math/tex"> \mathcal{H}_{\mathrm{D}} \sim \beta(p_y\sigma_y - p_x\sigma_x) </script>.
The goal will be to calculate the local density of states in the junction.</p>
<p>An appropriate configuration file for this system would be:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># S/F bilayer with SOC</span><span class="w"></span>

<span class="k">[superconductor]</span><span class="w"></span>
<span class="w">  </span><span class="na">order:         2</span><span class="w"></span>
<span class="w">  </span><span class="na">length:        2.5</span><span class="w"></span>
<span class="w">  </span><span class="na">conductance_b: 0.3</span><span class="w"></span>

<span class="k">[ferromagnet]</span><span class="w"></span>
<span class="w">  </span><span class="na">order:         1</span><span class="w"></span>
<span class="w">  </span><span class="na">length:        0.5</span><span class="w"></span>
<span class="w">  </span><span class="na">rashba:        1.0</span><span class="w"></span>
<span class="w">  </span><span class="na">dresselhaus:   1.0</span><span class="w"></span>
<span class="w">  </span><span class="na">magnetization: [3,0,0]</span><span class="w"></span>
<span class="w">  </span><span class="na">conductance_a: 0.3</span><span class="w"></span>
</code></pre></div>

<p>Save this file as e.g. <code>bilayer.conf</code>.
Note that there is no need to define boundary conditions for the "outer" interfaces: when no material is defined there, the program will automatically select vacuum boundary conditions.
The only thing needed to perform a selfconsistent calculation in the superconductor, is to specify a positive order for that layer (in this case 2).
The simulation can again be performed using the <code>converge</code> program:</p>
<div class="codehilite"><pre><span></span><code>converge bilayer.conf
</code></pre></div>

<p>The simulation program will alternate between solving the Usadel equation in the two layers.
Note that for the first few iterations, the order parameter in the superconductor is locked to <script type="math/tex">\Delta = \Delta_0</script>.
This is because the state changes rapidly between iterations in the beginning, and selfconsistently updating the order parameter before the initial boundary conditions are approximately satisfied can slow down the convergence.
This "bootstrap procedure" continues until the change in the Riccati parameters between iterations is below 1%.
After that, the program start to perform proper selfconsistency iterations, where it both solves the Usadel equation and updates the order parameter.
After each such iteration, the physical observables in the system is written to output files, making it possible to preview the results.
Finally, every 8th iteration, a simple convergence acceleration procedure (Steffensen's method) is used predict what value the order parameter is converging towards, thus shortening the required simulation time.</p>
<p>Once the simulation finishes, the relevant output file is <code>density.dat</code>.
The first three columns of this file correspond to the position, energy, and the spin-independent local density of states, respectively.
The results are easily visualized as a contour plot in Gnuplot:</p>
<div class="codehilite"><pre><span></span><code><span class="k">set</span><span class="w"> </span><span class="nb">xlabel</span><span class="w">  </span><span class="s">&#39;Position&#39;</span><span class="w"></span>
<span class="k">set</span><span class="w"> </span><span class="nb">ylabel</span><span class="w">  </span><span class="s">&#39;Energy&#39;</span><span class="w"></span>
<span class="k">set</span><span class="w"> </span><span class="nb">title</span><span class="w">   </span><span class="s">&#39;Density of states&#39;</span><span class="w"></span>

<span class="k">set</span><span class="w"> </span><span class="nb">yrange</span><span class="w">  </span><span class="p">[</span><span class="mi">-3</span><span class="o">:</span><span class="mi">3</span><span class="p">]</span><span class="w"></span>
<span class="k">set</span><span class="w"> </span><span class="nb">cbrange</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>

<span class="k">set</span><span class="w"> </span><span class="nb">pm3d</span><span class="w"> </span><span class="n">map</span><span class="w"></span>
<span class="k">splot</span><span class="w"> </span><span class="s">&#39;density.dat&#39;</span><span class="w"> </span><span class="nb">using</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">3</span><span class="w"></span>
</code></pre></div>

<h3>Nonequilibrium calculations</h3>
<p>In this section, we consider a voltage-biased N/S/N junction.
The voltage-biased contacts are used to inject a resistive charge current into the superconductor.
Once inside the superconductor, this resistive current decays as it is converted to a supercurrent.
Below, we intend to calculate and visualize that conversion process.
The superconductor is taken to have length <script type="math/tex"> L_{\mathrm{S}} = 5\xi </script>, and its order parameter has to be determined selfconsistently to obtain physically reasonable results.
Furthermore, due to the voltage bias, the system is necessarily out-of-equilibrium, which means that we also need to solve the kinetic equations numerically.
As for the normal metals, we will treat these as reservoirs at voltages <script type="math/tex"> eV/\Delta_0 = \pm 0.1 </script>.</p>
<p>An appropriate configuration file for the system above is:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Voltage-biased superconductor</span><span class="w"></span>

<span class="k">[conductor]</span><span class="w"></span>
<span class="w">  </span><span class="na">order:           0</span><span class="w"></span>
<span class="w">  </span><span class="na">voltage:        -0.1</span><span class="w"></span>

<span class="k">[superconductor]</span><span class="w"></span>
<span class="w">  </span><span class="na">order:           1</span><span class="w"></span>
<span class="w">  </span><span class="na">nonequilibrium:  T</span><span class="w"></span>
<span class="w">  </span><span class="na">boost:           F</span><span class="w"></span>
<span class="w">  </span><span class="na">length:          5.0</span><span class="w"></span>
<span class="w">  </span><span class="na">conductance_a:   0.3</span><span class="w"></span>
<span class="w">  </span><span class="na">conductance_b:   0.3</span><span class="w"></span>

<span class="k">[conductor]</span><span class="w"></span>
<span class="w">  </span><span class="na">order:           0</span><span class="w"></span>
<span class="w">  </span><span class="na">voltage:        +0.1</span><span class="w"></span>
</code></pre></div>

<p>Save the configuration above as <code>voltage.conf</code>, and start the simulation:</p>
<div class="codehilite"><pre><span></span><code>converge voltage.conf
</code></pre></div>

<p>By default, a convergence acceleration method is invoked every 8th selfconsistency iteration.
For systems without phase gradients (i.e. charge supercurrents), this can speed up convergence by a factor 2-5x.
However, for systems with such phase gradients, this procedure often diverges and should be disabled.
This is done by setting the parameter <code>boost</code> to false in the example above.</p>
<p>Note that you explicitly need to set <code>nonequilibrium</code> to true in each layer where you wish to solve the out-of-equilibrium kinetic equations.
Without this switch, the simulation program will assume that it is dealing with an equilibrium problem, and only solve the Usadel equation for the retarded propagators.</p>
<p>The example above is among the slowest single-layer junctions you can simulate with the code, typically taking a few hours to converge completely.
This is because the code in general requires a large number of iterations to perform selfconsistent calculations with phase gradients, a problem that is further exacerbated by the lack of convergence acceleration.
If you wish to perform some faster numerical experiments to explore the out-of-equilibrium functionality, I would recommend testing N/N/N systems first.</p>
<p>Once the simulation finishes, the resistive current and supercurrent can be visualized together using Gnuplot:</p>
<div class="codehilite"><pre><span></span><code><span class="k">set</span><span class="w"> </span><span class="nb">xlabel</span><span class="w"> </span><span class="s">&#39;Position&#39;</span><span class="w"></span>
<span class="k">set</span><span class="w"> </span><span class="nb">ylabel</span><span class="w"> </span><span class="s">&#39;Charge current&#39;</span><span class="w"></span>
<span class="k">set</span><span class="w"> </span><span class="nb">yrange</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mf">0.002</span><span class="p">]</span><span class="w"></span>

<span class="k">plot</span><span class="w"> </span><span class="s">&#39;supercurrent.dat&#39;</span><span class="w"> </span><span class="nb">using</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="w"> </span><span class="nb">title</span><span class="w"> </span><span class="s">&#39;Super&#39;</span><span class="o">,</span><span class="w"> </span>\<span class="w"></span>
<span class="w">     </span><span class="s">&#39;lossycurrent.dat&#39;</span><span class="w"> </span><span class="nb">using</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="w"> </span><span class="nb">title</span><span class="w"> </span><span class="s">&#39;Resistive&#39;</span><span class="w"></span>
</code></pre></div>

<h3>Advanced functionality</h3>
<p>In this section, we introduce some more advanced capabilities of the configuration format: mathematical expressions and command-line arguments.
In the configuration file, you may replace any real number or vector by a mathematical expression.
The simulation program uses the <a href="http://fparser.sourceforge.net/">fparser</a> library to parse these expressions, and supports all functionality of that library.
This basically means that you can use all elementary mathematical operators supported by Fortran itself (<code>**</code>, <code>*</code>, <code>/</code>, <code>+</code>, <code>-</code>), in addition to the most common elementary functions (<code>sin</code>, <code>cos</code>, <code>exp</code>, <code>log</code>, <code>sqrt</code>, etc.).
For more information, see the <a href="http://fparser.sourceforge.net/">fparser documentation</a>.</p>
<p>When defining mathematical expressions, there are two special variables available.
One of them is <code>pi</code>, which just refers to the mathematical constant (<script type="math/tex"> \pi = 3.1415\ldots </script>).
The second is <code>z</code>, which refers to the position <script type="math/tex"> z </script> inside a material.
The latter can be used to initialize physical fields using an analytical function of position, and is normalized so that that <script type="math/tex"> z = 0 </script> at the left and <script type="math/tex"> z = 1 </script> at the right interface of each material.</p>
<p>You can also feed the simulation programs command-line arguments.
These can then be referred to in the configuration file using the syntax <code>{1}</code> for the first command-line argument, <code>{2}</code> for the second, and so on.
In this way, the configuration files themselves specify how to interpret these arguments.
Note that if a command-line argument is referred to in the configuration file but not provided, the simulation program exits with an error.</p>
<p>Let us now consider a physical example where the functionality above might be useful.
Imagine an S/F/S Josephson junction, where the central layer is a helical ferromagnet like Ho.
Its magnetization texture can then be specified as a vector-valued function of position: <script type="math/tex"> \boldsymbol{m}(z) = [3\Delta_0 \cos(\pi z/2), 3\Delta_0 \sin(\pi z/2), \Delta_0] </script>.</p>
<p>As for the superconductors, these are modelled as reservoirs with fixed order parameters.
However, we wish to investigate the current-phase relation for multiple phase differences.
We therefore set the reservoir phases to <script type="math/tex"> \pm \delta\varphi/2 </script>, where the phase difference <script type="math/tex"> \delta\varphi </script> is provided as a command-line argument <code>{1}</code>.
This allows us to perform simulations for different <script type="math/tex"> \delta\varphi </script> in parallel without having to write multiple configuration files.</p>
<p>An appropriate configuration file is then:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Josephson junction with a helical ferromagnet.</span><span class="w"></span>

<span class="k">[superconductor]</span><span class="w"></span>
<span class="w">  </span><span class="na">order:         0</span><span class="w"></span>
<span class="w">  </span><span class="na">phase:        -{1}/2</span><span class="w"></span>

<span class="k">[ferromagnet]</span><span class="w"></span>
<span class="w">  </span><span class="na">length:        3.0</span><span class="w"></span>
<span class="w">  </span><span class="na">magnetization: [3*cos(pi*z/2), 3*sin(pi*z/2), 1]</span><span class="w"></span>
<span class="w">  </span><span class="na">conductance_a: 0.3</span><span class="w"></span>
<span class="w">  </span><span class="na">conductance_b: 0.3</span><span class="w"></span>

<span class="k">[superconductor]</span><span class="w"></span>
<span class="w">  </span><span class="na">order:         0</span><span class="w"></span>
<span class="w">  </span><span class="na">phase:        +{1}/2</span><span class="w"></span>
</code></pre></div>

<p>Save this file as e.g. <code>helical.conf</code> and open a terminal in the same folder.
We can then use a Bash loop to start multiple parallel simulations with different <script type="math/tex"> \delta\varphi \in \{ 0.0, 0.1, \ldots, 1.0 \} </script> in separate subdirectories:</p>
<div class="codehilite"><pre><span></span><code><span class="k">for</span> n <span class="k">in</span> <span class="k">$(</span>seq <span class="m">0</span>.0 <span class="m">0</span>.1 <span class="m">1</span>.0<span class="k">)</span><span class="p">;</span> <span class="k">do</span>
  mkdir sim_<span class="si">${</span><span class="nv">n</span><span class="si">}</span><span class="p">;</span>
  <span class="nb">cd</span> sim_<span class="si">${</span><span class="nv">n</span><span class="si">}</span><span class="p">;</span>
  nice converge ../helical.conf <span class="si">${</span><span class="nv">n</span><span class="si">}</span> &gt; output.log <span class="p">&amp;</span>
  <span class="nb">cd</span> ..<span class="p">;</span>
<span class="k">done</span>
</code></pre></div>

<p>Since the simulation results are scattered in multiple files in multiple folders, some postprocessing is required to collect the results afterwards.
The processes run in parallel in the background, each one writing its progress to a file <code>output.log</code> in the relevant subfolders.
The charge current is conserved, so we can extract it at any point in the ferromagnet; in this case, we use <code>tail -n 1</code> to extract it from the right end.
In Bash, these results can then be collected by running:</p>
<div class="codehilite"><pre><span></span><code><span class="k">for</span> n <span class="k">in</span> <span class="k">$(</span>seq <span class="m">0</span>.0 <span class="m">0</span>.1 <span class="m">1</span>.0<span class="k">)</span><span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> -n <span class="si">${</span><span class="nv">n</span><span class="si">}</span> &gt;&gt; current.dat<span class="p">;</span>
  tail -n <span class="m">1</span> sim_<span class="si">${</span><span class="nv">n</span><span class="si">}</span>/supercurrent.dat &gt;&gt; current.dat
<span class="k">done</span>
</code></pre></div>

<p>Finally, the resulting current-phase relation can be plotted using:</p>
<div class="codehilite"><pre><span></span><code><span class="k">set</span><span class="w"> </span><span class="nb">ylabel</span><span class="w"> </span><span class="s">&#39;Charge current&#39;</span><span class="w"></span>
<span class="k">set</span><span class="w"> </span><span class="nb">xlabel</span><span class="w"> </span><span class="s">&#39;Phase difference&#39;</span><span class="w"></span>

<span class="k">plot</span><span class="w"> </span><span class="s">&#39;current.dat&#39;</span><span class="w"> </span><span class="nb">using</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="mi">3</span><span class="w"></span>
</code></pre></div>

<h3>Critical temperature</h3>
<p>In all of the examples above, we have focused on a single program <code>converge</code>, which essentially calculates the steady-state solution for a physical system with known parameters.
In this section, we will demonstrate how to calculate the critical temperature of a superconducting junction using a more specialized program <code>critical</code>.
The program uses a kind of binary search algorithm to drastically improve the calculation time needed to determine the critical temperature with a high precision.
The ideas behind this algorithm are explained in more detail in the appendix of <a href="https://www.nature.com/articles/srep29312">Scientific Reports 6, 29312 (2016)</a>.</p>
<p>As a model system, we consider an FI/S/FI spin-valve setup.
The ferromagnetic insulators are modelled as spin-active interfaces with spin-mixing conductances <script type="math/tex"> G_\varphi = 0.5G_{\mathrm{N}} </script>, where <script type="math/tex"> G_{\mathrm{N}} </script> is the normal-state conductance of the superconductor.
Their magnetization directions are set to <script type="math/tex"> \boldsymbol{m} = [\cos(\pm\theta/2), \sin(\pm\theta/2), 0] </script>, where the relative magnetization angle <script type="math/tex"> \theta </script> will be provided as a command-line argument.</p>
<p>An appropriate model for this spin-valve setup is:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># FI/S/FI Spin-valve setup.</span><span class="w"></span>

<span class="k">[superconductor]</span><span class="w"></span>
<span class="w">  </span><span class="c1"># Material itself</span><span class="w"></span>
<span class="w">  </span><span class="na">length:          1.0</span><span class="w"></span>

<span class="w">  </span><span class="c1"># Left interface</span><span class="w"></span>
<span class="w">  </span><span class="na">magnetization_a: [cos(-{1}*pi/2),sin(-{1}*pi/2),0]</span><span class="w"></span>
<span class="w">  </span><span class="na">spinmixing_a:    0.5</span><span class="w"></span>

<span class="w">  </span><span class="c1"># Right interface</span><span class="w"></span>
<span class="w">  </span><span class="na">magnetization_b: [cos(+{1}*pi/2),sin(+{1}*pi/2),0]</span><span class="w"></span>
<span class="w">  </span><span class="na">spinmixing_b:    0.5</span><span class="w"></span>
</code></pre></div>

<p>Save this configuration file as e.g. <code>spinvalve.conf</code> and open a terminal in the same folder.
We then perform parallel simulations for magnetization angles <script type="math/tex"> \theta/\pi \in \{ 0.0, 0.1, \ldots, 1.0 \} </script>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">for</span> n <span class="k">in</span> <span class="k">$(</span>seq <span class="m">0</span>.0 <span class="m">0</span>.1 <span class="m">1</span>.0<span class="k">)</span><span class="p">;</span> <span class="k">do</span>
  mkdir sim_<span class="si">${</span><span class="nv">n</span><span class="si">}</span><span class="p">;</span>
  <span class="nb">cd</span> sim_<span class="si">${</span><span class="nv">n</span><span class="si">}</span><span class="p">;</span>
  critical ../spinvalve.conf <span class="si">${</span><span class="nv">n</span><span class="si">}</span> <span class="p">&amp;</span>
  <span class="nb">cd</span> ..<span class="p">;</span>
<span class="k">done</span>
</code></pre></div>

<p>These simulations may take a few hours to complete.
When the simulations are finished, they will write both the command-line options used to invoke each process and the calculated critical temperature to <code>critical.dat</code> output files.
The critical temperature result <script type="math/tex">T_{\mathrm{c}}</script> is normalized to the critical temperature <script type="math/tex">T_{\mathrm{cs}}</script> of a bulk superconductor.
The results can be collected into a single output file as follows:</p>
<div class="codehilite"><pre><span></span><code>cat sim_*/critical.dat <span class="p">|</span> cut -f <span class="m">2</span>,3 &gt; critical.dat
</code></pre></div>

<p>It is then trivial to plot the results in Gnuplot:</p>
<div class="codehilite"><pre><span></span><code><span class="k">set</span><span class="w"> </span><span class="nb">xlabel</span><span class="w"> </span><span class="s">&#39;Magnetization angle&#39;</span><span class="w"></span>
<span class="k">set</span><span class="w"> </span><span class="nb">ylabel</span><span class="w"> </span><span class="s">&#39;Critical temperature&#39;</span><span class="w"></span>

<span class="k">plot</span><span class="w"> </span><span class="s">&#39;critical.dat&#39;</span><span class="w"> </span><span class="nb">u</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="w"> </span><span class="nb">notitle</span><span class="w"></span>
</code></pre></div>

<h3>Phase diagrams</h3>
<p>In this example, we demonstrate another specialized program <code>flow</code>, which can be used to rapidly map out the phase diagram of a superconducting system.
The program is based on analysing the "flow" of the order parameter during selfconsistency iterations; the concept is explained in more detail in the supplemental information of <a href="https://arxiv.org/abs/1803.07076">arXiv:1803.07076</a>.
The program will be illustrated using a spin-valve setup similar to the previous section.
However, in this case we will assume zero temperature and perpendicular magnetizations, and investigate how the spin-mixing conductance <script type="math/tex"> G_\varphi </script> affects the stability of superconductivity.</p>
<p>An appropriate configuration file is:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># FI/S/FI Spin-valve setup.</span><span class="w"></span>

<span class="k">[superconductor]</span><span class="w"></span>
<span class="w">  </span><span class="c1"># Material itself</span><span class="w"></span>
<span class="w">  </span><span class="na">gap:             0.01</span><span class="w"></span>
<span class="w">  </span><span class="na">length:          1.00</span><span class="w"></span>

<span class="w">  </span><span class="c1"># Left interface</span><span class="w"></span>
<span class="w">  </span><span class="na">magnetization_a: [1,0,0]</span><span class="w"></span>
<span class="w">  </span><span class="na">spinmixing_a:    {1}</span><span class="w"></span>

<span class="w">  </span><span class="c1"># Right interface</span><span class="w"></span>
<span class="w">  </span><span class="na">magnetization_b: [0,1,0]</span><span class="w"></span>
<span class="w">  </span><span class="na">spinmixing_b:    {1}</span><span class="w"></span>
</code></pre></div>

<p>Save the file above as e.g. <code>spinvalve2.conf</code>, and run the following commands to start the simulations:</p>
<div class="codehilite"><pre><span></span><code><span class="k">for</span> n <span class="k">in</span> <span class="k">$(</span>seq <span class="m">0</span>.0 <span class="m">0</span>.1 <span class="m">1</span>.0<span class="k">)</span><span class="p">;</span> <span class="k">do</span>
  mkdir sim_<span class="si">${</span><span class="nv">n</span><span class="si">}</span><span class="p">;</span>
  <span class="nb">cd</span> sim_<span class="si">${</span><span class="nv">n</span><span class="si">}</span><span class="p">;</span>
  flow ../spinvalve2.conf <span class="si">${</span><span class="nv">n</span><span class="si">}</span> <span class="p">&amp;</span>
  <span class="nb">cd</span> ..<span class="p">;</span>
<span class="k">done</span>
</code></pre></div>

<p>According to the configuration file above, the order parameter is initially set to a small value <script type="math/tex"> \Delta = 0.01\Delta_0 </script>.
The simulation program then performs a fixed number of selfconsistency iterations, and determines whether the order parameter is spontaneously increasing (&gt;1) or decreasing (&lt;1) compared to its initial value.
This can be used to classify regions in parameter space as having a stable or unstable superconducting solution branch.</p>
<p>The simulations should take about 10 min to complete. 
The results can then be collected to a single output file:</p>
<div class="codehilite"><pre><span></span><code>cat sim_*/flow.dat <span class="p">|</span> cut -f <span class="m">2</span>,3 &gt; flow.dat
</code></pre></div>

<p>They are then straight-forward to visualize in Gnuplot:</p>
<div class="codehilite"><pre><span></span><code><span class="k">set</span><span class="w"> </span><span class="nb">xlabel</span><span class="w"> </span><span class="s">&#39;Spin-mixing conductance&#39;</span><span class="w"></span>
<span class="k">set</span><span class="w"> </span><span class="nb">ytics</span><span class="w"> </span><span class="p">(</span><span class="s">&#39;Normal&#39;</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="s">&#39;Super&#39;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>

<span class="k">plot</span><span class="w"> </span><span class="s">&#39;flow.dat&#39;</span><span class="w"> </span><span class="nb">u</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="p">(</span><span class="err">$</span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="nb">notitle</span><span class="w"></span>
</code></pre></div>
    </div>
    
    <div class="col-md-3 col-md-pull-9">
      <hr class="visible-xs visible-sm">
        <div class="well toc">
          <ul class="nav nav-stacked nav-pills">
            <li role="presentation" class="title"><a href='../page/index.html'>Overview</a></li>
          </ul>
          <hr>
          <ul class="nav nav-stacked nav-pills">
            
            <li role="presentation">
            <a href='../page/./01-installation.html'>Installation</a>
            
            </li>
            
            <li role="presentation" class="disabled">
            <a href='../page/./02-examples.html'>Tutorial</a>
            
            </li>
            
            <li role="presentation">
            <a href='../page/./03-config.html'>Configuration</a>
            
            </li>
            
            <li role="presentation">
            <a href='../page/./04-data.html'>Output files</a>
            
            </li>
            
          </ul>
        </div>
    </div>
    
  </div>

    <hr>    
    </div> <!-- /container -->
    <footer>
      <div class="container">
      <div class="row">
        <div class="col-xs-6 col-md-6"><p>GENEUS was developed by Jabir Ali Ouassou<br>&copy; 2022 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a>
                                          </p>
        </div>
        <div class="col-xs-6 col-md-6">
          <p class="text-right">
            Documentation generated by 
            <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
            
            
          </p>
        </div>
      </div>
      <br>
      </div> <!-- /container -->    
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
<!--
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
-->
    <script src="../js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../js/ie10-viewport-bug-workaround.js"></script>

    <!-- MathJax JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
        jax: ['input/TeX','input/MathML','output/HTML-CSS'],
        extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
      });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    
    <script src="../tipuesearch/tipuesearch_content.js"></script>
    <script src="../tipuesearch/tipuesearch_set.js"></script>
    <script src="../tipuesearch/tipuesearch.js"></script>
    
    
  </body>
</html>